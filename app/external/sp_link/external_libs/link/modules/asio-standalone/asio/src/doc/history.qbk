[/
 / Copyright (c) 2003-2023 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:history Revision History]

[heading Asio 1.28.0]

* Added missing handler tracking source location support to `awaitable<>`-based
  coroutine's ability to `co_await` asynchronous operations packaged as function
  objects.

* Add missing handler tracking source location support to `co_composed`.

* Fixed suppression of spurious 'potential null dereference' warnings, to work
  with older compilers.

* Fixed a bug where passing the deprecated `const_buffers_1` and
  `mutable_buffers_1` types to `asio::buffer()` would result in the contiguous
  iterator overloads being incorrectly chosen.

* Disabled the runtime Windows version test unless targeting older Windows
  versions.

* Fixed compatibility between buffered stream wrappers and move-constructible
  streams, such as `ssl::stream<>`.

* Marked `ip::address_v4::to_ulong` as deprecated in the documentation.

* Fixed shadowed variable warnings.

* Fixed `basic_socket_acceptor::async_accept` concept requirement checking to
  be compatible with lambdas that have a deduced return type.

* Fixed a feature detection macro used in `use_future`'s compatibility traits.

* Fixed `as_tuple` compatibility with legacy completion tokens.

* Fixed `redirect_error` compatibility with new completion tokens.

* Fixed a potential, Windows-specific program termination due to exceptions that
  should have been allowed to escape from a destructor.

* Fixed `this_coro` to prevent inadvertent `co_await` of boolean expressions.

* Fixed result handling in `experimental::use_coro` implementation.

* Fixed variadic template emulation for `is_async_operation` and
  `completion_signature_of`.

* Fixed incorrect reuse of a moved-from result in `experimental::promise`.

* Fixed `experimental::coro` use with custom allocators.

* Fixed clean up of internal I/O object structures when using [^io_uring].

* Use cached offset when seeking a file with seek_cur on Windows.

* Added immediate completion to asynchronous operation requirements.

* Added `any_completion_handler<>`, `co_composed`, and immediate completion
  support to the documentation overview.

* Added buffer literals to the documentation.

* Added a link to the
  [@https://github.com/chriskohlhoff/asio-debugger-extensions Asio debugger
  extensions] repository.

[heading Asio 1.27.0]

* Added the ability to customise the execution of a completion handler when an
  operation completes immediately. This change adds the
  `associated_immediate_executor` associator trait, `bind_immediate_executor`
  function, and `immediate_executor_binder` adapter. When a supported operation
  completes immediately (that is, within the initiating function) the
  associated immmediate executor is obtained, and the completion handler is
  delivered through that executor as if by using `asio::dispatch` on that
  executor. By default, the immediate executor delivers the completion handler
  as if using `asio::post` via the operation's I/O executor. For example, to
  allow a recursive call to the completion handler of an `async_read_some`
  operation, we may specify that immediate completion is delivered via a
  `system_executor`:[br]
  ``
  my_socket.async_read_some(my_buffer,
      bind_immediate_executor(
        system_executor(),
        [](error_code e, size_t n)
        {
          // ...
        }
      )
    );
  ``[br]
  Immediate execution is currently supported for asynchronous operations on
  reactor-based sockets and descriptors, and for asynchronous operations on
  channels.

* Added user-defined literals for buffer types. The `_buf` literal suffix,
  defined in namespace `asio::buffer_literals`, may be used to create
  const_buffer objects from string, binary integer, and hexadecimal integer
  literals. These buffer literals may be arbitrarily long. For example:[br]
  [pre
  using namespace asio::buffer_literals;

  asio::const_buffer b1 = "hello"_buf;
  asio::const_buffer b2 = 0xdeadbeef_buf;
  asio::const_buffer b3 = 0x01234567'89abcdef'01234567'89abcdef_buf;
  asio::const_buffer b4 = 0b1010101011001100_buf;
  ][br]
  The memory associated with a buffer literal is valid for the lifetime of the
  program. This means that the buffer can be safely used with asynchronous
  operations:[br]
  ``
  async_write(my_socket, "hello"_buf, my_handler);
  ``[br]

* Added a new protocol type `local::seq_packet_protocol` to represent `AF_UNIX`
  with `SOCK_SEQPACKET`.

* Exposed `sigaction()` flags via optional argument to `signal_set::add`. When
  registering a signal, it is now possible to pass flags that specify the
  behaviour associated with the signal. These flags are specified as an enum
  type in a new class, signal_set_base, and are passed to the underlying
  `sigaction()` call. For example:[br]
  ``
  asio::signal_set sigs(my_io_context);
  sigs.add(SIGINT, asio::signal_set::flags::restart);
  ``[br]
  Specifying flags other than `flags::dont_care` will fail unless `sigaction()`
  is supported by the target operating system. Since signal registration is
  global, conflicting flags (multiple registrations that pass differing flags
  other than `flags::dont_care`) will also result in an error.

* Change `allocator_binder`, `executor_binder`, and `cancellation_slot_binder`
  to support detection of unspecialised associators.

* Fixed ambiguity in `associated_cancellation_slot<reference_wrapper>::get()`.

* Fixed `awaitable` handling for completion signatures containing
  `std::exception_ptr`.

* Fixed `experimental::channel` `try_send` failure after a `cancel`.

* Fixed `thread_pool::join()` deadlock when the pool has no internal threads.

* Fixed pipe `release()` when using [^io_uring].

* Fixed a data initialisation issue in the [^io_uring] backend.

* Fixed a dangling reference issue in the execution context overload of
  `get_associated_executor`.

* Ensured buffered messages can still be received when an
  `experimental::channel` is closed.

* Fixed the `any_completion_handler` assignment operator to work correctly.

* Constrained the constructor of the move-only class template
  `any_completion_handler` to prevent accidental copying

* Suppressed spurious 'potential null dereference' warnings.

* Changed to use `uint64_t` for OpenSSL options, to match OpenSSL 3.

* Fixed `deferred` interoperability with multiple completion signatures.

* Fixed channels to support C++11 and later. Note that for C++11 and C++14,
  support is limited to channels with a single completion signature, or
  channels with a void() signature (plus the error signature added by the
  channel traits).

* Added `any_completion_handler` to the documentation.

[heading Asio 1.26.0]

* Fixed `spawn` and `co_spawn` implementations to dispatch cancellation
  handlers on the correct executor. When a completion handler uses a specified
  (i.e. non-default) associated executor, cancellation handlers are dispatched
  to the executor that was passed to `spawn()` or `co_spawn()`.

* Fixed `spawn` to ensure the completion handler is dispatched through the
  correct executor.

* Changed to use `snprintf` rather than `sprintf` on latest Xcode, to address
  deprecation warnings.

* Fixed compatibility between `co_spawn` and `any_completion_handler`.

* Fixed the arguments passed to `select_reactor::run` when it is run on an
  internal thread.

* Fixed compilation errors when `(BOOST_)ASIO_DISABLE_SMALL_BLOCK_RECYCLING` is
  defined.

* Updated detection of C++20 coroutine support on clang 14 and later.
  This includes the ability to use coroutines with libstdc++.

* Changed standard library feature detection to always enable
  `std::invoke_result` when targeting C++17 or later.

* Fixed detection of return type deduction with MSVC.

* Added a missing include in `experimental::coro` implementation.

* Updated the asynchronous operation requirements to relax the requirements on
  the associated executor.

* Added [^io_uring] to the implementation notes.

[heading Asio 1.25.0]

* Added the `consign` completion token adapter, which can be used to attach
  additional values to a completion handler. This is typically used to keep at
  least one copy of an object, such as a smart pointer, alive until the
  completion handler is called. For example:[br]
  ``
  auto timer1 = std::make_shared<asio::steady_timer>(my_io_context);
  timer1->expires_after(std::chrono::seconds(1));
  timer1->async_wait(
      asio::consign(
        [](asio::error_code ec)
        {
          // ...
        },
        timer1
      )
    );
  ``[br]

* Added `any_completion_handler<>`, which can be used to type-erase completion
  handlers. A typical use case is to enable separate compilation of
  asynchronous operation implementations. For example:[br]
  ``
  // Header file:

  void async_sleep_impl(
      asio::any_completion_handler<void(asio::error_code)> handler,
      asio::any_io_executor ex, std::chrono::nanoseconds duration);

  template <typename CompletionToken>
  inline auto async_sleep(asio::any_io_executor ex,
      std::chrono::nanoseconds duration, CompletionToken&& token)
  {
    return asio::async_initiate<
      CompletionToken, void(asio::error_code)>(
        async_sleep_impl, token, std::move(ex), duration);
  }

  // Separately compiled source file:

  void async_sleep_impl(
      asio::any_completion_handler<void(asio::error_code)> handler,
      asio::any_io_executor ex, std::chrono::nanoseconds duration)
  {
    auto timer = std::make_shared<asio::steady_timer>(ex, duration);
    timer->async_wait(asio::consign(std::move(handler), timer));
  }
  ``[br]

* Added `experimental::co_composed` which facilitates a lightweight
  implementation of user-defined asynchronous operations using C++20
  coroutines. The following example illustrates a simple asynchronous operation
  that implements an echo protocol in terms of a coroutine:[br]
  ``
  template <typename CompletionToken>
  auto async_echo(tcp::socket& socket,
      CompletionToken&& token)
  {
    return asio::async_initiate<
      CompletionToken, void(asio::error_code)>(
        asio::experimental::co_composed<
          void(asio::error_code)>(
            [](auto state, tcp::socket& socket) -> void
            {
              try
              {
                state.throw_if_cancelled(true);
                state.reset_cancellation_state(
                  asio::enable_terminal_cancellation());

                for (;;)
                {
                  char data[1024];
                  std::size_t n = co_await socket.async_read_some(
                      asio::buffer(data), asio::deferred);

                  co_await asio::async_write(socket,
                      asio::buffer(data, n), asio::deferred);
                }
              }
              catch (const asio::system_error& e)
              {
                co_return {e.code()};
              }
            }, socket),
        token, std::ref(socket));
  }
  ``[br]

* Add range-based experimental::make_parallel_group() overloads that may be used
  to launch a dynamically-sized set of asynchronous operations, where all
  operations are the same type. For example:[br]
  ``
  using op_type = decltype(
      socket1.async_read_some(
        asio::buffer(data1),
        asio::deferred
      )
    );

  std::vector<op_type> ops;
  ops.push_back(
      socket1.async_read_some(
        asio::buffer(data1),
        asio::deferred
      )
    );
  ops.push_back(
      socket2.async_read_some(
        asio::buffer(data2),
        asio::deferred
      )
    );

  asio::experimental::make_parallel_group(ops).async_wait(
      asio::experimental::wait_for_all(),
      [](
          std::vector<std::size_t> completion_order,
          std::vector<asio::error_code> e,
          std::vector<std::size_t> n
        )
      {
        for (std::size_t i = 0; i < completion_order.size(); ++i)
        {
          std::size_t idx = completion_order[i];
          std::cout << "socket " << idx << " finished: ";
          std::cout << e[idx] << ", " << n[idx] << "\n";
        }
      }
    );
  ``[br]
  Thanks go to Klemens Morgenstern for supplying part of this implementation.

* Added `any_completion_executor`, a type-erased wrappers for executors that
  are associated with completion handlers.

* Added missing `context` query to use_future's executor.

* Added nothrow constructor overloads to `execution::any_executor<>` and
  `any_io_executor`.

* Optimised representation of empty `execution::any_executor` objects to improve
  the performance of copy and move operations.

* Added an `associated_cancellation_slot` specialisation for
  `std::reference_wrapper`.

* Changed I/O objects to return their executors by const reference.

* Changed associated to use deduced return types for all two-argument `get`
  functions.

* Fixed `spawn` implementation to catch unhandled exceptions and rethrow them
  outside of the spawned "thread".

* Fixed cleanup of of terminal-state `spawn` "thread" objects.

* Changed semantics of `dispatch` to mean the executor is used as-is. An
  execution context's default executor is imbued with the possibly-blocking
  property.

* Deprecated the `execution::execute` customisation point. Use `execute` as a
  member function.

* Deprecated the concepts, traits, functions and customisation points related to
  senders and receivers.

* Added a C++11 `parallel_group` example.

* Fixed example code to not use the deprecated conversion of a resolve result to
  an endpoint.

* Fixed an ambiguity in `experimental::channel_traits` specialisations.

* Added a specialised channel implementation for the  for `R(error_code)`
  signature.

* Made `cancelled()` public on the `async_compose` 'self' object.

* Added io_executor_type and get_io_executor to the `async_compose` 'self'
  object.

* Fixed implementation of `release()` for Windows overlapped handles.

* Enabled deferred awaiting for `experimental::coro`, regularised
  `experimental::use_coro`, and fixed allocator handling. This means that
  `use_coro` does not return a coro object, just like use_awaitable does, i.e.
  it's an overhead that buys us type erasure. Allocators can now be set for
  `coro` by including `allocator_arg` in the coro signature.

* Cleaned up `experimental::promise` and made it an asynchronous operation
  object.

* Constrained `post`/`defer` overloads on ability to require `blocking.never`.

* Changed descriptor implementation to fall back to `fcntl` if `ioctl` fails
  with `ENOTTY` when setting non-blocking mode.

[heading Asio 1.24.0]

* Improved the performance of `awaitable<>`-based coroutines when they directly
  `co_await` an asynchronous operation, by eliminating the copy of the operation
  object in `await_transform`.

* Improved the performance of `spawn()`-based stackful coroutines by storing a
  reference to the yield context in the completion handler, rather than storing
  a copy of the executor.

* Fixed a C++03 build error by disabling `index_sequence` emulation when
  variadic templates are unavailable.

* Fixed detection of `std::aligned_alloc` for older Apple platforms.

* Removed faulty assertions from `experimental::coro` implementation.

* Added defence against Qt-defined macros when building with Intel C++.

* Ensured that a `spawn()`-based stackful coroutine is cleaned up immediately
  after it completes.

* Changed the implementation of the `select_reactor`, on Windows, to ensure that
  any exception resulting from failure to recreate its interrupter's sockets
  will be allowed to propagate out through `io_context::run()`.

* Changed the MSVC version used for the `system_error` workaround, as more
  recent runtime redistributables appear to have fixed the issue.

* Changed the `async_compose` example to use a return type compatible with the
  new `async_result` form.

[heading Asio 1.23.0]

* Added a deduced trailing return type, using `decltype`, to all asynchronous
  operations' initiating functions when using C++11. This change enables the
  new form of `async_result`, where the return type can vary per operation,
  for C++11.

* Moved `append`, `prepend`, `as_tuple`, and `deferred` to the `asio`
  namespace, and made them compatible with C++11. These are no longer
  experimental facilities, although the names have temporarily been retained
  under the `asio::experimental` namespace for backwards compatibility.

* Added `buffer()` overloads for contiguous containers, such as `std::span`.

* Added the ability for `awaitable<>`-based coroutines to directly `co_await`
  operations that are packaged as function objects. For example, using
  `deferred`:[br]
  ``
  asio::awaitable<void> my_coro()
  {
    asio::steady_timer timer(co_await asio::this_coro::executor);
    timer.expires_after(std::chrono::seconds(5));

    co_await timer.async_wait(asio::deferred);
  }
  ``
  or with a handcrafted function object:[br]
  ``
  asio::awaitable<void> my_coro()
  {
    asio::steady_timer timer(co_await asio::this_coro::executor);
    timer.expires_after(std::chrono::seconds(5));

    co_await [&](auto&& token)
    {
      return timer.async_wait(std::forward<decltype(token)>(token));
    };
  }
  ``[br]

* Changed `spawn()` to be a completion token-based asynchronous operation. This
  introduces new `spawn()` overloads that conform to the requirements for
  asynchronous operations. For example:[br]
  ``
  std::string do_read(asio::yield_context yield)
  {
    char data[1024];
    size_t n = my_socket.async_read_some(asio::buffer(data), yield);
    return std::string(data, n);
  }

  asio::spawn(my_executor, do_read,
      [](std::exception_ptr ex, std::string result)
      {
        // ...
      });
  ``
  These new `spawn()` overloads support cancellation, and the
  `basic_yield_context` completion token has also been enhanced to support
  move-only and variadic result types. When targeting C++11 and later, these
  functions are implemented in terms of Boost.Context directly. The existing
  overloads have been retained but are deprecated.

* Added the `is_async_operation` trait and `async_operation` concept. The
  `is_async_operation` trait may be used to determine if a function object, and
  optional arguments, may be called to initiate an asynchronous operation. For
  example, when using `deferred`:[br]
  ``
  auto d = my_timer.async_wait(asio::deferred);
  static_assert(asio::is_async_operation<decltype(d)>::value);
  ``[br]
  or with a handcrafted asynchronous operation:[br]
  ``
  struct my_async_op
  {
    asio::ip::tcp::socket& socket_ = ...;

    template <typename Token>
    auto operator()(asio::const_buffer data, Token&& token)
    {
      return asio::async_write(socket_, data,
          std::forward<Token>(token));
    }
  };

  static_assert(
      asio::is_async_operation<
        my_async_op, asio::const_buffer>::value);
  ``[br]

* Added the `completion_signature_of` trait. The `completion_signature_of`
  trait (and corresponding type alias `completion_signature_of_t`) may be used
  to determine the completion signature of an asynchronous operation. For
  example:[br]
  ``
  auto d = my_timer.async_wait(asio::deferred);
  using sig = asio::completion_signature_of<decltype(d)>::type;
  // sig is void(error_code)
  ``[br]
  or with a handcrafted asynchronous operation:[br]
  ``
  struct my_async_op
  {
    asio::ip::tcp::socket& socket_ = ...;

    template <typename Token>
    auto operator()(asio::const_buffer data, Token&& token)
    {
      return asio::async_write(socket_, data,
          std::forward<Token>(token));
    }
  };

  using sig =
    asio::completion_signature_of<
      my_async_op, asio::const_buffer>::type;
  // sig is void(error_code, size_t)
  ``[br]

* Added converting move construction/assignment to posix descriptors, serial
  ports, pipes, Windows `object_handle`, Windows stream handles, and Windows
  random-access handles.

* Added `release()` member functions to pipes, Windows stream handles, and
  Windows random-access handles.

* Enabled support for `Endpoint` implementations that return `void` pointers
  from their `data()` member functions, as per the documented `Endpoint` type
  requirements.

* Removed `all()` and `race()` from `experimental::promise`, as
  `experimental::parallel_group` covers this functionality.

* Added source locations to exceptions and error codes produced by the
  synchronous and asynchronous operations.

* Fixed compatibility with OpenSSL 3.0.4 and later.

* Fixed compatibility with with [^-masm=intel].

* Explicitly stated that socket `shutdown()` calls are thread-safe with respect
  to certain other synchronous operations on the same socket.

* Optimised the move construction of I/O objects where only the executor type
  differs.

* Fixed the detection of `std::invoke_result` for clang/libc++.

* Fixed an issue where `experimental::parallel_group` initiation incorrectly
  moved arguments instead of forwarding them.

* Fixed a sequencing issue in the implementation of `post()`, `dispatch()`,
  and `defer()`, where the the associated allocator may be obtained from an
  already moved-from completion handler.

* Fixed the `awaitable<>` implementation to propagate exceptions from awaited
  initiation functions through the current completion handler.

* Fixed detection of `std::aligned_alloc` with [^gcc].

* Changed to avoid using the soon-to-be-deprecated `std::aligned_storage` on
  newer compilers.

* Fixed various compiler warnings.

* Updated all composed operations examples, and the C++11 timeouts example, to
  use the new `async_result` form.

* Added composed operation and coroutine examples for C++20.

* Added pkg-config support.

[heading Asio 1.22.2]

* On Windows, changed the file support to open files using the same sharing mode
  as `fopen()`.

* On Linux, fixed the UNIX domain sockets implementation to correctly handle
  `EAGAIN` as an indication of an in-progress connect operation.

* Fixed `experimental::basic_channel::reset()` and
  `experimental::basic_concurrent_channel::reset()` so that they work correctly
  for an unclosed channel.

* Fixed potential undefined behaviour in the `experimental::promise` operations
  `race()` and `all()`.

* Changed the `co_spawn` implementation to explicitly dispatch cancellation
  signals through the specified executor, if the the completion handler has an
  associated executor of its own.

* Added more detailed reference documentation to `make_strand()`,
  `make_work_guard()`, `ip::address_v4`, `ip::address_v6`,
  `experimental::basic_channel`, and `experimental::basic_concurrent_channel`.

* Re-arranged and extended the Overview documentation to cover files, pipes,
  `async_compose`, `experimental::deferred`, `experimental::parallel_group`,
  `experimental::promise`, channels, and completion token adapters.

* Reverted the `io_context` reference documentation to use `executor_work_guard`
  when preventing the `io_context` from running out of work.

* Removed references to `deadline_timer` from the Overview documentation.

* Added reference documentation cross-references to asynchronous model elements.

[heading Asio 1.22.1]

* Added `bind_allocator`, to simplify associating a custom allocator with a
  completion token or handler.

* Added the `file_base::sync_all_on_write` flag, which maps to `O_SYNC` on POSIX
  and `FILE_FLAG_WRITE_THROUGH` on Windows.

* Added missing implementation of `basic_file::release()`.

* Added per-operation cancellation support to signal sets.

* Exposed `recycling_allocator` as part of the public interface.

* Added the `nodiscard` attribute to the following functions:
  * `bind_allocator()`
  * `bind_cancellation_slot()`
  * `bind_executor()`
  * `buffer()`
  * `dynamic_buffer()`
  * `experimental::append()`
  * `experimental::as_single()`
  * `experimental::as_tuple()`
  * `experimental::make_parallel_group()`
  * `experimental::prepend()`
  * `get_associated_allocator()`
  * `get_associated_cancellation_slot()`
  * `get_associated_executor()`
  * `make_work_guard()`

* Added compatibility with OpenSSL 3.0, particularly when deprecated
  functionality is disabled.

* Added support for adopting an existing `SSL*` into an `ssl::stream<>`.

* Enabled `executor_work_guard<>` even when `ASIO_NO_TS_EXECUTORS` is defined.

* Enabled movable socket iostreams when using clang.

* Fixed `bind_cancellation_slot` compatibility with legacy completion tokens.

* Fixed `bind_executor` compatibility with legacy completion tokens.

* Fixed `associator` specialisations for `experimental::append` and
  `experimental::prepend`, to correctly propagate the associated allocator,
  executor, and cancellation slot.

* Fixed 'zero as null pointer constant' warning in C++20 coroutines
  implementation of `awaitable`.

* Ensured concurrency hint preprocessor macros are made available when
  [^asio/io_context.hpp] is included.

* Fixed issue where the primary `associated_allocator` template was not
  correctly detecting the nested `T::allocator_type`.

* Fixed [^io_uring] implementation of `async_receive_from` operation for
  sockets.

* Fixed [^io_uring] implementation of `write_some_at` operation for files.

* Changed [^io_uring] implementation to correctly check that it is not the
  default before registering with reactor.

* Fixed a circular inclusion issue when using [^io_uring] in some build
  configurations.

* Fixed `experimental::coro`'s per-operation cancellation to clear the slot at
  completion of each operation.

* Fixed memory management in `experimental::promise`'s type-erased completion
  handlers.

* Fixed move `operator=` implementation for `ssl::stream`.

* Fixed `any_io_executor` implementation to work when both
  `ASIO_USE_TS_EXECUTOR_AS_DEFAULT` and `ASIO_SEPARATE_COMPILATION` are
  defined.

* Fixed implementation of `basic_socket::at_mark()` when using the
  `sockatmark()` system call.

* Changed the recycling allocator to use the default alignment as the minimum
  alignment for allocations.

* Added additional standard header file includes, as required by newer
  compilers.

* Added a workaround for apparent coroutine codegen bug with Apple's clang.

* Fixed various warnings in the examples and unit tests.

* Added a C++11 example showing file descriptor passing over local sockets.
  Thanks to Heiko Hund for providing this example.

* Added C++14 examples of wrapping callback-based APIs in asynchronous
  operations.

* Added an overview of Asio's asynchronous model to the documentation.

* Reworked reference documentation in terms of completion tokens.

* Updated documentation of asynchronous operation requirements to use new
  completion token form.

* Updated documentation for `dispatch()`, `post()`, and `defer()` to cover both
  the old and new executor forms.

* Documented per-operation cancellation for serial ports.

* Clarified the non-concurrency guarantees made for allocators.

[heading Asio 1.22.0]

* Improved error messages emitted by `ssl` facilities.

* Fixed `bind_executor` compatibility with completion tokens.

* Fixed build errors when `ASIO_USE_TS_EXECUTOR_AS_DEFAULT` is defined.

* Fixed corruption, cleanup issues in channel implementation.

* Added missing move assignment operator to `awaitable<>`.

* Fixed an access violation when using coroutines with MSVC, due to incorrect
  alignment of allocated memory.

* Fixed a cleanup issue in `experimental::parallel_group` that occured when the
  execution context was shut down with parallel operations still pending.

* Fixed header inclusion order problem when io_uring is enabled.

* Eliminated `shared_ptr` use from `experimental::coro` `co_spawn()`
  implementation.

* Prevented `async_resume` from being called on `experimental::coro`
  temporaries.

* Made `awaitable_operators.hpp` header self-contained.

* Added clarifications to the documentation on concurrency hints.

* Added documentation on error handling techniques for C++20 coroutines.

* Added channel-based proxy example.

* Regenerated `ssl` certificates used in examples.

[heading Asio 1.21.0]

* Added an io_uring backend. This backend may be used for all I/O objects,
  including sockets, timers, and posix descriptors.[br]
  [br]
  The backend is disabled by default, and must be enabled by defining both
  `ASIO_HAS_IO_URING` and `ASIO_DISABLE_EPOLL`.[br]
  [br]
  Simply defining `ASIO_HAS_IO_URING` alone will enable the backend without
  using it for the existing I/O objects. This allows it to be used for I/O
  objects that require io_uring support, such as files.[br]
  [br]
  This support depends on the [^liburing] library at both compile and link
  time. Add `-luring` to your list of libraries for linking.

* Added support for files. This introduces new classes for stream-oriented and
  random-access files. For example, to write to a newly created stream-oriented
  file:[br]
  ``
  asio::stream_file file(
      my_io_context, "/path/to/file",
      asio::stream_file::write_only
        | asio::stream_file::create
        | asio::stream_file::truncate);

  file.async_write_some(my_buffer,
      [](error_code e, size_t n)
      {
        // ...
      });
  ``[br]
  or to read from a random-access file:[br]
  ``
  asio::random_access_file file(
      my_io_context, "/path/to/file",
      asio::random_access_file::read_only);

  file.async_read_some_at(1234, my_buffer,
      [](error_code e, size_t n)
      {
        // ...
      });
  ``[br]
  This feature currently supports I/O completion ports on Windows, and io_uring
  on Linux (define `ASIO_HAS_IO_URING` to enable).

* Added support for portable pipes. This change add supports for pipes on POSIX
  and Windows (when I/O completion ports are available). For example, to create
  and use a connected pair of pipe objects:[br]
  ``
  asio::readable_pipe read_end;
  asio::writable_pipe write_end;
  asio::connect_pipe(read_end, write_end);

  write_end.async_write_some(my_write_buffer,
      [](error_code e, size_t n)
      {
        // ...
      });

  read_end.async_read_some(my_read_buffer,
      [](error_code e, size_t n)
      {
        // ...
      });
  ``[br]

* Added support for registered buffers. The `mutable_registered_buffer` and
  `const_registered_buffer` classes are buffer sequence types that represent
  registered buffers. These buffers are obtained by first performing a buffer
  registration:[br]
  ``
    auto my_registration =
      asio::register_buffers(
          my_execution_context,
          my_buffer_sequence);
  ``[br]
  The registration object must be maintained for as long as the buffer
  registration is required. The supplied buffer sequence represents the
  memory location or locations that will be registered, and the caller
  must ensure they remain valid for as long as they are registered. The
  registration is automatically removed when the registration object is
  destroyed. There can be at most one active registration per execution
  context.[br]
  [br]
  The registration object is a container of registered buffers. Buffers
  may be obtained from it by iterating over the container, or via direct
  index access:[br]
  ``
    asio::mutable_registered_buffer my_buffer
      = my_registration[i];
  ``[br]
  The registered buffers may then be passed directly to operations:[br]
  ``
  asio::async_read(my_socket, my_buffer,
      [](error_code ec, size_t n)
      {
        // ...
      });
  ``[br]
  Buffer registration supports the io_uring backend when used with read and
  write operations on descriptors, files, pipes, and sockets. For portability,
  the facility may be used on other platforms, but the registered buffers will
  behave as normal buffers.

* Added experimental support for channels. This adds templates
  `experimental::basic_channel` and `experimental::basic_concurrent_channel`,
  with aliases `experimental::channel` and `experimental::concurrent_channel`.
  Channels may be used to send completions as messages. For example:[br]
  ``
  // Create a channel with no buffer space.
  channel<void(error_code, size_t)> ch(ctx);

  // The call to try_send fails as there is no buffer
  // space and no waiting receive operations.
  bool ok = ch.try_send(asio::error::eof, 123);
  assert(!ok);

  // The async_send operation is outstanding until
  // a receive operation consumes the message.
  ch.async_send(asio::error::eof, 123,
      [](error_code ec)
      {
        // ...
      });

  // The async_receive consumes the message. Both the
  // async_send and async_receive operations complete
  // immediately.
  ch.async_receive(
      [](error_code ec, size_t n)
      {
        // ...
      });
  ``[br]

* Implemented improvements to `experimental::coro`.
  * Added overload so member functions can provide an explicit executor.
  * Added `co_spawn` for `coro` tasks.
  * Added reference and overview documentation.
  * Adopted awaitable cancellation model.
  * Refactored implementation.

* Disabled `aligned_alloc` on [^clang] when using an MSVC runtime.

* Changed to use a faster implementation for `ip::network_v4::canonical()`.

* Added template specialisations for common uses to improve compile time.

* Reduced the size of `io_context` executors to a single pointer.

* Increased the small object buffer size for `execution::any_executor` and
  `any_io_executor`.

* Fixed multi-signature handling when variadic templates are disabled.

* Fixed compatibility with new versions of [^gcc] and [^clang].

* Fixed compilation on Solaris.

* Fix defence against Qt-defined macros when building with MSVC.

* Fixed various warnings.

[heading Asio 1.20.0]

* Fixed `experimental::coro` compatibility with [^gcc].

* Fixed `experimental::promise` compatibility with [^gcc].

* Added documentation for per-operation cancellation.

* Added documentation for `parallel_group`.

* Added overview documentation for `experimental::coro`.

* Added some missing C++14 examples.

* Updated C++20 coroutines overview documentation.

[heading Asio 1.19.2]

* Cleaned up memory recycling to ensure the cache size is used consistently.

* Changed `parallel_group` to use the recycling allocator for shared state.

* Changed `awaitable` memory recycling to use the configurable cache size.

* Ensured `parallel_group` respects operations' associated executors.

* Added defence against macros defined by Qt.

* Added missing `boost_` prefix to namespaces during boostification.

* Added missing lvalue-qualified overloads for `deferred` operator().

* Added a tag to disambiguate `deferred` constructors.

* Added missing `push`/`pop_options` includes.

* Fixed argument evaluation order issue with a potentially moved-from variable
  in `awaitable` implementation.

* Enabled "expression SFINAE" for recent MSVC using `/std:c++latest`.

* Fixed compilation errors when `dev_poll_reactor` backend is used.

* Fixed handler type requirements checking to reflect rvalue completion handler
  invocation.

* Fixed `posix::basic_stream_descriptor` move operations to work with
  non-defaulted executors.

* Added missing move of executor in strand implementation.

[heading Asio 1.19.1]

* Fixed handling of move-only results with awaitable operators `&&` and `||`.

* Fixed `strand<>` to avoid using a potentially moved-from executor.

* Fixed order of `_aligned_malloc` arguments for MSVC.

* Ensured handler alignment requirements are respected by `cancellation_signal`.

* Ensured [^gcc] tests are not used for [^clang] when detecting compiler
  features.

* Disabled coroutines support for the [^clang] shipped with MSVC.

* Fixed compatibility with recent LibreSSL when `OPENSSL_NO_SSL_INTERN` is
  defined.

* Documented supported cancellation types for individual asynchronous
  operations.

* Ensured un-cancelled ops are correctly placed back in the queue.

[heading Asio 1.19.0]

* Added support for cancellation of individual asynchronous operations.
  Cancellation is implemented by having each completion handler carry an
  associated `CancellationSlot`, a lightweight cancellation channel that is
  specified through the new `associated_cancellation_slot` associator. A
  concrete `CancellationSlot` implementation is provided in the form of the
  `cancellation_signal` and `cancellation_slot` classes. In conjunction with
  the `bind_cancellation_slot` helper function, these may be used to hook
  cancellation into asynchronous operations. However, it should be noted that
  these classes are the low-level building blocks of cancellation, and most use
  cases should use a higher level abstraction for cancellation, such as
  `experimental::parallel_group` or the new logical operators for `awaitable`
  (see below). The ability to cancel individual operations, or composed
  operations, is currently supported by:
  * timers
  * sockets on POSIX and Windows
  * POSIX descriptors
  * Windows HANDLEs
  * SSL streams
  * all Asio-provided composed operations such as `async_read` and `async_write`
  * compositions based on `async_compose`
  * C++20 coroutines that use `awaitable`
  * C++20 coroutines that use the new `experimental::coro` (see below)
  * the new `experimental::parallel_group` operation (see below)
  * the new `experimental::promise` class (see below)

* Added the `associator` trait. The `associator` trait is used to generically
  forward associators, such as `associated_executor` and `associated_allocator`,
  through intermediate completion handlers. For example:[br]
  ``
  template <typename Handler>
  struct intermediate_handler
  {
    Handler handler_;

    template <typename... Args>
    void operator()(Args&... args)
    {
      // ...
    }
  };

  namespace asio {
    template <
        template <typename, typename> class Associator,
        typename Handler,
        typename DefaultCandidate>
    struct associator<
        Associator,
        intermediate_handler<Handler>,
        DefaultCandidate>
    {
      using type =
        typename Associator<Handler, DefaultCandidate>::type;

      static type get(
          const intermediate_handler<Handler>& h,
          const DefaultCandidate& c = DefaultCandidate()) noexcept
      {
        return Associator<Handler, DefaultCandidate>::get(
            h.handler_, c);
      }
    };
  } // namespace asio
  ``[br]

* Changed all asynchronous operations implemented in Asio to invoke their
  completion handlers as rvalue references. This allows an rvalue reference
  qualifier to be added to the function call operator.

* Added support for asynchronous operations with multiple completion signatures.
  Completion signatures may also specify that they are `noexcept`, and whether
  they are lvalue-invocable (and thus do not "consume" the completion handler)
  or rvalue-invocable (and thus do "consume" the handler, indicating an end to
  the asynchronous operation). For example:[br]
  ``
  auto my_async_operation(...,
      asio::completion_token_for<
        void(intermediate_result_type) & noexcept,
        void(final_result_type) &&
      > auto&& token)
  {
    // ...
  }
  ``[br]

* Added `operator&&` and `operator||` for `awaitable<>`. The logical operators
  `||` and `&&` have been overloaded for `awaitable<>`, to allow coroutines to
  be trivially awaited in parallel.[br]
  [br]
  When awaited using `&&`, the `co_await` expression waits until both operations
  have completed successfully. As a "short-circuit" evaluation, if one
  operation fails with an exception, the other is immediately cancelled.
  For example:[br]
  ``
  std::tuple<std::size_t, std::size_t> results =
    co_await (
      async_read(socket, input_buffer, use_awaitable)
        && async_write(socket, output_buffer, use_awaitable)
    );
  ``[br]
  When awaited using `||`, the `co_await` expression waits until either
  operation succeeds. As a "short-circuit" evaluation, if one operation
  succeeds without throwing an exception, the other is immediately cancelled.
  For example:[br]
  ``
  std::variant<std::size_t, std::monostate> results =
    co_await (
      async_read(socket, input_buffer, use_awaitable)
        || timer.async_wait(use_awaitable)
    );
  ``[br]
  The operators may be enabled by adding the `#include`:[br]
  ``
  #include <asio/experimental/awaitable_operators.hpp>
  ``[br]
  and then bringing the contents of the `experimental::awaitable_operators`
  namespace into scope:[br]
  ``
  using namespace asio::experimental::awaitable_operators;
  ``[br]

* Added the `experimental::as_tuple` completion token adapter. The `as_tuple`
  completion token adapter can be used to specify that the completion handler
  arguments should be combined into a single tuple argument. The `as_tuple`
  adapter may be used in conjunction with `use_awaitable` and structured
  bindings as follows:[br]
  ``
  auto [e, n] = co_await socket.async_read_some(
      asio::buffer(data), as_tuple(use_awaitable));
  ``[br]
  Alternatively, it may be used as a default completion token like so:[br]
  ``
  using default_token = as_tuple_t<use_awaitable_t<>>;
  using tcp_socket = default_token::as_default_on_t<tcp::socket>;
  // ...
  awaitable<void> do_read(tcp_socket socket)
  {
    // ...
    auto [e, n] = co_await socket.async_read_some(asio::buffer(data));
    // ...
  }
  ``[br]

* Added the `experimental::append` completion token adapter. The `append`
  completion token adapter can be used to pass additional completion handler
  arguments at the end of the completion signature. For example:[br]
  ``
  timer.async_wait(
      asio::experimental::append(
        [](std::error_code ec, int i)
        {
          // ...
        },
      42)
    );

  std::future<int> f = timer.async_wait(
      asio::experimental::append(
        asio::use_future,
        42
      )
    );
  ``[br]

* Added the `experimental::prepend` completion token adapter. The `prepend`
  completion token adapter can be used to pass additional arguments before the
  existing completion handler arguments. For example:[br]
  ``
  timer.async_wait(
      asio::experimental::prepend(
        [](int i, std::error_code ec)
        {
          // ...
        },
      42)
    );

  std::future<std::tuple<int, std::error_code>> f = timer.async_wait(
      asio::experimental::prepend(
        asio::use_future,
        42
      )
    );
  ``[br]

* Added the `experimental::deferred` completion token. The `deferred`
  completion token takes a call to an asynchronous operation's initiating
  function and turns it into a function object that accepts a completion token.
  For example:[br]
  ``
  auto deferred_op =
    timer.async_wait(
      asio::experimental::deferred);
  ...
  std::move(deferred_op)(
      [](std::error_code ec){ ... });
  ``[br]
  or:[br]
  ``
  auto deferred_op =
    timer.async_wait(
      asio::experimental::deferred);
  ...
  std::future<void> =
    std::move(deferred_op)(
      asio::use_future);
  ``[br]
  The deferred token also supports chaining, to create simple compositions:[br]
  ``
  auto deferred_op =
    timer.async_wait(
      asio::experimental::deferred(
        [&](std::error_code ec)
        {
          timer.expires_after(
              std::chrono::seconds(1));

          return timer.async_wait(
              asio::experimental::deferred);
        });
  ...
  std::future<void> = std::move(deferred_op)(asio::use_future);
  ``[br]

* Added the `experimental::parallel_group` class and
  `experimental::make_parallel_group` function. This utility may be used to
  launch work that is performed in parallel, and wait for one or all of the
  operations to complete. A `parallel_group` implements automatic cancellation
  of incomplete operations. For example:[br]
  ``
  experimental::make_parallel_group(
      [&](auto token)
      {
        return stream.async_read_some(asio::buffer(data), token);
      },
      [&](auto token)
      {
        return timer.async_wait(token);
      }
    ).async_wait(
      experimental::wait_for_one(),
      [](
          std::array<std::size_t, 2> completion_order,
          std::error_code ec1, std::size_t n1,
          std::error_code ec2
      )
      {
        // ...
      }
    );
  ``[br]
  The conditions for completion of the group may be specified using one of the
  four provided function objects `wait_for_all`, `wait_for_one`,
  `wait_for_one_success`, and `wait_for_one_error`, or with a custom function.
  The `parallel_group` class can also be combined with `deferred` as
  follows:[br]
  ``
  experimental::make_parallel_group(
      stream.async_read_some(asio::buffer(data), experimental::deferred),
      timer.async_wait(experimental::deferred)
    ).async_wait(
      // ...
    );
  ``[br]
  Note: for maximum flexibility, `parallel_group` does not propagate the
  executor automatically to the operations within the group.

* Added `experimental::promise`. The `promise` type allows eager execution and
  synchronisation of async operations. For example:[br]
  ``
  auto promise = async_read(
      stream, asio::buffer(my_buffer),
      asio::experimental::use_promise);

  ... do other stuff while the read is going on ...

  promise.async_wait( // completion the operation
      [](error_code ec, std::size_t bytes_read)
      {
        ...
      });
  ``[br]
  Promises can be safely disregarded if the result is no longer required.
  Different operations can be combined to either wait for all to complete
  or for one to complete (and cancel the rest). For example, to wait for
  one to complete:[br]
  ``
  auto timeout_promise =
    timer.async_wait(
      asio::experimental::use_promise);

  auto read_promise = async_read(
      stream, asio::buffer(my_buffer),
      asio::experimental::use_promise);

  auto promise =
    asio::experimental::promise<>::race(
      timeout_promise, read_promise);

  promise.async_wait(
      [](std::variant<error_code, std::tuple<error_code, std::size_t>> v)
      {
        if (v.index() == 0) {} //timed out
        else if (v.index() == 1) // completed in time
      });
  ``[br]
  or to wait for all to complete:[br]
  ``
  auto write_promise = async_write(
      stream, asio::buffer(my_write_buffer),
      asio::experimental::use_promise);

  auto read_promise = async_read(
      stream, asio::buffer(my_buffer),
      asio::experimental::use_promise);

  auto promise =
    asio::experimental::promise<>::all(
      write_promise, read_promise);

  promise.async_wait(
      [](std::tuple<error_code, std::size_t> write_result,
        std::tuple<error_code, std::size_t> read_result)
      {
      });
  ``[br]
  Thanks go to Klemens Morgenstern for contributing this feature.

* Added the `experimental::coro` class template. The `coro` type is a C++20
  coroutine primitive for resumable functions, with the ability to combine both
  asynchronous waiting (`co_await`) and yielding (`co_yield`) into a single,
  stateful control flow. For example:[br]
  ``
  #include <asio.hpp>
  #include <asio/experimental/coro.hpp>

  using asio::ip::tcp;

  asio::experimental::coro<std::string> reader(tcp::socket& sock)
  {
    std::string buf;
    while (sock.is_open())
    {
      std::size_t n = co_await asio::async_read_until(
          sock, asio::dynamic_buffer(buf), '\n',
          asio::experimental::use_coro);
      co_yield buf.substr(0, n);
      buf.erase(0, n);
    }
  }

  asio::awaitable<void> consumer(tcp::socket sock)
  {
    auto r = reader(sock);
    auto msg1 = co_await r.async_resume(asio::use_awaitable);
    std::cout << "Message 1: " << msg1.value_or("\n");
    auto msg2 = co_await r.async_resume(asio::use_awaitable);
    std::cout << "Message 2: " << msg2.value_or("\n");
  }

  asio::awaitable<void> listen(tcp::acceptor& acceptor)
  {
    for (;;)
    {
      co_spawn(
          acceptor.get_executor(),
          consumer(co_await acceptor.async_accept(asio::use_awaitable)),
          asio::detached);
    }
  }

  int main()
  {
    asio::io_context ctx;
    tcp::acceptor acceptor(ctx, {tcp::v4(), 54321});
    co_spawn(ctx, listen(acceptor), asio::detached);
    ctx.run();
  }
  ``[br]
  Thanks go to Klemens Morgenstern for contributing this feature.

* Added move assignment to `ssl::stream<>`.

* Changed `co_spawn` to `dispatch` the coroutine's initial step to the executor,
  and to only `post` the completion handler if the coroutine did not otherwise
  perform a context switch (i.e. a `co_await` on an asynchronous operation).

* Enabled additional optimisations for `any_executor` and `any_io_executor`
  when used with asynchronous operations.

* Added the `nodiscard` attribute to `awaitable<>`.

* Increased the number of cached slots in the default recycling allocator.
  This number defaults to 2, but may also be specified by defining the
  `ASIO_RECYCLING_ALLOCATOR_CACHE_SIZE` macro.

* Disabled the `std::system_error` message workaround for recent MSVC.

* Changed the default allocator behaviour to respect alignment requirements,
  to support over-aligned types. Requires C++17 or later, or Boost.

* Ensured the result strings are always initialised in reverse name resolution.

* Fixed recursive template instantiation issues in
  `use_awaitable_t::executor_with_default`.

* Fixed the `any_io_executor` equality operators to correctly return a result
  based on the target executor.

[heading Asio 1.18.2]

* Added `ip::scope_id_type` type alias.

* Added `ip::port_type` type alias.

* Added `std::hash` specialisations for IP addresses.

* Added `std::hash` specialisations for `ip::basic_endpoint<>`.

* Refactored SFINAE usage to improve compile times.

* Added friendship support to customisation points, and made most
  customisations private.

* Changed `any_io_executor` to a "strong typedef"-style class.

* Fixed `experimental::as_single` to work with handler hook deprecation.

* Ensured pthread condition variable attributes are cleaned up on all
  platforms.

* Clarified thread safety notes on sockets and descriptors.

* Ensured `errno` is not overwritten if `socket()` fails on macOS/FreeBSD.

* Fixed work tracking for `io_context` and `thread_pool` executors when
  move-assigned.

* Ensured internal `call_stack` objects are accessed only from implementation
  files.

* Fixed I/O object move-assignment to ensure the executor is left in a valid
  state.

* Fixed detection of compiler support for defaulted template argument on
  functions with MSVC.

* Prevented the `blocking.always` property from being used with `strand<>`, as
  it did not produce the correct semantics.

* Removed deprecated file [^asio/impl/src.cpp].

[heading Asio 1.18.1]

* Enabled support for UNIX domain sockets on Windows. From Windows 10, UNIX
  domain sockets (a.k.a "local" sockets) are supported on Windows, with the
  exception of the `connect_pair` function (which will fail with an
  operation_not_supported error).

* Added executor-converting construction and assignment to `ip::basic_resolver`.

* Added compatibility between polymorphic executors and the (deprecated) handler
  invocation hook.

* Added the `experimental::as_single` completion token adapter. The `as_single`
  completion token adapter can be used to specify that the completion handler
  arguments should be combined into a single argument. For completion signatures
  with a single parameter, the argument is passed through as-is. For signatures
  with two or more parameters, the arguments are combined into a tuple. The
  `as_single` adapter may be used in conjunction with `use_awaitable` and
  structured bindings as follows:[br]
  ``
  auto [e, n] = co_await socket.async_read_some(
      asio::buffer(data), as_single(use_awaitable));
  ``[br]
  Alternatively, it may be used as a default completion token like so:[br]
  ``
  using default_token = as_single_t<use_awaitable_t<>>;
  using tcp_socket = default_token::as_default_on_t<tcp::socket>;
  // ...
  awaitable<void> do_read(tcp_socket socket)
  {
    // ...
    auto [e, n] = co_await socket.async_read_some(asio::buffer(data));
    // ...
  }
  ``[br]

* Added support for `MSG_NOSIGNAL` on more platforms by using  `_POSIX_VERSION`
  to detect whether it is supported.

* Added the ability to compile using libpthread on Windows.

* Added workarounds for the Intel C++ compiler.

* Added more support for detecting and optimising for handlers that have no
  custom executor.

* Reduced lock contention for timer cancellation on Windows.

* Reinstated a previously removed null-pointer check, as it had a measurable
  impact on performance.

* Fixed the `executor` concept to test for a const-qualified `execute()`.

* Fixed `any_executor` support for builds without RTTI support.

* Fixed the `thread_pool` unit test to work without RTTI support.

* Fixed C++20 coroutines compatibility with clang on Windows.

* Fixed some compatibility issues with Windows Runtime.

* Fixed shadow name warnings caused by addition of `asio::query`.

* Fixed a "logical or of equal expressions" warning on linux.

* Fixed a benign switch fallthrough warning.

* Added missing `push/pop_options.hpp` includes.

* Suppressed zero-as-null-pointer-constant warnings.

* Fixed a comma-operator warning.

* Updated the documentation to clarify when the [^select] reactor is used on
  Windows.

* Fixed potential ambiguity caused by `any_executor` comparisons and conversion.

* Added detection of non-experimental C++20 coroutines on MSVC 19.8.

* Fixed compatibility with uClibc.

* Fixed `strand<>` adaptation of Networking TS executors when targeting older
  C++ versions or less conformant compilers.

[heading Asio 1.18.0]

* Marked the `basic_socket_acceptor` move constructor as `noexcept`.

* Added workarounds for various issues in [^gcc] 10's coroutine support.

* Added standard executor support to `windows::overlapped_ptr`.

* Added missing compatibility macros for the `execution::receiver_of` concept.

* Added short-circuited evaluation to `execution::executor`,
  `execution::operation_state`,`execution::sender`, `execution::receiver`,
  `execution::receiver_of`, and `execution::scheduler` concepts and the
  corresponding traits. These now test first for well-formed CPO expressions
  (or, in the case of senders, a specialised `sender_traits` template) and, if
  not valid, short-circuit the remainder of the evaluation. This helps prevent
  recursive template instantiations that can occur in some contexts.

* Added constraints to the `strand` template's constructor, to prevent template
  instantiation recursion.

* Changed Asio's internal executor adapters to prevent template instantiation
  recursion.

* Added constraints to the `execution::any_executor` template's converting
  constructors, as per the specification.

* Added missing `execution::sender_traits` specialisation and `connect()`
  member function to the `thread_pool` executor, as per the specification.

* Changed `execution::blocking_t::always_t::is_preferable` to be false as per
  the specification.

* Added `shape_type` and `index_type` to `thread_pool` executors, as per the
  specification.

* Ensured that the standard executor concept-related traits (such as
  `execution::is_executor`) work with `void`.

* Fixed `async_compose` support for standard executors.

* Fixed the forward declaration of `any_io_executor` in [^asio/ts/netfwd.hpp].

* Fixed `use_future` compatibility with older compilers.

* Fixed compatibility with MinGW.

* Improved compatibility with older versions of [^gcc].

* Added compatiblity with [^clang-cl] on Windows.

* Fixed various compiler warnings.

* Added basic overview documentation for the standard executors support.

* Added detailed descriptions to the standard executor-related member functions
  of `io_context` executors, `thread_pool` executors, `system_executor`, and
  `strand<>`.

* Changed introductory documentation to reflect that there our now multiple
  types of I/O execution context.

* Marked constructors, destructors, and static data members in class synopses
  in the reference documentation.

* Fixed various minor documentation errors.

[heading Asio 1.17.0]

* Added an implementation of the proposed standard executors
  ([@http://wg21.link/P0443r13 P0443r13], [@http://wg21.link/P1348r0 P1348r0],
  and [@http://wg21.link/P1393r0 P1393r0]).

* Added support for the proposed standard executors to Asio's I/O facilities:

  * The `io_context::executor_type`, `thread_pool::executor_type`,
    `system_executor`, and `strand` executors now meet the requirements for the
    proposed standard executors. These classes also continue to meet the
    existing requirements for the Networking TS model of executors.

  * All I/O objects, asynchronous operations, and utilities including
    `dispatch`, `post`, `defer`, `get_associated_executor`, `bind_executor`,
    `make_work_guard`, `spawn`, `co_spawn`, `async_compose`, `use_future`,
    etc., can interoperate with both new proposed standard executors, and with
    existing Networking TS executors. The implementation determines at compile
    time which model a particular executor meets; the proposed standard
    executor model is used in preference if both are detected.

  * The `any_io_executor` type alias has been introduced as the new default
    runtime-polymorphic executor for all I/O objects. This type alias points to
    the `execution::any_executor<>` template with a set of supportable
    properties specified for use with I/O. This change may break existing code
    that directly uses the old polymorphic wrapper, `executor`. If required for
    backward compatibility, `ASIO_USE_TS_EXECUTOR_AS_DEFAULT` can be defined,
    which changes the `any_io_executor` type alias to instead point to the
    `executor` polymorphic wrapper.

  * Support for the existing Networking TS model of executors can be disabled
    by defining `ASIO_NO_TS_EXECUTORS`.

* Added converting move construction and assignment to `basic_waitable_timer`.
  This enables move construction and assignment between different timer
  types, provided the executor types are convertible. For example:[br]
  ``
  basic_waitable_timer<
      clock_type,
      traits_type,
      io_context::executor_type
    > timer1(my_io_context);

  basic_waitable_timer<
      clock_type,
      traits_type,
      any_io_executor // polymorphic wrapper
    > timer2(std::move(timer1));
  ``[br]

* Enabled C++20 coroutine support when using [^gcc] 10.

* Added overloads of `co_spawn` that launch an awaitable. This change allows us
  to write:[br]
  ``
  co_spawn(executor,
      echo(std::move(socket)),
      detached);
  ``[br]
  instead of:[br]
  ``
  co_spawn(executor,
      [socket = std::move(socket)]() mutable
      {
        return echo(std::move(socket));
      },
      detached);
  ``[br]

* Added a new constructor overload to `use_awaitable_t`'s default executor
  adapter, to enable conversion between executor types.

* Added support for using `detached_t` as a default completion token, by
  adding members `as_default_on()` and `as_default_on_t<>`.

* Added a move constructor to `ssl::stream<>`.

* Changed `ssl::stream<>` write operations to linearise gather-write buffer
  sequences.

* Added compile-time detection of the deprecated `asio_handler_invoke` hook.
  This hook was deprecated with the introduction of the Networking TS trait
  `associated_executor` and function `get_associated_executor()`. Compiling
  an application with `ASIO_NO_DEPRECATED` will now trigger a compile error if
  any handler implements the `asio_handler_invoke` hook.

* Added compile-time detection of the deprecated `asio_handler_allocate`
  and `asio_handle_deallocate` hooks. These hooks were deprecated with the
  introduction of the Networking TS trait `associated_allocator` and function
  `get_associated_allocator()`. Compiling an application with
  `ASIO_NO_DEPRECATED` will now trigger a compile error if any handler
  implements the `asio_handler_allocate` or `asio_handler_deallocate` hooks.

* Implemented a number of performance optimisations, including:

  * Specialising single-buffer operations to use `recv` rather than `recvmsg`,
    `send` rather than `sendmsg`, `read` rather than `readv`, and `write`
    rather than `writev`.

  * Lightening the reference counting overhead of the polymorphic wrapper
    `executor`.

  * Returning from system call operation wrappers as early as possible, and
    only accessing `errno` and error codes when on an error path.

  * Applying additional optimisations if a "native" I/O executor (such as
    `io_context::exeutor_type`) is detected.

* Added source location support to handler tracking. The new
  `ASIO_HANDLER_LOCATION((file_name, line, function_name))` macro may be used
  to inform the handler tracking mechanism of a source location. This macro
  declares an object that is placed on the stack. Then, when an asynchronous
  operation is launched with location information, it outputs lines using the
  [*<action>] [^n^m], prior to the [^n*m] line that signifies the beginning
  of the asynchronous operation. For example:
  [pre
  @asio|1589423304.861944|>7|ec=system:0,bytes_transferred=5
  @asio|1589423304.861952|7^8|in 'async_write' (./../../../include/asio/impl/write.hpp:330)
  @asio|1589423304.861952|7^8|called from 'do_write' (handler_tracking/async_tcp_echo_server.cpp:62)
  @asio|1589423304.861952|7^8|called from 'operator()' (handler_tracking/async_tcp_echo_server.cpp:51)
  @asio|1589423304.861952|7*8|socket@0x7ff61c008230.async_send
  @asio|1589423304.861975|.8|non_blocking_send,ec=system:0,bytes_transferred=5
  @asio|1589423304.861980|<7|][br]
  If `std::source_location` or `std::experimental::source_location` are
  available, the `use_awaitable_t` token (when default-constructed or used as a
  default completion token) will also cause handler tracking to output a source
  location for each newly created asynchronous operation. A `use_awaitable_t`
  object may also be explicitly constructed with location information.

* Implemented various improvements to the [^handlerviz.pl] tool.

  * Add nodes for pending handlers at bottom of graph, outlined in red.

  * Display source location in a tooltip on the edge label (for SVG).

  * Use invisible nodes to enforce order to keep related control flow vertical.

* Added the [^handlerlive.pl] tool, which processes handler tracking output to
  produce a list of "live" handlers. Live handlers are those that are
  associated with pending asynchronous operations, as well as handlers that are
  currently executing. For example:
  ``
  cat output.txt | perl handlerlive.pl
  ``
  or:
  ``
  perl handerlive.pl < output.txt
  ``
  or:
  ``
  perl handlerlive.pl output.txt
  ``[br]

* Added the [^handlertree.pl] tool, which filters handler tracking output to
  include only those events in the tree that produced the nominated handlers.
  For example, to filter the output to include only the events associated with
  handlers `123`, `456`, and their predecessors:
  [pre
  cat output.txt | perl handlertree.pl 123 456]
  or:
  [pre
  perl handlertree.pl 123 456 < output.txt][br]
  This script may be combined with handerlive.pl and handlerviz.pl to produce a
  graph of the "live" asynchronous operation chains. For example:
  [pre
  cat output.txt | \
    perl handlertree.pl `perl handlerlive.pl output.txt` | \
    perl handlerviz.pl | \
    dot -Tsvg > output.svg][br]

* Added changes for clang-based Embarcadero C++ compilers.

* Fixed a deadlock that can occur when multiple threads concurrently initialise
  the Windows I/O completion port backend.

* Fixed `async_compose` to work with copyable handlers when passed by lvalue.

* Fixed completion signature deduction in `co_spawn`.

* Removed a spurious `Executor` base class from the `executor_binder`
  implementation.

* Various fixes and improvements in the documentation and examples.

[heading Asio 1.16.1]

* Fixed compatibility with C++20 concept syntax.

* Marked the POSIX descriptor classes' move constructors as `noexcept`.

* Added the `ssl::host_name_verification` class, which is a drop-in replacement
  for `ssl::rfc2818_verification`. The `ssl::rfc2818_verification` class has
  been marked as deprecated. As a consequence of this change, SSL support now
  depends on functions that were introduced in OpenSSL 1.0.2.

* Added an `ssl::context` constructor to take ownership of a native handle.

* Changed C++ language version detection with [^gcc] to use `__cplusplus` macro.

* Fixed a work counting issue in the asynchronous resolve operation for
  endpoints.

* Fixed the `strand<>` converting constructors and assignment operators.

* Ensured that resolvers are restarted correctly after a fork.

* Fixed compatibility with the current NetBSD release.

* Removed spurious handler requirement checks in some `async_read` overloads.

* Changed the `ssl::context` class to propagate non-EOF errors from the
  `add_certificate_authority` function.

* Fixed a Windows-specific `thread_pool` destructor hang that occurred when the
  pool had an associated I/O object.

* Changed the [^select] reactor to recreate the "self pipe trick" sockets on
  error. This addresses an issue on some versions of Windows, where these
  sockets are discconected after a system sleep.

* Fixed a compile error in the buffered streams due to the lack of reference
  collapsing in C++98.

* Changed the `priority_scheduler` example to demonstrate calls to `shutdown()`
  and `destroy()`.

* Removed some unnecessary null pointer checks.

* Changed Windows platform detection to recognise TV titles as Windows apps.

* Added some emscripten compatibility patches.

* Fixed a compile error in the `use_awaitable_t::as_default_on` function.

* Changed all uses of the boost.bind placeholders to use the
  `boost::placeholders` namespace.

* Fixed a potential compile error in the `async_compose` implementation due to
  incorrect overload selection.

* Suppressed some non-virtual destructor warnings.

* Various documentation fixes and improvements.

[heading Asio 1.16.0]

* Changed the `async_initiate` helper function to automatically deduce its
  return type. This is enabled for C++11 or later.

* Changed all asynchronous operations to use automatically deduced return
  types. This allows completion token implementations to incorporate the
  asynchronous operation initiation into the initiating function's return type,
  without type erasure. Note that C++14 or later is required to support
  completion tokens that use per-operation return type deduction. For C++11 or
  earlier, a completion token's async_result specialisation must still provide
  the nested typedef `return_type`.

* Introduced three new concepts to support `async_initiate`.
  * `completion_signature<T>`: Checks if `T` is a signature of the form
    `R(Args...)`.
  * `completion_handler_for<T, Signature>`: Checks if `T` is usable as a
    completion handler with the specified signature.
  * `completion_token_for<T, Signature>`: Checks if `T` is a completion token
    that can be used with async_initiate and the specified signature.
  * For backward compatibility with pre-concepts C++, the macros
    `(BOOST_)ASIO_COMPLETION_SIGNATURE`, `(BOOST_)ASIO_COMPLETION_HANDLER_FOR`, and
    `(BOOST_)ASIO_COMPLETION_TOKEN_FOR` are provided. These macros expand to
    `typename` when concepts are unsupported.

* Added the nested template type `rebind_executor` to all I/O object types, as
  a way to generically rebind them to use alternative I/O executors. For
  example:
  ``
  using my_socket_type = tcp::socket::rebind_executor<my_executor_type>::other;
  ``[br]

* Changed the asynchronous operations' initiation function objects to report
  their associated I/O executor via the nested type `executor_type` and member
  function `get_executor()`. Note that the presence of `executor_type` and
  `get_executor()` should be treated as optional, and consequently it may be
  preferable to access them via the `associated_executor` trait and the
  `get_associated_executor()` helper function.

* Added the `default_completion_token` trait, so that every I/O executor type
  now has an associated default completion token type. This trait may be used
  in asynchronous operation declarations as follows:
  ``
  template <
      typename IoObject,
      typename CompletionToken =
        typename default_completion_token<
          typename IoObject::executor_type
        >::type
    >
  auto async_xyz(
      IoObject& io_object,
      CompletionToken&& token =
        typename default_completion_token<
          typename IoObject::executor_type
        >::type{}
    );
  ``[br]
  If not specialised, this trait type is `void`, meaning no default completion
  token type is available for the given I/O executor.

* Specialised the `default_completion_token` trait for the `use_awaitable`
  completion token, so that it may be used as shown in the following example:
  ``
  auto socket = use_awaitable.as_default_on(tcp::socket(my_context));
  // ...
  co_await socket.async_connect(my_endpoint); // Defaults to use_awaitable.
  ``[br]
  In this example, the type of the `socket` object is transformed from
  `tcp::socket` to have an I/O executor with the default completion token set
  to `use_awaitable`. Alternatively, the socket type may be computed directly:
  ``
  using tcp_socket = use_awaitable_t<>::as_default_on_t<tcp::socket>;
  tcp_socket socket(my_context);
  // ...
  co_await socket.async_connect(my_endpoint); // Defaults to use_awaitable.
  ``[br]

* Added missing `async_initiate` to the Windows-specific I/O objects'
  asynchronous operations.

* Ensured that the executor type is propagated to newly accepted sockets.
  When synchronously or asynchronously accepting a new connection, but
  without specifying an executor or execution context, the accept
  operation will now correctly propagate the executor type from the
  acceptor to the socket. For example, if your acceptor type is:
  ``
  basic_socket_acceptor<ip::tcp, my_executor_type>
  ``[br]
  then your accepted socket type will be:
  ``
  basic_stream_socket<ip::tcp, my_executor_type>
  ``[br]

* Changed to require that `Protocol` copy and move operations never throw.

* Changed to require that `Endpoint` default constructor and move operations
  never throw.

* Added the `noexcept` qualifier to protocol accessors.

* Added the `noexcept` qualifier to socket move constructors.

* Fixed issues associated with opening serial ports on Windows:
  * Use the correct constant to initialise the RTS control flag.
  * Specify a default baud rate (9600).

* Fixed a lost "outstanding work count" that can occur when an asynchronous
  accept operation is automatically restarted.

[heading Asio 1.14.1]

* Improved performance slightly by eliminating a redundant move construction
  when completed handlers are dispatched.

* Eliminated a compiler warning by annotating a `case` fall-through in
  the free function `connect()` implementation.

* Fixed the `is_*_buffer_sequence` detection traits for user-defined sequence
  types.

* Fixed some Windows-specific warnings about an incompatible pointer cast when
  obtaining the `CancelIoEx` entry point.

* Changed to automatically set the defaults when opening a serial port on
  Windows.

* Changed the serial port `get_option()` member function to be const.

* Fixed a name hiding issue with the WinRT stream-oriented socket backend's
  `shutdown` function.

* Applied a minor fix to the documentation for `is_dynamic_buffer`.

* Added some support for Haiku OS.

* Added wolfSSL compatability.

* Changed to require C++17 or later for coroutines TS support with clang.

* Fixed a doxygen generation problem in the tutorial.

[heading Asio 1.14.0]

* Improved I/O object performance by adding runtime detection of native I/O
  executors when using the polymorphic executor wrapper.

* Changed I/O object move constructors so that the executor is copied, not
  moved. This ensures that the moved-from I/O object is left in the same state
  as if constructed with a valid executor but without a resource.

* On Windows, fixed an issue where global object destructors were not being
  run.

* Fixed move-based `async_accept` between sockets with different executor
  types.

[heading Asio 1.13.0]

* Added custom I/O executor support to I/O objects.

  * All I/O objects now have an additional `Executor` template parameter. This
    template parameter defaults to the `asio::executor` type (the polymorphic
    executor wrapper) but can be used to specify a user-defined executor
    type.

  * I/O objects' constructors and functions that previously took an
    `asio::io_context&` now accept either an `Executor` or a reference to a
    concrete `ExecutionContext` (such as `asio::io_context` or
    `asio::thread_pool`).

  * Note: One potential source of breakage in existing user code is when reusing an
    I/O object's `io_context` for constructing another I/O object, as in:
    ``
    asio::steady_timer my_timer(my_socket.get_executor().context());
    ``[br]
    To fix this, either construct the second I/O object using the first I/O
    object's executor:[br]
    ``
    asio::steady_timer my_timer(my_socket.get_executor());
    ``[br]
    or otherwise explicitly pass the `io_context`:[br]
    ``
    asio::steady_timer my_timer(my_io_context);
    ``[br]

  * The previously deprecated `get_io_context` and `get_io_service`
    member functions have now been removed.

  * The previously deprecated service template parameters, and the
    corresponding classes, have now been removed.

* Added a new `async_result` form with an `initiate` static member function.

  * The `async_result` template now supports a new form:
    ``
    template <typename CompletionToken, typename Signature>
    struct async_result
    {
      typedef /* ... */ return_type;

      template <typename Initiation,
          typename RawCompletionToken,
          typename... Args>
      static return_type initiate(
          Initiation&& initiation,
          RawCompletionToken&& token,
          Args&&... args);
    };
    ``[br]

  * The `initiate` member function must: (a) transform the token into a
    completion handler object `handler`; (b) cause the invocation of the
    function object `initiation` as if by calling
    `std::forward<Initiation>(initiation)(std::move(handler),
    std::forward<Args>(args)...)`. Note that the invocation of `initiation`
    may be deferred (e.g. lazily evaluated), in which case `initiation` and
    `args` must be decay-copied and moved as required.

  * A helper function template `async_initiate` has also been added as a
    wrapper for the invocation of `async_result<>::initiate`. For backward
    compatibility, this function supports both the old and new `async_result`
    forms.

  * The composed operations examples have been updated to use `async_initiate`.

  * The previously deprecated `handler_type` trait and single-argument form of
    `async_result` have now been removed.

* Updated the Coroutines TS support and promoted it to the `asio` namespace.

  * The `awaitable<>`, `co_spawn`, `this_coro`, `detached`, and
    `redirect_error` facilities have been moved from the `asio::experimental`
    namespace to namespace `asio`. As part of this change, the
    `this_coro::token()` awaitable has been superseded by the
    `asio::use_awaitable` completion token.

  * Please note that the `use_awaitable` and `redirect_error` completion tokens
    work only with asynchronous operations that use the new form of
    `async_result` with member function `initiate`. Furthermore, when using
    `use_awaitable`, please be aware that the asynchronous operation is not
    initiated until `co_await` is applied to the `awaitable<>`.

* Added a new `DynamicBuffer_v2` concept which is CopyConstructible.

  * This change adds a new set of type requirements for dynamic buffers,
    `DynamicBuffer_v2`, which supports copy construction. These new type
    requirements enable dynamic buffers to be used as arguments to
    user-defined composed operations, where the same dynamic buffer object
    is used repeatedly for multiple underlying operations. For example:[br]
    ``
      template <typename DynamicBuffer>
      void echo_line(tcp::socket& sock, DynamicBuffer buf)
      {
        n = asio::read_until(sock, buf, '\n');
        asio::write(sock, buf, asio::transfer_exactly(n));
      }
    ``[br]

  * The original `DynamicBuffer` type requirements have been renamed to
    `DynamicBuffer_v1`. These requirements continue to be compatible with the
    Networking TS.

  * New type traits `is_dynamic_buffer_v1` and `is_dynamic_buffer_v2` have been
    added to test for conformance to `DynamicBuffer_v1` and `DynamicBuffer_v2`
    respectively. The existing `is_dynamic_buffer` trait has been retained and
    delegates to `is_dynamic_buffer_v1` (unless `ASIO_NO_DYNAMIC_BUFFER_V1` is
    explicitly defined, in which case it delegates to `is_dynamic_buffer_v2`).

  * For convenience, the `dynamic_string_buffer` and `dynamic_vector_buffer`
    classes conform to both `DynamicBuffer_v1` and `DynamicBuffer_v2`
    requirements.

  * When `ASIO_NO_DYNAMIC_BUFFER_V1` is defined, all support for
    `DynamicBuffer_v1` types and functions is #ifdef-ed out. Support for using
    `basic_streambuf` with the `read`, `async_read`, `read_until`,
    `async_read_until`, `write`, and `async_write` functions is also disabled
    as a consequence.

  * Note: This change should have no impact on existing source code that simply
    uses dynamic buffers in conjunction with Asio's composed operations.

* Added a new `async_compose` function that simplifies the implementation of
  user-defined asynchronous operations.

* Added a `make_strand` function, which creates a `strand` with a deduced
  `Executor` template argument.

* Relaxed the completion condition type requirements to only require
  move-constructibility rather than copy-constructibility.

* Added a constructor for `local::basic_endpoint` that takes a `string_view`.

* Added the noexcept qualifier to various member functions of the
  `ip::address`, `ip::address_v4`, `ip::address_v6`, `ip::basic_endpoint`, and
  `executor_work_guard` classes.

* Added the noexcept qualifier to the `buffer_sequence_begin` and
  `buffer_sequence_end` functions.

* Added a new `ASIO_DISABLE_VISIBILITY` configuration `#define` that allows
  visibility pragmas to be disabled. (Note: If symbols are hidden, extra care
  must be taken to ensure that Asio types are not passed across shared
  library API boundaries.)

* Changed compile-time feature detection to define `ASIO_STANDALONE`
  automatically if C++11 or later is detected.

  * Users should define `ASIO_ENABLE_BOOST` to explicitly disable standalone
    mode when compiling with C++11 or later.

  * The `configure` script now defaults to a standalone build unless Boost is
    specified or detected.

* Enabled recycling of the memory used to type-erase a function object with the
  polymorphic executor.

* Changed receive operations to return the correct number of bytes transferred
  when truncation (`error::message_size`) occurs on a datagram-oriented socket.

* Fixed multicast behaviour on QNX by automatically applying `SO_REUSEPORT`
  when the `reuse_address` option is set.

* Added inclusion of `unistd.h` when targeting Haiku OS, to fix feature detection.

* Added the `network_v[46].hpp` headers to the top-level convenience header.

* Fixed calculation of absolute timeout when the backend uses
  `pthread_cond_timedwait`.

* Changed the range-based asynchronous connect operation to deduce the
  `EndpointSequence` iterator type rather than assume the presence of a
  `const_iterator` typedef.

* Fixed `buffer_sequence_begin` and `buffer_sequence_end` to prevent implicit
  conversion. This change addresses an issue where a call to
  `buffer_sequence_begin` or `buffer_sequence_end` could trigger an implicit
  conversion to `const_buffer` or `mutable_buffer`. Whenever this implicit
  conversion occurred, the return value of `buffer_sequence_begin` or
  `buffer_sequence_end` would point to a temporary object.

* Ensured SSL handshake errors are propagated to the peer before the local
  operation completes.

* Suppressed the `eof` error on SSL shutdown as it actually indicates success.

* Added a fallback error code for when we OpenSSL produces an
  `SSL_ERROR_SYSCALL` result without an associated error.

* Changed composed asynchronous read and write operations to move, rather than
  copy, the buffer sequence objects when the composed operation implementation
  is moved.

* Changed to use `<atomic>` when targeting apple/clang/libc++ with recent Xcode
  versions, even for C++03. This fixes a warning about the deprecation of
  `OSMemoryBarrier`.

* Fixed compile errors that occur when using the composed read and write
  operations with MSVC 11.0, by disabling `decltype` support for that compiler.

* Increased the default value of `_WIN32_WINNT` to `0x0601` (Windows 7).

* Fixed `dispatch` documentation to note that it may call the supplied function
  object in the current thread.

* Updated `post` and `defer` documentation to clarify the the distinction
  between them.

[heading Asio 1.12.2]

* Fixed a problem with the detection of `std::future` availability with
  libstdc++.

* Fixed compile error in regex overload of `read_until`.

* Fixed a timer heap corruption issue that can occur when moving a cancelled
  timer.

* Fixed detection of `std::experimental::string_view` and `std::string_view`
  with newer clang/libc++.

* Fixed MSVC version detection for availability of `std::invoke_result`.

* Fixed the buffer sequence traits to test the new requirements, if `decltype`
  is available.

* Fixed an MSVC issue when building with exceptions disabled.

* Added SSL context options for TLS v1.3.

* Added a compile-time test for TLS v1 support.

* Fixed the macro used to test for TLS v1.2 support.

* Prevented global objects from being created once per thread on Windows.

* Fixed a crash when using `size()`, `max_size()` or `empty()` on
  default-constructed resolver results.

* Changed to move the return value in basic_resolver_results::begin() to avoid
  copying.

* Enabled move support for the Intel Compiler.

* Fixed `std::string_view` detection issue when using clang-cl.

* Fixed the handler tracking operation name for
  `io_context::executor_type::dispatch`.

* Fixed a buffer overflow that could occur when parsing an address string with
  a 64-bit scope id.

* Added examples showing how to write composed operations.

* Added C++11 versions of the Timeouts, Timers, SOCKS4 and SSL examples.

* Fixed minor issues in documentation and examples.

[heading Asio 1.12.1]

* Added missing const qualifier to `basic_socket_acceptor::get_option`.

* Worked around a parsing error that occurs with some versions of gcc.

* Fixed broken code samples in tutorial.

* Added new experimental features. (Note that "experimental" features may be
  changed without notice in subsequent releases.)

  * Added `experimental::detached` completion token.

  * Added `experimental::redirect_error` completion token.

  * Added `experimental::co_spawn` facility for integration with the coroutines
    technical specification.

* Updated timeout examples to use latest features.

  * Used `asio::steady_timer` rather than `asio::deadline_timer`.

  * Used `asio::dynamic_buffer` rather than `asio::streambuf`.

  * Used timed `asio::io_context::run_for()` function for blocking clients.

  * Added example showing a custom completion token for blocking with timeouts.

* Fixed unit tests to compile when `(BOOST_)ASIO_NO_DEPRECATED` is defined.

* Changed socket iostreams to use chrono by default, to fix compatibility with
  the Networking TS. Define `(BOOST_)ASIO_USE_BOOST_DATE_TIME_FOR_SOCKET_IOSTREAM`
  to enable the old Boost.Date_Time interface in `basic_socket_streambuf` and
  `basic_socket_iostream`.

* Updated examples to use chrono rather than Boost.Date_Time.

* Fixed an incorrect member function detector in the `is_dynamic_buffer` trait.

* Fixed an `async_result` incompatibility with deprecated `handler_type`.

* Added a missing move optimisation in the SSL stream implementation.

* Fixed incorrect `basic_resolver_results::value_type` typedef.

* Fixed a compile error with some OpenSSL versions when `SSL_OP_NO_COMPRESSION`
  is defined.

* Changed `add_certificate_authority` to process multiple certificates in a bundle.

* Eliminated deprecation warning with MSVC by using `std::invoke_result` rather
  than `std::result_of`.

* Changed to use `std::string_view` for C++17 or later, and
  `std::experimental::string_view` for C++14. Define the preprocessor macro
  `(BOOST_)ASIO_DISABLE_STD_STRING_VIEW` to force the use of
  std::experimental::string_view (assuming it is available) when compiling in
  C++17 mode.

* Ensured `DynamicBuffer` template arguments are decayed before using in
  `enable_if` tests.

* Changed documentation to distinguish legacy completion handlers (which are
  still required to be CopyConstructible) from new MoveConstructible handlers.

* Suppressed a discarded return value warning in the buffer debugging support.

* Fixed `basic_yield_context` to work with completion signatures containing
  reference parameters.

* Ensured that stackful coroutines launched using `spawn()` correctly store
  decayed copies of their function and handler arguments.

* Fixed some compatibility issues with Android.

* Fixed some minor portability issues in examples.

[heading Asio 1.12.0]

* Completed the interface changes to reflect the Networking TS
  ([@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4656.pdf N4656]).

  * See the [link asio.net_ts list] of new interfaces and, where
    applicable, the corresponding old interfaces that have been superseded.

  * The service template parameters, and the corresponding classes, are disabled
    by default. For example, instead of `basic_socket<Protocol, SocketService>` we
    now have simply `basic_socket<Protocol>`. The old interface can be enabled by
    defining the `(BOOST_)ASIO_ENABLE_OLD_SERVICES` macro.

* Added support for customised handler tracking.

* Added reactor-related (i.e. descriptor readiness) events to handler tracking.

* Added special [link asio.overview.core.concurrency_hint concurrency
  hint] values that may be used to disable locking on a per `io_context` basis.

* Enabled perfect forwarding for the first `ssl::stream<>` constructor argument.

* Added ability to release ownership of the underlying native socket. (Requires
  Windows 8.1 or later when using the I/O completion port backend.)

[heading Asio 1.11.0]

* Implemented changes to substantially reflect the Networking Library Proposal
  ([@www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4370.html N4370]).

  * New `Executor` type requirements and classes to support an executor
    framework, including the `execution_context` base class, the
    `executor_work` class for tracking outstanding work, and the `executor`
    polymorphic wrapper. Free functions `dispatch()`, `post()` and `defer()`
    have been added and are used to submit function objects to executors.

  * Completion handlers now have an associated executor and associated
    allocator. The free function `wrap()` is used to associate an executor with
    a handler or other object. The handler hooks for allocation, invocation and
    continuation have been deprecated.

  * A `system_executor` class has been added as a default executor.

  * The `io_service` class is now derived from `execution_context` and
    implements the executor type requirements in its nested `executor_type`
    class. The member functions `dispatch()`, `post()`, `defer()` and `wrap()`
    have been deprecated. The `io_service::work` class has been deprecated.

  * The `io_service` member function `reset()` has been renamed to `restart()`.
    The old name is retained for backward compatibility but has been
    deprecated.

  * The `make_service<>()` function is now used to add a new service to an
    execution context such as an `io_service`. The `add_service()` function has
    been deprecated.

  * A new `strand<>` template has been added to allow strand functionality to
    be used with generic executor types.

  * I/O objects (such as sockets and timers) now provide access to their
    associated `io_service` via a `context()` member function. The
    `get_io_service()` member function is deprecated.

  * All asynchronous operations and executor operations now support move-only
    handlers. However, the deprecated `io_service::post()`,
    `io_service::dispatch()`, `io_service::strand::post()` and
    `io_service::strand::dispatch()` functions still require copyable handlers.

  * Waitable timer objects are now movable.

  * Waitable timers, socket iostreams and socket streambufs now provide an
    `expiry()` member function for obtaining the expiry time. The accessors
    `expires_at()` and `expires_after()` have been deprecated, though those
    names are retained for the mutating members.

  * The `std::packaged_task` class template is now supported as a completion
    handler. The initiating operation automatically returns the future
    associated with the task. The `package()` function has been added as a
    convenient factory for packaged tasks.

  * Sockets, socket acceptors and descriptors now provide `wait()` and
    `async_wait()` operations that may be used to wait for readiness. The
    `null_buffers` type has been deprecated.

  * The proposed error code enum classes are simulated using namespaces.
    Existing asio error codes now have a correspondence with the standard error
    conditions.

  * Conversion between IP address types, and conversion from string to address,
    is now supported via the `address_cast<>()`, `make_address()`,
    `make_address_v4()` and `make_address_v6()` free functions. The
    `from_string()`, `to_v4()`, `to_v6()` and `v4_mapped()` member functions
    have been deprecated.

  * A default-constructed `ip::address` now represents an invalid address value
    that is neither IPv4 nor IPv6.

  * New `buffer()` overloads that generate mutable buffers for non-const
    `string` objects.

  * Support for dynamic buffer sequences that automatically grow and shrink to
    accomodate data as it is read or written. This is a generic facility
    similar to the existing `asio::streambuf` class. This support includes:

    * New `dynamic_string_buffer` and `dynamic_vector_buffer` adapter classes
      that meet the `DynamicBufferSequence` type requirements.

    * New `dynamic_buffer()` factory functions for creating a dynamic buffer
      adapter for a `vector` or `string`.

    * New overloads for the `read()`, `async_read()`, `write()` and
      `async_write()`, `read_until()` and `async_read_until()` free functions
      that directly support dynamic buffer sequences.

  * Support for networks and address ranges. Thanks go to Oliver Kowalke for
    contributing to the design and providing the implementation on which this
    facility is based. The following new classes have been added:

    * `address_iterator_v4` for iterating across IPv4 addresses
    * `address_iterator_v6` for iterating across IPv6 addresses
    * `address_range_v4` to represent a range of IPv4 addresses
    * `address_range_v6` to represent a range of IPv6 addresses
    * `network_v4` for manipulating IPv4 CIDR addresses, e.g. 1.2.3.0/24
    * `network_v6` for manipulating IPv6 CIDR addresses, e.g. ffe0:/120

  * New convenience headers in [^<asio/ts/*.hpp>] that correspond to the headers
    in the proposal.

* Added a new, executor-aware `thread_pool` class.

* Changed `spawn()` to be executor-aware.

* Added a new `spawn()` overload that takes only a function object.

* Changed `spawn()` and `yield_context` to permit nested calls to the
  completion handler.

* Removed previously deprecated functions.

* Added options for disabling TLS v1.1 and v1.2.

* Changed the SSL wrapper to call the password callback when loading an
  in-memory key.

* Changed the tutorial to use `std::endl` to ensure output is flushed.

* Fixed false SSL error reports by ensuring that the SSL error queue is cleared
  prior to each operation.

* Fixed an `ssl::stream<>` bug that may result in spurious 'short read' errors.

* Enabled perfect forwarding for the first `ssl::stream<>` constructor argument.

* Added standalone Asio support for Clang when used with libstdc++ and C++11.

* Fixed an unsigned integer overflow reported by Clang's integer sanitizer.

* Added support for move-only return types when using a `yield_context` object
  with asynchronous operations.

* Ensured errors generated by Windows' `ConnectEx` function are mapped to their
  portable equivalents.

* Changed multicast test to treat certain `join_group` failures as non-fatal.

[heading Asio 1.10.5]

* Fixed the [^kqueue] reactor so that it works on FreeBSD.

* Fixed an issue in the [^kqueue] reactor which resulted in spinning when using
  serial ports on Mac OS.

* Fixed [^kqueue] reactor support for read-only file descriptors.

* Fixed a compile error when using the [^/dev/poll] reactor.

* Changed the Windows backend to use `WSASocketW`, as `WSASocketA` has been
  deprecated.

* Fixed some warnings reported by Visual C++ 2013.

* Fixed integer type used in the WinRT version of the byte-order conversion
  functions.

* Changed documentation to indicate that `use_future` and `spawn()` are not
  made available when including the `asio.hpp` convenience header.

* Explicitly marked `asio::strand` as deprecated. Use
  `asio::io_service::strand` instead.

[heading Asio 1.10.4]

* Stopped using certain Winsock functions that are marked as deprecated in the
  latest Visual C++ and Windows SDK.

* Fixed a shadow variable warning on Windows.

* Fixed a regression in the [^kqueue] backend that was introduced in Asio
  1.10.2.

* Added a workaround for building the unit tests with [^gcc] on AIX.

[heading Asio 1.10.3]

* Worked around a [^gcc] problem to do with anonymous enums.

* Reverted the Windows `HANDLE` backend change to ignore `ERROR_MORE_DATA`.
  Instead, the error will be propagated as with any other (i.e. in an
  `error_code` or thrown as a `system_error`), and the number of bytes
  transferred will be returned. For code that needs to handle partial messages,
  the `error_code` overload should be used.

* Fixed an off-by-one error in the `signal_set` implementation's signal
  number check.

* Changed the Windows IOCP backend to not assume that
  `SO_UPDATE_CONNECT_CONTEXT` is defined.

* Fixed a Windows-specific issue, introduced in Asio 1.10.2, by using
  `VerifyVersionInfo` rather than `GetVersionEx`, as `GetVersionEx` has been
  deprecated.

* Changed to use SSE2 intrinsics rather than inline assembly, to allow the
  Cray compiler to work.

[heading Asio 1.10.2]

* Fixed `asio::spawn()` to work correctly with new Boost.Coroutine interface.

* Ensured that incomplete `asio::spawn()` coroutines are correctly unwound when
  cleaned up by the `io_service` destructor.

* Fixed delegation of continuation hook for handlers produced by
  `io_service::wrap()` and `strand::wrap()`.

* Changed the Windows I/O completion port backend to use `ConnectEx`, if
  available, for connection-oriented IP sockets.

* Changed the `io_service` backend for non-Windows (and non-IOCP Windows)
  platforms to use a single condition variable per `io_service` instance.
  This addresses a potential race condition when `run_one()` is used from
  multiple threads.

* Prevented integer overflow when computing timeouts based on some
  `boost::chrono` and `std::chrono` clocks.

* Made further changes to `EV_CLEAR` handling in the kqueue backend, to address
  other cases where the `close()` system call may hang on Mac OS X.

* Fixed infinite recursion in implementation of
  `resolver_query_base::flags::operator~`.

* Made the `select` reactor more efficient on Windows for large numbers of
  sockets.

* Fixed a Windows-specific type-aliasing issue reported by [^gcc].

* Prevented execution of compile-time-only buffer test to avoid triggering an
  address sanitiser warning.

* Disabled the `GetQueuedCompletionStatus` timeout workaround on recent
  versions of Windows.

* Changed implementation for Windows Runtime to use `FormatMessageW` rather
  than `FormatMessageA`, as the Windows store does not permit the latter.

* Added support for string-based scope IDs when using link-local multicast
  addresses.

* Changed IPv6 multicast group join to use the address's scope ID as the
  interface, if an interface is not explicitly specified.

* Fixed multicast test failure on Mac OS X and the BSDs by using a link-local
  multicast address.

* Various minor documentation improvements.

[heading Asio 1.10.1]

* Implemented a limited port to Windows Runtime. This support requires that the
  language extensions be enabled. Due to the restricted facilities exposed by
  the Windows Runtime API, the port also comes with the following caveats:

  * The core facilities such as the `io_service`, `strand`, buffers, composed
    operations, timers, etc., should all work as normal.

  * For sockets, only client-side TCP is supported.

  * Explicit binding of a client-side TCP socket is not supported.

  * The `cancel()` function is not supported for sockets. Asynchronous
    operations may only be cancelled by closing the socket.

  * Operations that use `null_buffers` are not supported.

  * Only `tcp::no_delay` and `socket_base::keep_alive` options are supported.

  * Resolvers do not support service names, only numbers. I.e. you must
    use "80" rather than "http".

  * Most resolver query flags have no effect.

* Extended the ability to use Asio without Boost to include Microsoft Visual
  Studio 2012. When using a C++11 compiler, most of Asio may now be used
  without a dependency on Boost header files or libraries. To use Asio in this
  way, define `ASIO_STANDALONE` on your compiler command line or as part of the
  project options. This standalone configuration has been tested for the
  following platforms and compilers:

  * Microsoft Visual Studio 2012

  * Linux with g++ 4.7 or 4.8 (requires [^-std=c++11])

  * Mac OS X with clang++ / Xcode 4.6 (requires [^-std=c++11 -stdlib=libc++])

* Fixed a regression (introduced in 1.10.0) where, on some platforms, errors
  from `async_connect` were not correctly propagated through to the completion
  handler.

* Fixed a Windows-specific regression (introduced in 1.10.0) that occurs when
  multiple threads are running an `io_service`. When the bug occurs, the result
  of an asynchronous operation (error and bytes tranferred) is incorrectly
  discarded and zero values used instead. For TCP sockets this results in
  spurious end-of-file notifications.

* Fixed a bug in handler tracking, where it was not correctly printing out some
  handler IDs.

* Fixed the comparison used to test for successful synchronous accept
  operations so that it works correctly with unsigned socket descriptors.

* Ensured the signal number is correctly passed to the completion handler when
  starting an `async_wait` on a signal that is already raised.

* Suppressed a g++ 4.8+ warning about unused typedefs.

* Enabled the move optimisation for handlers that use the default invocation
  hook.

* Clarified that programs must not issue overlapping `async_write_at`
  operations.

* Changed the Windows `HANDLE` backend to treat `ERROR_MORE_DATA` as a
  non-fatal error when returned by `GetOverlappedResult` for a synchronous
  read.

* Visual C++ language extensions use `generic` as a keyword. Added a
  workaround that renames the namespace to `cpp_generic` when those language
  extensions are in effect.

* Fixed some asynchronous operations that missed out on getting `async_result`
  support in 1.10.0. In particular, the buffered stream templates have been
  updated so that they adhere to current handler patterns.

* Enabled move support for Microsoft Visual Studio 2012.

* Added `use_future` support for Microsoft Visual Studio 2012.

* Removed a use of `std::min` in the Windows IOCP backend to avoid a
  dependency on the `<algorithm>` header.

* Eliminated some unnecessary handler copies.

* Fixed support for older versions of OpenSSL that do not provide the
  `SSL_CTX_clear_options` function.

* Fixed various minor and cosmetic issues in code and documentation.

[heading Asio 1.10.0]

* Added new traits classes, `handler_type` and `async_result`, that allow the
  customisation of the return type of an initiating function.

* Added the `asio::spawn()` function, a high-level wrapper for running
  stackful coroutines, based on the Boost.Coroutine library. The `spawn()`
  function enables programs to implement asynchronous logic in a synchronous
  manner. For example: `size_t n = my_socket.async_read_some(my_buffer, yield);`.
  For further information, see [link asio.overview.composition.spawn Stackful
  Coroutines].

* Added the `asio::use_future` special value, which provides first-class
  support for returning a C++11 `std::future` from an asynchronous
  operation's initiating function. For example:
  `future<size_t> = my_socket.async_read_some(my_buffer, asio::use_future);`.
  For further information, see [link asio.overview.composition.futures Futures].

* Promoted the stackless coroutine class and macros to be part of Asio's
  documented interface, rather than part of the HTTP server 4 example.
  For further information, see [link asio.overview.composition.coroutine
  Stackless Coroutines].

* Added a new handler hook called `asio_handler_is_continuation`.
  Asynchronous operations may represent a continuation of the asynchronous
  control flow associated with the current executing handler. The
  `asio_handler_is_continuation` hook can be customised to return `true` if
  this is the case, and Asio's implementation can use this knowledge to
  optimise scheduling of the new handler. To cover common cases, Asio
  customises the hook for strands, `spawn()` and composed asynchronous
  operations.

* Added four new generic protocol classes, `generic::datagram_protocol`,
  `generic::raw_protocol`, `generic::seq_packet_protocol` and
  `generic::stream_protocol`, which implement the `Protocol` type
  requirements, but allow the user to specify the address family (e.g.
  `AF_INET`) and protocol type (e.g. `IPPROTO_TCP`) at runtime.
  For further information, see [link
  asio.overview.networking.other_protocols Support for Other Protocols].

* Added C++11 move constructors that allow the conversion of a socket (or
  acceptor) into a more generic type. For example, an `ip::tcp::socket` can
  be converted into a `generic::stream_protocol::socket` via move
  construction.
  For further information, see [link
  asio.overview.networking.other_protocols Support for Other Protocols].

* Extended the `basic_socket_acceptor<>`'s `accept()` and `async_accept()`
  functions to allow a new connection to be accepted directly into a socket
  of a more generic type. For example, an `ip::tcp::acceptor` can be used to
  accept into a `generic::stream_protocol::socket` object.
  For further information, see [link
  asio.overview.networking.other_protocols Support for Other Protocols].

* Moved existing examples into a C++03-specific directory, and added a new
  directory for C++11-specific examples. A limited subset of the C++03
  examples have been converted to their C++11 equivalents.

* Add the ability to use Asio without Boost, for a limited set of platforms.
  When using a C++11 compiler, most of Asio may now be used without a
  dependency on Boost header files or libraries. To use Asio in this way,
  define `ASIO_STANDALONE` on your compiler command line or as part of the
  project options. This standalone configuration has currently been tested for
  the following platforms and compilers:

  * Linux with g++ 4.7 (requires [^-std=c++11])

  * Mac OS X with clang++ / Xcode 4.6 (requires [^-std=c++11 -stdlib=libc++])

* Various SSL enhancements. Thanks go to Nick Jones, on whose work these changes
  are based.

  * Added support for SSL handshakes with re-use of data already read from
    the wire. New overloads of the `ssl::stream<>` class's `handshake()` and
    `async_handshake()` functions have been added. These accept a
    `ConstBufferSequence` to be used as initial input to the ssl engine for
    the handshake procedure.

  * Added support for creation of TLSv1.1 and TLSv1.2 `ssl::context` objects.

  * Added a `set_verify_depth()` function to the `ssl::context` and
    `ssl::stream<>` classes.

  * Added the ability to load SSL certificate and key data from memory
    buffers. New functions, `add_certificate_authority()`,
    `use_certificate()`, `use_certificate_chain()`, `use_private_key()`,
    `use_rsa_private_key()` and `use_tmp_dh()`, have been added to the
    `ssl::context` class.

  * Changed `ssl::context` to automatically disable SSL compression by
    default. To enable, use the new `ssl::context::clear_options()` function,
    as in `my_context.clear_options(ssl::context::no_compression)`.

* Fixed a potential deadlock in `signal_set` implementation.

* Fixed an error in acceptor example in documentation.

* Fixed copy-paste errors in waitable timer documentation.

* Added assertions to satisfy some code analysis tools.

* Fixed a malformed `#warning` directive.

* Fixed a potential data race in the Linux `epoll` implementation.

* Fixed a Windows-specific bug, where certain operations might generate an
  `error_code` with an invalid (i.e. `NULL`) `error_category`.

* Fixed `basic_waitable_timer`'s underlying implementation so that it can
  handle any `time_point` value without overflowing the intermediate duration
  objects.

* Fixed a problem with lost thread wakeups that can occur when making
  concurrent calls to `run()` and `poll()` on the same `io_service` object.

* Fixed implementation of asynchronous connect operation so that it can cope
  with spurious readiness notifications from the reactor.

* Fixed a memory leak in the `ssl::rfc2818_verification` class.

* Added a mechanism for disabling automatic Winsock initialisation. See the
  header file [^asio/detail/winsock_init.hpp] for details.

[heading Asio 1.8.3]

* Fixed some 64-to-32-bit conversion warnings.

* Fixed various small errors in documentation and comments.

* Fixed an error in the example embedded in `basic_socket::get_option`'s
  documentation.

* Changed to use `long` rather than `int` for SSL_CTX options, to match OpenSSL.

* Changed to use `_snwprintf` to address a compile error due to the changed
  `swprintf` signature in recent versions of MinGW.

* Fixed a deadlock that can occur on Windows when shutting down a pool of
  `io_service` threads due to running out of work.

* Changed UNIX domain socket example to treat errors from `accept` as non-fatal.

* Added a small block recycling optimisation to improve default memory
  allocation behaviour.

[heading Asio 1.8.2]

* Fixed an incompatibility between `ip::tcp::iostream` and C++11.

* Decorated GCC attribute names with underscores to prevent interaction
  with user-defined macros.

* Added missing `#include <cctype>`, needed for some versions of MinGW.

* Changed to use [^gcc]'s atomic builtins on ARM CPUs, when available.

* Changed strand destruction to be a no-op, to allow strand objects to be
  destroyed after their associated `io_service` has been destroyed.

* Added support for some newer versions of glibc which provide the
  `epoll_create1()` function but always fail with ENOSYS.

* Changed the SSL implementation to throw an exception if SSL engine
  initialisation fails.

* Fixed another regression in `buffered_write_stream`.

* Implemented various minor performance improvements, primarily targeted at
  Linux x86 and x86-64 platforms.

[heading Asio 1.8.1]

* Changed the `epoll_reactor` backend to do lazy registration for `EPOLLOUT`
  events.

* Fixed the `epoll_reactor` handling of out-of-band data, which was broken by
  an incomplete fix in the last release.

* Changed Asio's SSL wrapper to respect OpenSSL's `OPENSSL_NO_ENGINE` feature
  test `#define`.

* Fixed `windows::object_handle` so that it works with Windows compilers that
  support C++11 move semantics (such as [^g++]).

* Improved the performance of strand rescheduling.

* Added support for [^g++] 4.7 when compiling in C++11 mode.

* Fixed a problem where `signal_set` handlers were not being delivered when
  the `io_service` was constructed with a `concurrency_hint` of 1.

[heading Asio 1.8.0]

* Added a new class template `basic_waitable_timer` based around the C++11 clock
  type requirements. It may be used with the clocks from the C++11 `<chrono>`
  library facility or, if those are not available, Boost.Chrono. The typedefs
  `high_resolution_timer`, `steady_timer` and `system_timer` may be used to
  create timer objects for the standard clock types.

* Added a new `windows::object_handle` class for performing waits on Windows
  kernel objects. Thanks go to Boris Schaeling for contributing substantially
  to the development of this feature.

* On Linux, `connect()` can return EAGAIN in certain circumstances. Remapped
  this to another error so that it doesn't look like a non-blocking operation.

* Fixed a compile error on NetBSD.

* Fixed deadlock on Mac OS X.

* Fixed a regression in `buffered_write_stream`.

* Fixed a non-paged pool "leak" on Windows when an `io_service` is repeatedly
  run without anything to do.

* Reverted earlier change to allow some speculative operations to be performed
  without holding the lock, as it introduced a race condition in some
  multithreaded scenarios.

* Fixed a bug where the second buffer in an array of two buffers may be ignored
  if the first buffer is empty.

[heading Asio 1.6.1]

* Implemented various performance improvements, including:

  * Using thread-local operation queues in single-threaded use cases (i.e. when
    `concurrency_hint` is 1) to eliminate a lock/unlock pair.

  * Allowing some `epoll_reactor` speculative operations to be performed
    without holding the lock.

  * Improving locality of reference by performing an `epoll_reactor`'s I/O
    operation immediately before the corresponding handler is called. This also
    improves scalability across CPUs when multiple threads are running the
    `io_service`.

  * Specialising asynchronous read and write operations for buffer sequences
    that are arrays (`boost::array` or `std::array`) of exactly two buffers.

* Fixed a compile error in the regex overload of `async_read_until`.

* Fixed a Windows-specific compile error by explicitly specifying the
  `signal()` function from the global namespace.

* Changed the `deadline_timer` implementation so that it does not read the
  clock unless the timer heap is non-empty.

* Changed the SSL stream's buffers' sizes so that they are large enough to hold
  a complete TLS record.

* Fixed the behaviour of the synchronous `null_buffers` operations so that they
  obey the user's non-blocking setting.

* Changed to set the size of the select `fd_set` at runtime when using Windows.

* Disabled an MSVC warning due to const qualifier being applied to function type.

* Fixed a crash that occurs when using the Intel C++ compiler.

* Changed the initialisation of the OpenSSL library so that it supports all
  available algorithms.

* Fixed the SSL error mapping used when the session is gracefully shut down.

* Added some latency test programs.

* Clarified that a read operation ends when the buffer is full.

* Fixed an exception safety issue in `epoll_reactor` initialisation.

* Made the number of strand implementations configurable by defining
  `(BOOST_)ASIO_STRAND_IMPLEMENTATIONS` to the desired number.

* Added support for a new `(BOOST_)ASIO_ENABLE_SEQUENTIAL_STRAND_ALLOCATION` flag
  which switches the allocation of strand implementations to use a round-robin
  approach rather than hashing.

* Fixed potential strand starvation issue that can occur when `strand.post()`
  is used.

[heading Asio 1.6.0]

* Improved support for C++0x move construction to further reduce copying of
  handler objects. In certain designs it is possible to eliminate virtually all
  copies. Move support is now enabled when compiling in [^-std=c++0x] mode on
  g++ 4.5 or higher.

* Added build support for platforms that don't provide either of `signal()` or
  `sigaction()`.

* Changed to use C++0x variadic templates when they are available, rather than
  generating function overloads using the Boost.Preprocessor library.

* Ensured the value of `errno` is preserved across the implementation's signal
  handler.

* On Windows, ensured the count of outstanding work is decremented for
  abandoned operations (i.e. operations that are being cleaned up within the
  `io_service` destructor).

* Fixed behaviour of zero-length reads and writes in the new SSL implementation.

* Added support for building with OpenSSL 1.0 when `OPENSSL_NO_SSL2` is defined.

* Changed most examples to treat a failure by an accept operation as non-fatal.

* Fixed an error in the [^tick_count_timer] example by making the duration type
  signed. Previously, a wait on an already-passed deadline would not return for
  a very long time.

[heading Asio 1.5.3]

* Added a new, completely rewritten SSL implementation. The new implementation
  compiles faster, shows substantially improved performance, and supports
  custom memory allocation and handler invocation. It includes new API features
  such as certificate verification callbacks and has improved error reporting.
  The new implementation is source-compatible with the old for most uses.
  However, if necessary, the old implementation may still be used by defining
  `(BOOST_)ASIO_ENABLE_OLD_SSL`.

* Added new `asio::buffer()` overloads for `std::array`, when available. The
  support is automatically enabled when compiling in [^-std=c++0x] mode on g++
  4.3 or higher, or when using MSVC 10. The support may be explicitly enabled
  by defining `(BOOST_)ASIO_HAS_STD_ARRAY`, or disabled by defining
  `(BOOST_)ASIO_DISABLE_STD_ARRAY`.

* Changed to use the C++0x standard library templates `array`, `shared_ptr`,
  `weak_ptr` and `atomic` when they are available, rather than the Boost
  equivalents.

* Support for `std::error_code` and `std::system_error` is no longer enabled by
  default for g++ 4.5, as that compiler's standard library does not implement
  `std::system_error::what()` correctly.

[heading Asio 1.5.2]

* Added support for C++0x move construction and assignment to sockets, serial
  ports, POSIX descriptors and Windows handles.

* Added support for the `fork()` system call. Programs that use `fork()` must
  call `io_service.notify_fork()` at the appropriate times. Two new examples
  have been added showing how to use this feature.

* Cleaned up the handling of errors reported by the `close()` system call. In
  particular, assume that most operating systems won't have `close()` fail with
  `EWOULDBLOCK`, but if it does then set the blocking mode and restart the call.
  If any other error occurs, assume the descriptor is closed.

* The kqueue flag `EV_ONESHOT` seems to cause problems on some versions of Mac
  OS X, with the `io_service` destructor getting stuck inside the `close()`
  system call. Changed the kqueue backend to use `EV_CLEAR` instead.

* Changed exception reporting to include the function name in exception `what()`
  messages.

* Fixed an insufficient initialisers warning with MinGW.

* Changed the `shutdown_service()` member functions to be private.

* Added archetypes for testing socket option functions.

* Added a missing lock in `signal_set_service::cancel()`.

* Fixed a copy/paste error in `SignalHandler` example.

* Added the inclusion of the signal header to `signal_set_service.hpp` so that
  constants like `NSIG` may be used.

* Changed the `signal_set_service` implementation so that it doesn't assume
  that `SIGRTMAX` is a compile-time constant.

* Changed the Boost.Asio examples so that they don't use Boost.Thread's
  convenience header. Use the header file that is specifically for the
  boost::thread class instead.

[heading Asio 1.5.1]

* Added support for signal handling, using a new class called `signal_set`.
  Programs may add one or more signals to the set, and then perform an
  `async_wait()` operation. The specified handler will be called when one of
  the signals occurs. The same signal number may registered with multiple
  `signal_set` objects, however the signal number must be used only with Asio.

* Added handler tracking, a new debugging aid. When enabled by defining
  `(BOOST_)ASIO_ENABLE_HANDLER_TRACKING`, Asio writes debugging output to the
  standard error stream. The output records asynchronous operations and the
  relationships between their handlers. It may be post-processed using the
  included [^handlerviz.pl] tool to create a visual representation of the
  handlers (requires GraphViz).

* Fixed a bug in `asio::streambuf` where the `consume()` function did not
  always update the internal buffer pointers correctly. The problem may occur
  when the `asio::streambuf` is filled with data using the standard C++ member
  functions such as `sputn()`. (Note: the problem does not manifest when the
  streambuf is populated by the Asio free functions `read()`,
  `async_read()`, `read_until()` or `async_read_until()`.)

* Fixed a bug on kqueue-based platforms, where reactor read operations that
  return false from their `perform()` function are not correctly re-registered
  with kqueue.

* Support for `std::error_code` and `std::system_error` is no longer enabled by
  default for MSVC10, as that compiler's standard library does not implement
  `std::system_error::what()` correctly.

* Modified the `buffers_iterator<>` and `ip::basic_resolver_iterator` classes
  so that the value_type typedefs are non-const byte types.

[heading Asio 1.5.0]

* Added support for timeouts on socket iostreams, such as `ip::tcp::iostream`.
  A timeout is set by calling `expires_at()` or `expires_from_now()` to
  establish a deadline. Any socket operations which occur past the deadline
  will put the iostream into a bad state.

* Added a new `error()` member function to socket iostreams, for retrieving the
  error code from the most recent system call.

* Added a new `basic_deadline_timer::cancel_one()` function. This function lets
  you cancel a single waiting handler on a timer. Handlers are cancelled in
  FIFO order.

* Added a new `transfer_exactly()` completion condition. This can be used to
  send or receive a specified number of bytes even if the total size of the
  buffer (or buffer sequence) is larger.

* Added new free functions `connect()` and `async_connect()`. These operations
  try each endpoint in a list until the socket is successfully connected.

* Extended the `buffer_size()` function so that it works for buffer sequences
  in addition to individual buffers.

* Added a new `buffer_copy()` function that can be used to copy the raw bytes
  between individual buffers and buffer sequences.

* Added new non-throwing overloads of `read()`, `read_at()`, `write()` and
  `write_at()` that do not require a completion condition.

* Added friendlier compiler errors for when a completion handler does not meet
  the necessary type requirements. When C++0x is available (currently supported
  for g++ 4.5 or later, and MSVC 10), `static_assert` is also used to generate
  an informative error message. This checking may be disabled by defining
  `(BOOST_)ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS`.

* Added support for using `std::error_code` and `std::system_error`, when
  available. The support is automatically enabled when compiling in
  [^-std=c++0x] mode on g++ 4.5 or higher, or when using MSVC 10. The support
  may be explicitly enabled by defining `ASIO_HAS_STD_SYSTEM_ERROR`, or
  disabled by defining `ASIO_DISABLE_STD_SYSTEM_ERROR`. (Available in non-Boost
  version of Asio only.)

* Made the `is_loopback()`, `is_unspecified()` and `is_multicast()` functions
  consistently available across the `ip::address`, `ip::address_v4` and
  `ip::address_v6` classes.

* Added new `non_blocking()` functions for managing the non-blocking behaviour
  of a socket or descriptor. The `io_control()` commands named `non_blocking_io`
  are now deprecated in favour of these new functions.

* Added new `native_non_blocking()` functions for managing the non-blocking
  mode of the underlying socket or descriptor. These functions are intended to
  allow the encapsulation of arbitrary non-blocking system calls as
  asynchronous operations, in a way that is transparent to the user of the
  socket object. The functions have no effect on the behaviour of the
  synchronous operations of the socket or descriptor.

* Added the `io_control()` member function for socket acceptors.

* For consistency with the C++0x standard library, deprecated the `native_type`
  typedefs in favour of `native_handle_type`, and the `native()` member
  functions in favour of `native_handle()`.

* Added a `release()` member function to posix descriptors. This function
  releases ownership of the underlying native descriptor to the caller.

* Added support for sequenced packet sockets (`SOCK_SEQPACKET`).

* Added a new `io_service::stopped()` function that can be used to determine
  whether the `io_service` has stopped (i.e. a `reset()` call is needed prior
  to any further calls to `run()`, `run_one()`, `poll()` or `poll_one()`).

* Reduced the copying of handler function objects.

* Added support for C++0x move construction to further reduce copying of
  handler objects. Move support is enabled when compiling in [^-std=c++0x] mode
  on g++ 4.5 or higher, or when using MSVC10.

* Removed the dependency on OS-provided macros for the well-known IPv4 and IPv6
  addresses. This should eliminate the annoying "missing braces around
  initializer" warnings.

* Reduced the size of `ip::basic_endpoint<>` objects (such as
  `ip::tcp::endpoint` and `ip::udp::endpoint`).

* Changed the reactor backends to assume that any descriptors or sockets added
  using `assign()` may have been `dup()`-ed, and so require explicit
  deregistration from the reactor.

* Changed the SSL error category to return error strings from the OpenSSL
  library.

* Changed the separate compilation support such that, to use Asio's SSL
  capabilities, you should also include 'asio/ssl/impl/src.hpp` in one source
  file in your program.

* Removed the deprecated member functions named `io_service()`. The
  `get_io_service()` member functions should be used instead.

* Removed the deprecated typedefs `resolver_query` and `resolver_iterator` from
  the `ip::tcp`, `ip::udp` and `ip::icmp` classes.

* Fixed a compile error on some versions of g++ due to anonymous enums.

* Added an explicit cast to the `FIONBIO` constant to int to suppress a compiler
  warning on some platforms.

* Fixed warnings reported by g++'s [^-Wshadow] compiler option.

[heading Asio 1.4.8]

* Fixed an integer overflow problem that occurs when
  `ip::address_v4::broadcast()` is used on 64-bit platforms.

* Fixed a problem on older Linux kernels (where epoll is used without `timerfd`
  support) that prevents timely delivery of `deadline_timer` handlers, after the
  program has been running for some time.

[heading Asio 1.4.7]

* Fixed a problem on kqueue-based platforms where a `deadline_timer` may
  never fire if the `io_service` is running in a background thread.

* Fixed a const-correctness issue that prevented valid uses of
  `has_service<>` from compiling.

* Fixed MinGW cross-compilation.

* Removed dependency on deprecated Boost.System functions (Boost.Asio only).

* Ensured `close()`/`closesocket()` failures are correctly propagated.

* Added a check for errors returned by `InitializeCriticalSectionAndSpinCount`.

* Added support for hardware flow control on QNX.

* Always use `pselect()` on HP-UX, if it is available.

* Ensured handler arguments are passed as lvalues.

* Fixed Windows build when thread support is disabled.

* Fixed a Windows-specific problem where `deadline_timer` objects with expiry
  times set more than 5 minutes in the future may never expire.

* Fixed the resolver backend on BSD platforms so that an empty service name
  resolves to port number `0`, as per the documentation.

* Fixed read operations so that they do not accept buffer sequences of type
  `const_buffers_1`.

* Redefined `Protocol` and `id` to avoid clashing with Objective-C++ keywords.

* Fixed a `vector` reallocation performance issue that can occur when there are
  many active `deadline_timer` objects.

* Fixed the kqueue backend so that it compiles on NetBSD.

* Fixed the socket `io_control()` implementation on 64-bit Mac OS X and BSD
  platforms.

* Fixed a Windows-specific problem where failures from `accept()` are
  incorrectly treated as successes.

* Deprecated the separate compilation header `asio/impl/src.cpp` in
  favour of `asio/impl/src.hpp`.

[heading Asio 1.4.6]

* Reduced compile times. (Note that some programs may need to add additional
  `#include`s, e.g. if the program uses boost::array but does not explicitly
  include `<boost/array.hpp>`.)

* Reduced the size of generated code.

* Refactored `deadline_timer` implementation to improve performance.

* Improved multiprocessor scalability on Windows by using a dedicated hidden
  thread to wait for timers.

* Improved performance of `asio::streambuf` with `async_read()` and
  `async_read_until()`. These read operations now use the existing capacity of
  the `streambuf` when reading, rather than limiting the read to 512 bytes.

* Added optional separate compilation. To enable, include
  `asio/impl/src.cpp` in one source file in a program, then
  build the program with `(BOOST_)ASIO_SEPARATE_COMPILATION` defined in the
  project\/compiler settings. Alternatively, `(BOOST_)ASIO_DYN_LINK` may be
  defined to build a separately-compiled Asio as part of a shared library.

* Added new macro `(BOOST_)ASIO_DISABLE_FENCED_BLOCK` to permit the disabling of
  memory fences around completion handlers, even if thread support is enabled.

* Reworked timeout examples to better illustrate typical use cases.

* Ensured that handler arguments are passed as const types.

* Fixed incorrect parameter order in `null_buffers` variant of `async_send_to`.

* Ensured unsigned char is used with `isdigit` in `getaddrinfo` emulation.

* Fixed handling of very small but non-zero timeouts.

* Fixed crash that occurred when an empty buffer sequence was passed to a
  composed read or write operation.

* Added missing operator+ overload in `buffers_iterator`.

* Implemented cancellation of `null_buffers` operations on Windows.

[heading Asio 1.4.5]

* Improved performance.

* Reduced compile times.

* Reduced the size of generated code.

* Extended the guarantee that background threads don't call user code to
  all asynchronous operations.

* Changed to use edge-triggered epoll on Linux.

* Changed to use `timerfd` for dispatching timers on Linux, when
  available.

* Changed to use one-shot notifications with kqueue on Mac OS X and BSD
  platforms.

* Added a bitmask type `ip::resolver_query_base::flags` as per the TR2
  proposal. This type prevents implicit conversion from `int` to
  `flags`, allowing the compiler to catch cases where users incorrectly
  pass a numeric port number as the service name.

* Added `#define NOMINMAX` for all Windows compilers. Users can define
  `(BOOST_)ASIO_NO_NOMINMAX` to suppress this definition.

* Fixed a bug where 0-byte asynchronous reads were incorrectly passing
  an `error::eof` result to the completion handler.

* Changed the `io_control()` member functions to always call `ioctl` on
  the underlying descriptor when modifying blocking mode.

* Changed the resolver implementation so that it no longer requires the
  typedefs `InternetProtocol::resolver_query` and
  `InternetProtocol::resolver_iterator`, as neither typedef is part of
  the documented `InternetProtocol` requirements. The corresponding
  typedefs in the `ip::tcp`, `ip::udp` and `ip::icmp` classes have been
  deprecated.

* Fixed out-of-band handling for reactors not based on `select()`.

* Added new `(BOOST_)ASIO_DISABLE_THREADS` macro that allows Asio's
  threading support to be independently disabled.

* Minor documentation improvements.

[heading Asio 1.4.4]

* Added a new HTTP Server 4 example illustrating the use of stackless
  coroutines with Asio.

* Changed handler allocation and invocation to use `boost::addressof` to
  get the address of handler objects, rather than applying `operator&`
  directly.

* Restricted MSVC buffer debugging workaround to 2008, as it causes a
  crash with 2010 beta 2.

* Fixed a problem with the lifetime of handler memory, where Windows
  needs the `OVERLAPPED` structure to be valid until both the initiating
  function call has returned and the completion packet has been
  delivered.

* Don't block signals while performing system calls, but instead restart
  the calls if they are interrupted.

* Documented the guarantee made by strand objects with respect to order
  of handler invocation.

* Changed strands to use a pool of implementations, to make copying of
  strands cheaper.

* Ensured that kqueue support is enabled for BSD platforms.

* Added a `boost_` prefix to the `extern "C"` thread entry point
  function.

* In `getaddrinfo` emulation, only check the socket type (`SOCK_STREAM`
  or `SOCK_DGRAM`) if a service name has been specified. This should
  allow the emulation to work with raw sockets.

* Added a workaround for some broken Windows firewalls that make a
  socket appear bound to 0.0.0.0 when it is in fact bound to 127.0.0.1.

* Applied a fix for reported excessive CPU usage under Solaris.

* Added some support for platforms that use older compilers such as g++
  2.95.

[heading Asio 1.4.3]

* Added a new ping example to illustrate the use of ICMP sockets.

* Changed the `buffered*_stream<>` templates to treat 0-byte reads and
  writes as no-ops, to comply with the documented type requirements for
  `SyncReadStream`, `AsyncReadStream`, `SyncWriteStream` and
  `AsyncWriteStream`.

* Changed some instances of the `throw` keyword to
  `boost::throw_exception()` to allow Asio to be used when exception
  support is disabled. Note that the SSL wrappers still require
  exception support.

* Made Asio compatible with the OpenSSL 1.0 beta.

* Eliminated a redundant system call in the Solaris /dev/poll backend.

* Fixed a bug in resizing of the bucket array in the internal hash maps.

* Ensured correct propagation of the error code when a synchronous
  accept fails.

* Ensured correct propagation of the error code when a synchronous read
  or write on a Windows `HANDLE` fails.

* Fixed failures reported when `_GLIBCXX_DEBUG` is defined.

* Fixed custom memory allocation support for timers.

* Tidied up various warnings reported by g++.

* Various documentation improvements, including more obvious hyperlinks
  to function overloads, header file information, examples for the
  handler type requirements, and adding enum values to the index.

[heading Asio 1.4.2]

* Implement automatic resizing of the bucket array in the internal hash
  maps. This is to improve performance for very large numbers of
  asynchronous operations and also to reduce memory usage for very small
  numbers. A new macro `(BOOST_)ASIO_HASH_MAP_BUCKETS` may be used to
  tweak the sizes used for the bucket arrays. (N.B. this feature
  introduced a bug which was fixed in Asio 1.4.3 / Boost 1.40.)

* Add performance optimisation for the Windows IOCP backend for when no
  timers are used.

* Prevent locale settings from affecting formatting of TCP and UDP
  endpoints.

* Fix a memory leak that occurred when an asynchronous SSL operation's
  completion handler threw an exception.

* Fix the implementation of `io_control()` so that it adheres to the
  documented type requirements for IoControlCommand.

* Fix incompatibility between Asio and ncurses.h.

* On Windows, specifically handle the case when an overlapped `ReadFile`
  call fails with `ERROR_MORE_DATA`. This enables a hack where a
  `windows::stream_handle` can be used with a message-oriented named
  pipe.

* Fix system call wrappers to always clear the error on success, as
  POSIX allows successful system calls to modify errno.

* Don't include termios.h if `(BOOST_)ASIO_DISABLE_SERIAL_PORT` is
  defined.

* Cleaned up some more MSVC level 4 warnings.

* Various documentation fixes.

[heading Asio 1.4.1]

* Improved compatibility with some Windows firewall software.

* Ensured arguments to `windows::overlapped_ptr::complete()` are correctly
  passed to the completion handler.

* Fixed a link problem and multicast failure on QNX.

* Fixed a compile error in SSL support on MinGW / g++ 3.4.5.

* Drop back to using a pipe for notification if eventfd is not available
  at runtime on Linux.

* Various minor bug and documentation fixes.

[heading Asio 1.4.0]

* Enhanced CompletionCondition concept with the signature
  `size_t CompletionCondition(error_code ec, size_t total)`, where the return
  value indicates the maximum number of bytes to be transferred on the next
  read or write operation. (The old CompletionCondition signature is still
  supported for backwards compatibility).

* New `windows::overlapped_ptr` class to allow arbitrary overlapped I/O
  functions (such as `TransmitFile`) to be used with Asio.

* On recent versions of Linux, an `eventfd` descriptor is now used (rather than
  a pipe) to interrupt a blocked select/epoll reactor.

* Added const overloads of `lowest_layer()`.

* Synchronous read, write, accept and connect operations are now thread safe
  (meaning that it is now permitted to perform concurrent synchronous
  operations on an individual socket, if supported by the OS).

* Reactor-based `io_service` implementations now use lazy initialisation to
  reduce the memory usage of an `io_service` object used only as a message
  queue.

[heading Asio 1.2.0]

* Added support for serial ports.

* Added support for UNIX domain sockets.

* Added support for raw sockets and ICMP.

* Added wrappers for POSIX stream-oriented file descriptors (excluding regular
  files).

* Added wrappers for Windows stream-oriented `HANDLE`s such as named pipes
  (requires `HANDLE`s that work with I/O completion ports).

* Added wrappers for Windows random-access `HANDLE`s such as files (requires
  `HANDLE`s that work with I/O completion ports).

* Added support for reactor-style operations (i.e. they report readiness but
  perform no I/O) using a new `null_buffers` type.

* Added an iterator type for bytewise traversal of buffer sequences.

* Added new `read_until()` and `async_read_until()` overloads that take a
  user-defined function object for locating message boundaries.

* Added an experimental two-lock queue (enabled by defining
  `(BOOST_)ASIO_ENABLE_TWO_LOCK_QUEUE`) that may provide better `io_service`
  scalability across many processors.

* Various fixes, performance improvements, and more complete coverage of the
  custom memory allocation support.

[heading Asio 1.0.0]

First stable release of Asio.

[endsect]
