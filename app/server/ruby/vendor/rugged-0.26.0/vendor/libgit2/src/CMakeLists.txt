IF(DEBUG_POOL)
	SET(GIT_DEBUG_POOL 1)
ENDIF()

SET(LIBGIT2_OBJECTS "")

# This variable will contain the libraries we need to put into
# libgit2.pc's Requires.private. That is, what we're linking to or
# what someone who's statically linking us needs to link to.
SET(LIBGIT2_PC_REQUIRES "")
# This will be set later if we use the system's http-parser library or
# use iconv (OSX) and will be written to the Libs.private field in the
# pc file.
SET(LIBGIT2_PC_LIBS "")

SET(LIBGIT2_INCLUDES
	"${CMAKE_CURRENT_BINARY_DIR}"
	"${CMAKE_SOURCE_DIR}/src"
	"${CMAKE_SOURCE_DIR}/include")
SET(LIBGIT2_LIBS "")
SET(LIBGIT2_LIBDIRS "")

# Installation paths
#
SET(BIN_INSTALL_DIR bin CACHE PATH "Where to install binaries to.")
SET(LIB_INSTALL_DIR lib CACHE PATH "Where to install libraries to.")
SET(INCLUDE_INSTALL_DIR include CACHE PATH "Where to install headers to.")

# Set a couple variables to be substituted inside the .pc file.
# We can't just use LIB_INSTALL_DIR in the .pc file, as passing them as absolue
# or relative paths is both valid and supported by cmake.
SET (PKGCONFIG_PREFIX ${CMAKE_INSTALL_PREFIX})

IF(IS_ABSOLUTE ${LIB_INSTALL_DIR})
  SET (PKGCONFIG_LIBDIR ${LIB_INSTALL_DIR})
ELSE(IS_ABSOLUTE ${LIB_INSTALL_DIR})
  SET (PKGCONFIG_LIBDIR "\${prefix}/${LIB_INSTALL_DIR}")
ENDIF (IS_ABSOLUTE ${LIB_INSTALL_DIR})

IF(IS_ABSOLUTE ${INCLUDE_INSTALL_DIR})
  SET (PKGCONFIG_INCLUDEDIR ${INCLUDE_INSTALL_DIR})
ELSE(IS_ABSOLUTE ${INCLUDE_INSTALL_DIR})
  SET (PKGCONFIG_INCLUDEDIR "\${prefix}/${INCLUDE_INSTALL_DIR}")
ENDIF(IS_ABSOLUTE ${INCLUDE_INSTALL_DIR})

# Enable tracing
IF (ENABLE_TRACE STREQUAL "ON")
	SET(GIT_TRACE 1)
ENDIF()

CHECK_SYMBOL_EXISTS(regcomp_l "regex.h;xlocale.h" HAVE_REGCOMP_L)
IF (HAVE_REGCOMP_L)
	SET(GIT_USE_REGCOMP_L 1)
ENDIF ()

CHECK_FUNCTION_EXISTS(futimens HAVE_FUTIMENS)
IF (HAVE_FUTIMENS)
	SET(GIT_USE_FUTIMENS 1)
ENDIF ()

CHECK_FUNCTION_EXISTS(qsort_r HAVE_QSORT_R)
IF (HAVE_QSORT_R)
	ADD_DEFINITIONS(-DHAVE_QSORT_R)
ENDIF ()

CHECK_FUNCTION_EXISTS(qsort_s HAVE_QSORT_S)
IF (HAVE_QSORT_S)
	ADD_DEFINITIONS(-DHAVE_QSORT_S)
ENDIF ()

# Find required dependencies

IF(WIN32)
	LIST(APPEND LIBGIT2_LIBS ws2_32)
ELSEIF(CMAKE_SYSTEM_NAME MATCHES "(Solaris|SunOS)")
	LIST(APPEND LIBGIT2_LIBS socket nsl)
	LIST(APPEND LIBGIT2_PC_LIBS "-lsocket" "-lnsl")
ELSEIF(CMAKE_SYSTEM_NAME MATCHES "Haiku")
	LIST(APPEND LIBGIT2_LIBS network)
	LIST(APPEND LIBGIT2_PC_LIBS "-lnetwork")
ENDIF()

CHECK_LIBRARY_EXISTS(rt clock_gettime "time.h" NEED_LIBRT)
IF(NEED_LIBRT)
	LIST(APPEND LIBGIT2_LIBS rt)
	LIST(APPEND LIBGIT2_PC_LIBS "-lrt")
ENDIF()

IF(THREADSAFE)
	LIST(APPEND LIBGIT2_LIBS ${CMAKE_THREAD_LIBS_INIT})
	LIST(APPEND LIBGIT2_PC_LIBS ${CMAKE_THREAD_LIBS_INIT})
ENDIF()

IF (SECURITY_FOUND)
  # OS X 10.7 and older do not have some functions we use, fall back to OpenSSL there
  CHECK_LIBRARY_EXISTS("${SECURITY_DIRS}" SSLCreateContext "Security/SecureTransport.h" HAVE_NEWER_SECURITY)
  IF (HAVE_NEWER_SECURITY)
    MESSAGE("-- Found Security ${SECURITY_DIRS}")
    LIST(APPEND LIBGIT2_PC_LIBS "-framework Security")
    LIST(APPEND LIBGIT2_LIBS ${SECURITY_DIRS})
  ELSE()
    MESSAGE("-- Security framework is too old, falling back to OpenSSL")
    SET(SECURITY_FOUND "NO")
    SET(USE_OPENSSL "ON")
  ENDIF()
ENDIF()

IF (COREFOUNDATION_FOUND)
  MESSAGE("-- Found CoreFoundation ${COREFOUNDATION_DIRS}")
  LIST(APPEND LIBGIT2_PC_LIBS "-framework CoreFoundation")
  LIST(APPEND LIBGIT2_LIBS ${COREFOUNDATION_DIRS})
ENDIF()


IF (WIN32 AND EMBED_SSH_PATH)
	FILE(GLOB SRC_SSH "${EMBED_SSH_PATH}/src/*.c")
	LIST(APPEND LIBGIT2_INCLUDES "${EMBED_SSH_PATH}/include")
	FILE(WRITE "${EMBED_SSH_PATH}/src/libssh2_config.h" "#define HAVE_WINCNG\n#define LIBSSH2_WINCNG\n#include \"../win32/libssh2_config.h\"")
	SET(GIT_SSH 1)
ENDIF()

IF (WIN32 AND WINHTTP)
	SET(GIT_WINHTTP 1)
	SET(GIT_HTTPS 1)

	# Since MinGW does not come with headers or an import library for winhttp,
	# we have to include a private header and generate our own import library
	IF (MINGW)
		ADD_SUBDIRECTORY("${CMAKE_SOURCE_DIR}/deps/winhttp" "${CMAKE_BINARY_DIR}/deps/winhttp")
		LIST(APPEND LIBGIT2_LIBS winhttp)
		LIST(APPEND LIBGIT2_INCLUDES "${CMAKE_SOURCE_DIR}/deps/winhttp")
		LIST(APPEND LIBGIT2_LIBDIRS ${LIBWINHTTP_PATH})
	ELSE()
		LIST(APPEND LIBGIT2_LIBS "winhttp")
		LIST(APPEND LIBGIT2_PC_LIBS "-lwinhttp")
	ENDIF ()

	LIST(APPEND LIBGIT2_LIBS "rpcrt4" "crypt32" "ole32")
	LIST(APPEND LIBGIT2_PC_LIBS "-lrpcrt4" "-lcrypt32" "-lole32")
ELSE ()
	IF (CURL)
		PKG_CHECK_MODULES(CURL libcurl)
	ENDIF ()

	IF (NOT AMIGA AND USE_OPENSSL)
		FIND_PACKAGE(OpenSSL)
	ENDIF ()

	IF (CURL_FOUND)
		SET(GIT_CURL 1)
		LIST(APPEND LIBGIT2_INCLUDES ${CURL_INCLUDE_DIRS})
		LIST(APPEND LIBGIT2_LIBDIRS ${CURL_LIBRARY_DIRS})
		LIST(APPEND LIBGIT2_LIBS ${CURL_LIBRARIES})
		LIST(APPEND LIBGIT2_PC_LIBS ${CURL_LDFLAGS})
	ENDIF()
ENDIF()

# Specify sha1 implementation
IF (USE_SHA1DC)
	SET(GIT_SHA1_COLLISIONDETECT 1)
	ADD_DEFINITIONS(-DSHA1DC_NO_STANDARD_INCLUDES=1)
	ADD_DEFINITIONS(-DSHA1DC_CUSTOM_INCLUDE_SHA1_C=\"common.h\")
	ADD_DEFINITIONS(-DSHA1DC_CUSTOM_INCLUDE_UBC_CHECK_C=\"common.h\")
	FILE(GLOB SRC_SHA1 hash/hash_collisiondetect.c hash/sha1dc/*)
ELSEIF (WIN32 AND NOT MINGW)
	SET(GIT_SHA1_WIN32 1)
	FILE(GLOB SRC_SHA1 hash/hash_win32.c)
ELSEIF (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
	SET(GIT_SHA1_COMMON_CRYPTO 1)
ELSEIF (OPENSSL_FOUND)
	SET(GIT_SHA1_OPENSSL 1)
	IF (CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
		LIST(APPEND LIBGIT2_PC_LIBS "-lssl")
	ELSE()
		SET(LIBGIT2_PC_REQUIRES "${LIBGIT2_PC_REQUIRES} openssl")
	ENDIF ()
ELSE()
	FILE(GLOB SRC_SHA1 hash/hash_generic.c)
ENDIF()


# Include POSIX regex when it is required
IF(WIN32 OR AMIGA OR CMAKE_SYSTEM_NAME MATCHES "(Solaris|SunOS)")
	ADD_SUBDIRECTORY("${CMAKE_SOURCE_DIR}/deps/regex" "${CMAKE_BINARY_DIR}/deps/regex")
	LIST(APPEND LIBGIT2_INCLUDES "${CMAKE_SOURCE_DIR}/deps/regex")
	LIST(APPEND LIBGIT2_OBJECTS $<TARGET_OBJECTS:regex>)
ENDIF()

# Optional external dependency: http-parser
FIND_PACKAGE(HTTP_Parser)
IF (USE_EXT_HTTP_PARSER AND HTTP_PARSER_FOUND AND HTTP_PARSER_VERSION_MAJOR EQUAL 2)
	LIST(APPEND LIBGIT2_INCLUDES ${HTTP_PARSER_INCLUDE_DIRS})
	LIST(APPEND LIBGIT2_LIBS ${HTTP_PARSER_LIBRARIES})
	LIST(APPEND LIBGIT2_PC_LIBS "-lhttp_parser")
ELSE()
	MESSAGE(STATUS "http-parser version 2 was not found or disabled; using bundled 3rd-party sources.")
	ADD_SUBDIRECTORY("${CMAKE_SOURCE_DIR}/deps/http-parser" "${CMAKE_BINARY_DIR}/deps/http-parser")
	LIST(APPEND LIBGIT2_INCLUDES "${CMAKE_SOURCE_DIR}/deps/http-parser")
	LIST(APPEND LIBGIT2_OBJECTS "$<TARGET_OBJECTS:http-parser>")
ENDIF()

# Optional external dependency: zlib
FIND_PACKAGE(ZLIB)
IF (ZLIB_FOUND)
	LIST(APPEND LIBGIT2_INCLUDES ${ZLIB_INCLUDE_DIRS})
	LIST(APPEND LIBGIT2_LIBS ${ZLIB_LIBRARIES})
	IF(APPLE OR CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
		LIST(APPEND LIBGIT2_LIBS "z")
		LIST(APPEND LIBGIT2_PC_LIBS "-lz")
	ELSE()
		SET(LIBGIT2_PC_REQUIRES "${LIBGIT2_PC_REQUIRES} zlib")
	ENDIF()
ELSE()
	MESSAGE(STATUS "zlib was not found; using bundled 3rd-party sources." )
	ADD_SUBDIRECTORY("${CMAKE_SOURCE_DIR}/deps/zlib" "${CMAKE_BINARY_DIR}/deps/zlib")
	LIST(APPEND LIBGIT2_INCLUDES "${CMAKE_SOURCE_DIR}/deps/zlib")
	LIST(APPEND LIBGIT2_OBJECTS $<TARGET_OBJECTS:zlib>)
ENDIF()

# Optional external dependency: libssh2
IF (USE_SSH)
	PKG_CHECK_MODULES(LIBSSH2 libssh2)
ENDIF()
IF (LIBSSH2_FOUND)
	SET(GIT_SSH 1)
	LIST(APPEND LIBGIT2_INCLUDES ${LIBSSH2_INCLUDE_DIRS})
	LIST(APPEND LIBGIT2_LIBS ${LIBSSH2_LIBRARIES})
	LIST(APPEND LIBGIT2_LIBDIRS ${LIBSSH2_LIBRARY_DIRS})
	LIST(APPEND LIBGIT2_PC_LIBS ${LIBSSH2_LDFLAGS})
	#SET(LIBGIT2_PC_LIBS "${LIBGIT2_PC_LIBS} ${LIBSSH2_LDFLAGS}")

	CHECK_LIBRARY_EXISTS("${LIBSSH2_LIBRARIES}" libssh2_userauth_publickey_frommemory "${LIBSSH2_LIBRARY_DIRS}" HAVE_LIBSSH2_MEMORY_CREDENTIALS)
	IF (HAVE_LIBSSH2_MEMORY_CREDENTIALS)
		SET(GIT_SSH_MEMORY_CREDENTIALS 1)
	ENDIF()
ELSE()
	MESSAGE(STATUS "LIBSSH2 not found. Set CMAKE_PREFIX_PATH if it is installed outside of the default search path.")
ENDIF()

# Optional external dependency: libgssapi
IF (USE_GSSAPI)
	FIND_PACKAGE(GSSAPI)
ENDIF()
IF (GSSAPI_FOUND)
	SET(GIT_GSSAPI 1)
	LIST(APPEND LIBGIT2_LIBS ${GSSAPI_LIBRARIES})
ENDIF()

# Optional external dependency: iconv
IF (USE_ICONV)
	FIND_PACKAGE(Iconv)
ENDIF()
IF (ICONV_FOUND)
	SET(GIT_USE_ICONV 1)
	LIST(APPEND LIBGIT2_INCLUDES ${ICONV_INCLUDE_DIR})
	LIST(APPEND LIBGIT2_LIBS ${ICONV_LIBRARIES})
	LIST(APPEND LIBGIT2_PC_LIBS ${ICONV_LIBRARIES})
ENDIF()

IF (SECURITY_FOUND)
	SET(GIT_SECURE_TRANSPORT 1)
	SET(GIT_HTTPS 1)
	LIST(APPEND LIBGIT2_INCLUDES ${SECURITY_INCLUDE_DIR})
ENDIF ()

IF (OPENSSL_FOUND)
	SET(GIT_OPENSSL 1)
	SET(GIT_HTTPS 1)
	LIST(APPEND LIBGIT2_INCLUDES ${OPENSSL_INCLUDE_DIR})
	LIST(APPEND LIBGIT2_LIBS ${OPENSSL_LIBRARIES})
ENDIF()



IF (THREADSAFE)
	IF (NOT WIN32)
		FIND_PACKAGE(Threads REQUIRED)
	ENDIF()

	SET(GIT_THREADS 1)
ENDIF()

IF (USE_NSEC)
	SET(GIT_USE_NSEC 1)
ENDIF()

IF (HAVE_STRUCT_STAT_ST_MTIM)
	SET(GIT_USE_STAT_MTIM 1)
ELSEIF (HAVE_STRUCT_STAT_ST_MTIMESPEC)
	SET(GIT_USE_STAT_MTIMESPEC 1)
ELSEIF (HAVE_STRUCT_STAT_ST_MTIME_NSEC)
	SET(GIT_USE_STAT_MTIME_NSEC 1)
ENDIF()

ADD_DEFINITIONS(-D_FILE_OFFSET_BITS=64)

# Collect sourcefiles
FILE(GLOB SRC_H
	"${CMAKE_SOURCE_DIR}/include/git2.h"
	"${CMAKE_SOURCE_DIR}/include/git2/*.h"
	"${CMAKE_SOURCE_DIR}/include/git2/sys/*.h")

# On Windows use specific platform sources
IF (WIN32 AND NOT CYGWIN)
	ADD_DEFINITIONS(-DWIN32 -D_WIN32_WINNT=0x0501)

	IF(MSVC)
		SET(WIN_RC "win32/git2.rc")
	ENDIF()

	FILE(GLOB SRC_OS win32/*.c win32/*.h)
ELSEIF (AMIGA)
	ADD_DEFINITIONS(-DNO_ADDRINFO -DNO_READDIR_R -DNO_MMAP)
ELSE()
	IF (VALGRIND)
		ADD_DEFINITIONS(-DNO_MMAP)
	ENDIF()
	FILE(GLOB SRC_OS unix/*.c unix/*.h)
ENDIF()
FILE(GLOB SRC_GIT2 *.c *.h transports/*.c transports/*.h xdiff/*.c xdiff/*.h)

# Determine architecture of the machine
IF (CMAKE_SIZEOF_VOID_P EQUAL 8)
	SET(GIT_ARCH_64 1)
ELSEIF (CMAKE_SIZEOF_VOID_P EQUAL 4)
	SET(GIT_ARCH_32 1)
ELSEIF (CMAKE_SIZEOF_VOID_P)
	MESSAGE(FATAL_ERROR "Unsupported architecture (pointer size is ${CMAKE_SIZEOF_VOID_P} bytes)")
ELSE()
	MESSAGE(FATAL_ERROR "Unsupported architecture (CMAKE_SIZEOF_VOID_P is unset)")
ENDIF()

CONFIGURE_FILE(features.h.in git2/sys/features.h)

SET(LIBGIT2_SOURCES ${SRC_H} ${SRC_GIT2} ${SRC_OS} ${SRC_SSH} ${SRC_SHA1})

ADD_LIBRARY(git2internal OBJECT ${LIBGIT2_SOURCES})
IDE_SPLIT_SOURCES(git2internal)
LIST(APPEND LIBGIT2_OBJECTS $<TARGET_OBJECTS:git2internal>)

IF (${CMAKE_VERSION} VERSION_LESS 2.8.12)
	INCLUDE_DIRECTORIES(${LIBGIT2_INCLUDES})
ELSE()
	TARGET_INCLUDE_DIRECTORIES(git2internal
	    PRIVATE ${LIBGIT2_INCLUDES}
	    PUBLIC ${CMAKE_SOURCE_DIR}/include)
ENDIF()

SET(LIBGIT2_OBJECTS ${LIBGIT2_OBJECTS} PARENT_SCOPE)
SET(LIBGIT2_INCLUDES ${LIBGIT2_INCLUDES} PARENT_SCOPE)
SET(LIBGIT2_LIBS ${LIBGIT2_LIBS} PARENT_SCOPE)
SET(LIBGIT2_LIBDIRS ${LIBGIT2_LIBDIRS} PARENT_SCOPE)

# Compile and link libgit2
LINK_DIRECTORIES(${LIBGIT2_LIBDIRS})
ADD_LIBRARY(git2 ${WIN_RC} ${LIBGIT2_OBJECTS})
TARGET_LINK_LIBRARIES(git2 ${LIBGIT2_LIBS})

SET_TARGET_PROPERTIES(git2 PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
SET_TARGET_PROPERTIES(git2 PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
SET_TARGET_PROPERTIES(git2 PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})

# Workaround for Cmake bug #0011240 (see http://public.kitware.com/Bug/view.php?id=11240)
# Win64+MSVC+static libs = linker error
IF(MSVC AND GIT_ARCH_64 AND NOT BUILD_SHARED_LIBS)
  SET_TARGET_PROPERTIES(git2 PROPERTIES STATIC_LIBRARY_FLAGS "/MACHINE:x64")
ENDIF()

IDE_SPLIT_SOURCES(git2)

IF (SONAME)
	SET_TARGET_PROPERTIES(git2 PROPERTIES VERSION ${LIBGIT2_VERSION_STRING})
	SET_TARGET_PROPERTIES(git2 PROPERTIES SOVERSION ${LIBGIT2_SOVERSION})
	IF (LIBGIT2_FILENAME)
		ADD_DEFINITIONS(-DLIBGIT2_FILENAME=\"${LIBGIT2_FILENAME}\")
		SET_TARGET_PROPERTIES(git2 PROPERTIES OUTPUT_NAME ${LIBGIT2_FILENAME})
	ELSEIF (DEFINED LIBGIT2_PREFIX)
		SET_TARGET_PROPERTIES(git2 PROPERTIES PREFIX "${LIBGIT2_PREFIX}")
	ENDIF()
ENDIF()
STRING(REPLACE ";" " " LIBGIT2_PC_LIBS "${LIBGIT2_PC_LIBS}")
CONFIGURE_FILE(${CMAKE_SOURCE_DIR}/libgit2.pc.in ${CMAKE_BINARY_DIR}/libgit2.pc @ONLY)

IF (MSVC_IDE)
   # Precompiled headers
   SET_TARGET_PROPERTIES(git2 PROPERTIES COMPILE_FLAGS "/Yuprecompiled.h /FIprecompiled.h")
   SET_SOURCE_FILES_PROPERTIES(win32/precompiled.c COMPILE_FLAGS "/Ycprecompiled.h")
ENDIF ()

# Install
INSTALL(TARGETS git2
	RUNTIME DESTINATION ${BIN_INSTALL_DIR}
	LIBRARY DESTINATION ${LIB_INSTALL_DIR}
	ARCHIVE DESTINATION ${LIB_INSTALL_DIR}
)
INSTALL(FILES ${CMAKE_BINARY_DIR}/libgit2.pc DESTINATION ${LIB_INSTALL_DIR}/pkgconfig )
INSTALL(DIRECTORY ${CMAKE_SOURCE_DIR}/include/git2 DESTINATION ${INCLUDE_INSTALL_DIR} )
INSTALL(FILES ${CMAKE_SOURCE_DIR}/include/git2.h DESTINATION ${INCLUDE_INSTALL_DIR} )
