# This file is distributed under the same license as the Sonic Pi package.
# Do not edit this file, use Weblate instead.
# Read TRANSLATION.md for more information.
msgid ""
msgstr ""
"Project-Id-Version: Sonic Pi\n"
"PO-Revision-Date: 2022-05-25 21:14+0000\n"
"Last-Translator: neginex <kanta.negishi.2021b@mlab.info>\n"
"Language-Team: Japanese <https://hosted.weblate.org/projects/sonic-pi/"
"tutorial/ja/>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13-dev\n"

#: 01-Welcome-to-Sonic-Pi.md:1
msgid "1 Welcome to Sonic Pi"
msgstr "1 Sonic Pi へようこそ"

#: 01-Welcome-to-Sonic-Pi.md:3
msgid "Welcome friend :-)"
msgstr "Welcome friend:-)"

#: 01-Welcome-to-Sonic-Pi.md:5
msgid ""
"Welcome to Sonic Pi. Hopefully you're as excited to get started making crazy s"
"ounds as I am to show you. It's going to be a really *fun* ride where you'll l"
"earn all about music, synthesis, programming, composition, performance and mor"
"e."
msgstr ""
"Sonic Pi（ソニックパイ）へようこそ。これから説明するクレイジーな音作りに、あなたも夢中になることを願っています。音楽、シンセ、プログラミング、作曲、"
"演奏など、これから学ぶことは、本当に刺激的なものになるでしょう。"

#: 01-Welcome-to-Sonic-Pi.md:10
msgid ""
"But wait, how rude of me! Let me introduce myself - I'm [Sam Aaron](https://tw"
"itter.com/samaaron) - the chap that created Sonic Pi. You can find me at [@sam"
"aaron](http://twitter.com/samaaron) on Twitter and I'd be more than happy to s"
"ay hello to you. You might also be interested in finding out more about my [Li"
"ve Coding Performances](https://youtube.com/samaaron) where I code with Sonic "
"Pi live in front of audiences."
msgstr ""
"でも、ちょっと待ってください。まずは自己紹介が必要でしたね。失礼いたしました！ 私は、Sonic Piを作成した[Sam Aaron](http://twi"
"tter.com/samaaron)といいます。Twitter上の[@samaaron](http://twitter.com/samaaron)で見つける"
"ことができますので、連絡くれるとうれしいです。もしかすると、僕がSonic Piを使って観客の前で演奏している[ライブコーディングのパフォーマンス](htt"
"ps://youtube.com/samaaron)にも興味を持ってもらえるかもしれません。"

#: 01-Welcome-to-Sonic-Pi.md:18
msgid ""
"If you have any thoughts, or ideas for improving Sonic Pi - please pass them o"
"n - feedback is so helpful. You never know, your idea might be the next big fe"
"ature!"
msgstr ""
"Sonic Piを改善するために、気づいたことや、アイデアを持っていたら、是非、知らせてください。フィードバックはとても役立ちます。あなたのアイデアが次の重"
"要な機能になるかもしれません！"

#: 01-Welcome-to-Sonic-Pi.md:22
msgid ""
"This tutorial is divided up into sections grouped by category. Whilst I've wri"
"tten it to have an easy learning progression from start to finish, feel very f"
"ree just to dip in and out of sections as you see fit. If you feel that there'"
"s something missing, do let me know and I'll consider it for a future version."
msgstr ""
"最後に、このチュートリアル（使いかた）は、カテゴリ別にグループ化されたセクションに分かれています。始まりから終わりまで、簡単に学べるように手引きを書いたので"
"、自由に、色々なセクションを覗いてみてください。何か、不足している点に気がついたら、将来のバージョンのために検討したいので、知らせてください。"

#: 01-Welcome-to-Sonic-Pi.md:28
msgid ""
"Finally, watching others live code is a really great way to learn. I regularly"
" stream live on [https://youtube.com/samaaron](http://youtube.com/samaaron) so"
" please do drop by, say hi and ask me lots of questions :-)"
msgstr ""
"最後に、他人のライブコーディングを見るのはとても良い学習方法です。私は定期的に[http://youtube.com/"
"samaaron](http://youtube.com/samaaron)でライブをストリーミングしているので、ぜひ立ち寄って、"
"たくさんの質問をしてみてください :-)"

#: 01-Welcome-to-Sonic-Pi.md:33
msgid "OK, let's get started..."
msgstr "では、早速はじめましょう！"

#: 01.1-Live-Coding.md:1
msgid "1.1 Live Coding"
msgstr "1.1 ライブコーディング"

#: 01.1-Live-Coding.md:3 09-Live-Coding.md:3 09.1-Live-Coding-Fundamentals.md:3
#: A.02-live-coding.md:3
msgid "Live Coding"
msgstr "ライブコーディング"

#: 01.1-Live-Coding.md:5
msgid ""
"One of the most exciting aspects of Sonic Pi is that it enables you to write a"
"nd *modify code live* to make music, just like you might perform live with a g"
"uitar. This means that given some practice you can take Sonic Pi on stage and "
"gig with it."
msgstr ""
"Sonic Piの最もエキサイティングな側面のひとつは、まるでギターをライブで演奏するかのように、ライブでコードを書いて音楽を作ることができることです。つま"
"り、ステージやコンサートでSonic Piが使えるということです！"

#: 01.1-Live-Coding.md:10
msgid "Free your mind"
msgstr "心を解き放て"

#: 01.1-Live-Coding.md:12
msgid ""
"Before we get into the real details of how Sonic Pi works in the rest of this "
"tutorial, I'd like to give you an experience of what it's like to live code. D"
"on't worry if you don't understand much (or any) of this. Just try to hold ont"
"o your seats and enjoy..."
msgstr ""
"これからチュートリアルで、実際のSonic Piの詳しい使い方に入る前に、まず、ライブコーディングがどんなものか体験してみましょう。あまり（もしくは全然）わ"
"からなくても、心配ご無用！ そのまま席についたまま、楽しんでいきましょう。"

#: 01.1-Live-Coding.md:17
msgid "A live loop"
msgstr "ライブループ"

#: 01.1-Live-Coding.md:19
msgid "Let's get started, copy the following code into an empty buffer:"
msgstr "さぁ、はじめましょう！ 下のコードを上の空欄のエディタにコピーしてみましょう。"

#: 01.1-Live-Coding.md:21
#, no-wrap
msgid ""
"live_loop :flibble do\n"
"  sample :bd_haus, rate: 1\n"
"  sleep 0.5\n"
"end"
msgstr ""
"live_loop :flibble do\n"
" sample :bd_haus, rate: 1\n"
" sleep 0.5\n"
"end"

#: 01.1-Live-Coding.md:28
msgid ""
"Now, press the `Run` button and you'll hear a nice fast bass drum beating away"
". If at any time you wish to stop the sound just hit the `Stop` button. Althou"
"gh don't hit it just yet... Instead, follow these steps:"
msgstr ""
"左上の`Run`（再生）ボタンを押すと、いい感じの速さでバスドラムの音が聞こえてきます。`Stop`（停止）ボタンを押せば、いつでも音を止めることができます"
"。ですが、まだ`Stop`（停止）ボタンを押さずに、次のステップを実行しましょう。"

#: 01.1-Live-Coding.md:32
msgid "Make sure the bass drum sound is still running"
msgstr "バスドラムがまだ鳴っていることを確認します。"

#: 01.1-Live-Coding.md:33
msgid "Change the `sleep` value from `0.5` to something higher like `1`."
msgstr "`sleep`の値を、`0.5`から、`1`のような、より大きい値に書き換えてみましょう。"

#: 01.1-Live-Coding.md:34
msgid "Press the `Run` button again"
msgstr "`Run`（再生）ボタンをもう一度押します。"

#: 01.1-Live-Coding.md:35
msgid "Notice how the drum speed has changed."
msgstr "ドラムの速さがどのように変わったかを確認してみましょう。"

#: 01.1-Live-Coding.md:36
msgid ""
"Finally, *remember this moment*, this is the first time you've live coded with"
" Sonic Pi and it's unlikely to be your last..."
msgstr "この瞬間を忘れないでください。これが、あなたが初めてSonic Piでライブコーディングをした瞬間です。そしてこれが最後にはならないはず…"

#: 01.1-Live-Coding.md:39
msgid ""
"Ok, that was simple enough. Let's add something else into the mix. Above `samp"
"le :bd_haus` add the line `sample :ambi_choir, rate: 0.3`. Your code should lo"
"ok like this:"
msgstr ""
"これは簡単でした。では他の要素を加えてみましょう。`sample :bd_haus`の上に、`sample :ambi_choir, rate: 0.3`を"
"追加してみます。コードはこのようになるはずです。"

#: 01.1-Live-Coding.md:43
#, no-wrap
msgid ""
"live_loop :flibble do\n"
"  sample :ambi_choir, rate: 0.3\n"
"  sample :bd_haus, rate: 1\n"
"  sleep 1\n"
"end"
msgstr ""
"live_loop :flibble do\n"
" sample :ambi_choir, rate: 0.3\n"
" sample :bd_haus, rate: 1\n"
" sleep 1\n"
"end"

#: 01.1-Live-Coding.md:51
msgid ""
"Now, play around. Change the rates - what happens when you use high values, or"
" small values or negative values? See what happens when you change the `rate:`"
" value for the `:ambi_choir` sample just slightly (say to `0.29`). What happen"
"s if you choose a really small `sleep` value? See if you can make it go so fas"
"t your computer will stop with an error because it can't keep up (if that happ"
"ens, just choose a bigger `sleep` time and hit `Run` again)."
msgstr ""
"では、ちょっと遊んでみましょう。値を変えてみてください。大きな値、小さな値、もしくはマイナスの値にしたとき、何が起こるでしょうか？ では、`:ambi_ch"
"oir`の`rate:`の値をほんの少し（0.29などに）変えた時、どうなるでしょう？ `sleep`の値をすごく小さくすると、どうでしょう？ 速くしすぎる"
"と、エラーが出てコンピュータが止まってしまいます。これはコンピュータがついていけないからです（そんな時は、より大きい値を`sleep`に設定して`Run`ボ"
"タンをもう一度押しましょう）。"

#: 01.1-Live-Coding.md:59
msgid "Try commenting one of the `sample` lines out by adding a `#` to the beginning:"
msgstr "では、`sample`の行に`#`をつけることで、「コメント」してみてください。"

#: 01.1-Live-Coding.md:62
#, no-wrap
msgid ""
"live_loop :flibble do\n"
"  sample :ambi_choir, rate: 0.3\n"
"#  sample :bd_haus, rate: 1\n"
"  sleep 1\n"
"end"
msgstr ""
"live_loop :flibble do\n"
" sample :ambi_choir, rate: 0.3\n"
"#  sample :bd_haus, rate: 1\n"
" sleep 1\n"
"end"

#: 01.1-Live-Coding.md:70
msgid ""
"Notice how it tells the computer to ignore it, so we don't hear it. This is ca"
"lled a comment. In Sonic Pi we can use comments to remove and add things into "
"the mix."
msgstr ""
"コンピュータに#をつけた行を無視するよう命令したので、聞こえませんね。これはコメントと呼ばれます。Sonic Piでは、要素を削除したり追加したりするのにコ"
"メントを使います。"

#: 01.1-Live-Coding.md:74
msgid ""
"Finally, let me leave you something fun to play with. Take the code below, and"
" copy it into a spare buffer. Now, don't try to understand it too much other t"
"han see that there are two loops - so two things going round at the same time."
" Now, do what you do best - experiment and play around. Here are some suggesti"
"ons:"
msgstr ""
"最後に、遊んでみると面白いのことをみなさんにお伝えしましょう。下のほうにあるコードを空いたBufferにコピーします。次に、2つのループがある（つまり2つの"
"ことが同時進行している）ということ以外は深く考えないようにして、遊びながら実験してみましょう。その際、以下のようなヒントがあります："

#: 01.1-Live-Coding.md:80
msgid "Try changing the blue `rate:` values to hear the sample sound change."
msgstr "`rate:`の青い値を変更し、`sample`の音が変わることを聞いてみましょう。"

#: 01.1-Live-Coding.md:81
msgid ""
"Try changing the `sleep` times and hear that both loops can spin round at diff"
"erent rates."
msgstr "`sleep`の時間を変更し、それぞれのループを異なる速度で繰り返すのを聞いてみましょう。"

#: 01.1-Live-Coding.md:83
msgid ""
"Try uncommenting the sample line (remove the `#`) and enjoy the sound of the g"
"uitar played backwards."
msgstr "`sample`の行のコメントを解除して（`#`を削除）、ギターの逆再生を楽しみましょう。"

#: 01.1-Live-Coding.md:85
msgid ""
"Try changing any of the blue `mix:` values to numbers between `0` (not in the "
"mix) and `1` (fully in the mix)."
msgstr "いくつかの`mix:`の値を`0`（最小値）から`1`（最大値）の間で変えてみましょう。"

#: 01.1-Live-Coding.md:88
msgid ""
"Remember to press `Run` and you'll hear the change next time the loop goes rou"
"nd. If you end up in a pickle, don't worry - hit `Stop`, delete the code in th"
"e buffer and paste a fresh copy in and you're ready to jam again. Making mista"
"kes is how you'll learn the quickest..."
msgstr ""
"`Run`ボタンを押すのを忘れないでください。次のループで音が変化するのを聞くことができるでしょう。うまくいかなくても気にしないでください。`Stop`ボタ"
"ンを押して、Buffer内のコードを削除して、新しいコードをコピー&ペーストして、再び演奏の準備をすれば良いです。失敗することがどんなことよりも学習の近道に"
"なるのですから。"

#: 01.1-Live-Coding.md:94
#, no-wrap
msgid ""
"live_loop :guit do\n"
"  with_fx :echo, mix: 0.3, phase: 0.25 do\n"
"    sample :guit_em9, rate: 0.5\n"
"  end\n"
"#  sample :guit_em9, rate: -0.5\n"
"  sleep 8\n"
"end\n"
"live_loop :boom do\n"
"  with_fx :reverb, room: 1 do\n"
"    sample :bd_boom, amp: 10, rate: 1\n"
"  end\n"
"  sleep 8\n"
"end"
msgstr ""
"live_loop :guit do\n"
" with_fx :echo, mix: 0.3, phase: 0.25 do\n"
"   sample :guit_em9, rate: 0.5\n"
" end\n"
"#  sample :guit_em9, rate: -0.5\n"
" sleep 8\n"
"end\n"
"live_loop :boom do\n"
" with_fx :reverb, room: 1 do\n"
"   sample :bd_boom, amp: 10, rate: 1\n"
" end\n"
" sleep 8\n"
"end"

#: 01.1-Live-Coding.md:111
msgid ""
"Now, keep playing and experimenting until your curiosity about how this all ac"
"tually works kicks in and you start wondering what else you can do with this. "
"You're now ready to read the rest of the tutorial."
msgstr ""
"さあ、これらが実際にどう動くか好奇心が動き出すまで、そしてあなたが次に何をしたらいいかを知りたくなるまで、演奏と実験を続けましょう。さあ、残りのチュートリア"
"ルを読む準備ができました。"

#: 01.1-Live-Coding.md:115
msgid "So what are you waiting for..."
msgstr "次にあなたを待っているものは…"

#: 01.2-Exploring-the-Interface.md:1
msgid "1.2 Exploring the Interface"
msgstr "1.2 インタフェースの探索"

#: 01.2-Exploring-the-Interface.md:3
msgid "The Sonic Pi Interface"
msgstr "Sonic Pi のインタフェース"

#: 01.2-Exploring-the-Interface.md:5
msgid ""
"Sonic Pi has a very simple interface for coding music. Let's spend a little ti"
"me exploring it."
msgstr "Sonic Piは、音楽をコーディング（記述）するためのとてもシンプルなインタフェース（操作画面）を持っています。ちょっと見てみましょう。"

#: 01.2-Exploring-the-Interface.md:8
msgid "![Sonic Pi Interface](../../../etc/doc/images/tutorial/GUI.png)"
msgstr "![Sonic Piのインターフェイス](../../../etc/doc/images/tutorial/GUI.png)"

#: 01.2-Exploring-the-Interface.md:11
msgid "*A* - Play Controls"
msgstr "*A* - 演奏の操作"

#: 01.2-Exploring-the-Interface.md:12
msgid "*B* - Editor Controls"
msgstr "*B* - 編集の操作"

#: 01.2-Exploring-the-Interface.md:13
msgid "*C* - Info and Help"
msgstr "*C* - 情報とヘルプ"

#: 01.2-Exploring-the-Interface.md:14
msgid "*D* - Code Editor"
msgstr "*D* - コードエディタ"

#: 01.2-Exploring-the-Interface.md:15
msgid "*E* - Prefs Panel"
msgstr "*E* - 設定画面"

#: 01.2-Exploring-the-Interface.md:16
msgid "*F* - Log Viewer"
msgstr "*F* - ログビューア"

#: 01.2-Exploring-the-Interface.md:17
msgid "*G* - Help System"
msgstr "*G* - ヘルプシステム"

#: 01.2-Exploring-the-Interface.md:18
msgid "*H* - Scope Viewer"
msgstr "*H* - スコープビューア"

#: 01.2-Exploring-the-Interface.md:19
msgid "*I* - Cue Viewer"
msgstr "*I* - キュービューア"

#: 01.2-Exploring-the-Interface.md:21
msgid "A. Play Controls"
msgstr "A. 演奏の操作"

#: 01.2-Exploring-the-Interface.md:23
msgid ""
"These pink buttons are the main controls for starting and stopping sounds. The"
"re's the *Run* button for running the code in the editor, *Stop* for stopping "
"all running code, *Save* for saving the code to an external file and *Record* "
"to create a recording (a WAV file) of the sound playing."
msgstr ""
"ここにあるピンクのボタンで、音を再生したり停止するための主要な操作ができます。*Run*ボタンは編集画面内のコードを実行します。*Stop*ボタンですべての"
"コードの動作を停止します。*Save*ボタンは外部ファイルにコードを保存し、*Record*ボタンは演奏中の音を（WAVファイルに）録音します。"

#: 01.2-Exploring-the-Interface.md:29
msgid "B. Editor Controls"
msgstr "B. 編集の操作"

#: 01.2-Exploring-the-Interface.md:31
msgid ""
"These orange buttons allow you to manipulate the code editor. The *Size +* and"
" *Size -* buttons allow you to make the text bigger and smaller."
msgstr ""
"ここにあるピンクのボタンでコードエディタの設定を変えられます。*Size +* と *Size -* "
"ボタンでコードエディタの文字を大きくしたり小さくしたりできます。"

#: 01.2-Exploring-the-Interface.md:35
msgid "C. Info and Help"
msgstr "C. 情報とヘルプ"

#: 01.2-Exploring-the-Interface.md:37
msgid ""
"These blue buttons give you access to information, help and preferences. The *"
"Info* button will open up the information window which contains information ab"
"out Sonic Pi itself - the core team, history, contributors and community. The "
"*Help* button toggles the help system (*G*) and the *Prefs* button toggles the"
" preferences window which allows you to control some basic system parameters."
msgstr ""
"これらの青いボタンで、情報、ヘルプや設定にアクセスします。*Info*ボタンは、概要、コア、協力者、コミュニティ、ライセンス、ヒストリーといったSonic "
"Pi自体についての情報を画面に表示します。*Help*ボタンは*G*のヘルプシステム表示を切り替えます。また*Prefs*ボタンは基本的なシステムを操作する"
"ための設定画面の表示を切り替えます。"

#: 01.2-Exploring-the-Interface.md:44
msgid "D. Code Editor"
msgstr "D. コードエディタ"

#: 01.2-Exploring-the-Interface.md:46
msgid ""
"This is the area where you'll write your code and compose/perform music. It's "
"a simple text editor where you can write code, delete it, cut and paste, etc. "
"Think of it like a very basic version of Word or Google Docs. The editor will "
"automatically colour words based on their meaning in the code. This may seem s"
"trange at first, but you'll soon find it very useful. For example, you'll know"
" something is a number because it is blue."
msgstr ""
"ここは音楽を作曲/演奏したりするためのコードを書く領域です。コードを書いたり、消したり、切り取り、貼り付けなどを行うためのシンプルな編集画面です。Googl"
"e DocsやWordの基本版だと思ってください。編集画面ではコードの意味合いに応じて自動で色つけします。はじめは変わっていると思うかもしれませんが、とても"
"使いやすくなるはずです。例えば、数値は青色で示されます。"

#: 01.2-Exploring-the-Interface.md:54
msgid "E. Prefs Panel"
msgstr "E. 設定画面"

#: 01.2-Exploring-the-Interface.md:56
msgid ""
"Sonic Pi supports a number of tweakable preferences which can be accessed by t"
"oggling the *prefs* button in the Info and Help button set. This will toggle t"
"he visibility of the Prefs Panel which includes a number of options to be chan"
"ged. Examples are forcing mono mode, inverting stereo, toggling log output ver"
"bosity and also a volume slider and audio selector on the Raspberry Pi."
msgstr ""
"Sonic Piには変更可能な設定がたくさんあり、*Prefs*ボタンを切り替えることでアクセスできます。このボタンにより、環境設定パネルの表示/非表示を"
"切り替えることができます。設定の例としては、モノラルモードへの変更や、ステレオ反転、ログ出力の切り替え、さらにRaspberry "
"Piのボリュームスライダーやオーディオセレクターなどがあります。"

#: 01.2-Exploring-the-Interface.md:63
msgid "F. Log Viewer"
msgstr "F. ログビューア"

#: 01.2-Exploring-the-Interface.md:65
msgid ""
"When you run your code, information about what the program is doing will be di"
"splayed in the log viewer. By default, you'll see a message for every sound yo"
"u create with the exact time the sound was triggered. This is very useful for "
"debugging your code and understanding what your code is doing."
msgstr ""
"コードを実行させた時、ログ画面にはプログラムがどうなっているかについての情報が表示されます。デフォルトでは、正確な再生時間を毎音ごとにメッセージとして見るこ"
"とができます。コードのデバッグ（欠陥を取り除く作業）に利用でき、コードが何をしているかを理解することにも役立ちます。"

#: 01.2-Exploring-the-Interface.md:71
msgid "G. Help System"
msgstr "G. ヘルプシステム"

#: 01.2-Exploring-the-Interface.md:73
msgid ""
"One of the most important parts of the Sonic Pi interface is the help system w"
"hich appears at the bottom of the window. This can be toggled on and off by cl"
"icking on the blue *Help* button. The help system contains help and informatio"
"n about all aspects of Sonic Pi including this tutorial, a list of available s"
"ynths, samples, examples, FX and a full list of all the functions Sonic Pi pro"
"vides for coding music."
msgstr ""
"最後は、Sonic Piインタフェースのもっとも重要な部分の1つである、画面の下にあるヘルプシステムです。青い*Help*ボタンによって表示/非表示を切り替"
"えることができます。ヘルプシステムは、ヘルプと情報を含んでいます。このチュートリアル、入手できるシンセのリスト、サンプルや実例、エフェクトのリスト、そして音"
"楽をコーディングするために備えているSonic Piの全機能のリストといった、Sonic Piの全てについてのヘルプと情報があります。"

#: 01.2-Exploring-the-Interface.md:81
msgid "H. Scope Viewer"
msgstr "H. スコープビューア"

#: 01.2-Exploring-the-Interface.md:83
msgid ""
"The scope viewer allows you to see the sound you're hearing. You can easily se"
"e that the saw wave looks like a saw and that the basic beep is a curvey sine "
"wave. You can also see the difference between loud and quiet sounds by the siz"
"e of the lines. There are 3 scopes to play with - the default is a combined sc"
"ope for the left and right channels, there is a stereo scope which draws a sep"
"arate scope for each channel. Finally there is a Lissajous curve scope which w"
"ill show the phase relationship between the left and right channels and allows"
" you to draw pretty pictures with sound (https://en.wikipedia.org/wiki/Lissajo"
"us_curve)."
msgstr ""
"スコープビューアは、あなたの聞いている音を見ることを可能にします。ノコギリ波がのこぎりのようだったり、単純なビープ音が正弦波であることを簡単に見ることが出"
"来ます。また、うるさい音と静かな音の違いを線の大きさで見ることも可能です。Sonic Piには、3つのスコープがあります。デフォルトは左右のチャネルを混ぜ"
"あわせたモノラルスコープです。左右のチャネルを別々のスコープで描画するステレオスコープがあります。最後に、左右のチャネルの位相の関係を描画する[リサジュー"
"ス曲線](https://ja.wikipedia.org/wiki/"
"%E3%83%AA%E3%82%B5%E3%82%B8%E3%83%A5%E3%83%BC%E5%9B%B3%E5%BD%A2)スコープがあります。"

#: 01.2-Exploring-the-Interface.md:93
msgid "I. Cue Viewer"
msgstr "F. キュービューア"

#: 01.2-Exploring-the-Interface.md:95
msgid ""
"All internal and external events (called cues in Sonic Pi) are automatically l"
"ogged in the Cue Viewer. For example, if you have a MIDI controller connected "
"and press one of its buttons, you'll see a new cue event in the Cue Viewer tel"
"ling you the name of the controller and which button you pressed. Once you've "
"mastered the basics of making and producing sounds, you'll start to want to cu"
"e sounds or whole sections of sounds based on events such as these. A cue even"
"t is just an indication that something happened. For example, every time a liv"
"e loop spins round, it sends a cue event out which is logged in the Cue Viewer"
". Also, external events such as MIDI messages from connected MIDI equipment an"
"d OSC messages from other programs or computers are also displayed in the Cue "
"Viewer. It is also possible to directly generate cue events using the `cue` fu"
"nction. Anything that appears in the Cue Viewer can be used to trigger somethi"
"ng happening. This is covered in more detail in Sections 10 to 12 of this tuto"
"rial."
msgstr ""
"すべての内部および外部のイベント（Sonic Piではキューと呼ばれます）は、キュー"
"ビューアーに自動的に記録されます。たとえば、MIDIコントローラーが接続された状"
"態でボタンを押すと、コントローラーの名前からなる新しいキューイベントがキュー"
"ビューアーに表示されます。サウンドの作成と生成の基本をマスターすると、このよ"
"うなイベントに基づいて、サウンドまたはサウンドのセクション全体をキューに入れ"
"たいと思うようになります。キューイベントは、何かが起こったことを示すだけです"
"。たとえば、ライブループが実行されるたびに、キュービューアに記録されているキ"
"ューイベントが送信されます。また、接続されているMIDI機器からのMIDIメッセージ"
"や他のプログラムやコンピューターからのOSCメッセージなどの外部イベントもキュー"
"ビューアーに表示されます。 `cue`関数を使用してキューイベントを直接生成するこ"
"ともできます。キュービューアに表示されるものはすべて、何かが発生するようにト"
"リガーするために使用できます。これについては、このチュートリアルのセクション1"
"0〜12で詳しく説明しています。"

#: 01.3-Learning-through-Play.md:1
msgid "1.3 Learning through Play"
msgstr "1.3 遊びを通した学び"

#: 01.3-Learning-through-Play.md:3
msgid "Learning through Play"
msgstr "遊びを通した学び"

#: 01.3-Learning-through-Play.md:5
msgid ""
"Sonic Pi encourages you to learn about both computing and music through play a"
"nd experimentation. The most important thing is that you're having fun, and be"
"fore you know it you'll have accidentally learned how to code, compose and per"
"form."
msgstr ""
"Sonic Piは、遊びと実験を通して、コンピューティングと音楽の両方を学ぶ手助けをしてくれます。もっとも大切なことは、楽しむこと。そうすれば、コードや作曲"
"、演奏を、学ぶ前に自然と身につけられるでしょう。"

#: 01.3-Learning-through-Play.md:10
msgid "There are no mistakes"
msgstr "間違いはない"

#: 01.3-Learning-through-Play.md:12
msgid ""
"Whilst we're on this subject, let me just give you one piece of advice I've le"
"arned over my years of live coding with music - *there are no mistakes, only o"
"pportunities*. This is something I've often heard in relation to jazz but it w"
"orks equally well with live coding. No matter how experienced you are - from a"
" complete beginner to a seasoned live coder, you'll run some code that has a c"
"ompletely unexpected outcome. It might sound insanely cool - in which case run"
" with it. However, it might sound totally jarring and out of place. It doesn't"
" matter that it happened - what matters is what you do next with it. Take the "
"sound, manipulate it and morph it into something awesome. The crowd will go *w"
"ild*."
msgstr ""
"このチュートリアルの内容に取り組むにあたって、私が何年もライブコーディングし"
"てきて得られたアドバイスを紹介しましょう。「間違いはない、あるのはただ可能性"
"だけ」これは、しばしばジャズについて言われることですが、ライブコーディングに"
"も同様に言えることです。経験に関係なく、あなたが全くの初心者でも、熟練のライ"
"ブコーダーでも、コードを実行してまったく予期せぬ結果になることがあります。め"
"ちゃくちゃクールに聞こえる場合は、そのコードを実行すればいいのですが、すごく"
"耳障りで場違いに聞こえる場合もあります。そうなっても問題ではありません。重要"
"なのは、あなたが次にすべきことです。音を取り、操作し、素晴らしいものに変える"
"のです。観衆は*熱狂*するでしょう。"

#: 01.3-Learning-through-Play.md:24
msgid "Start Simple"
msgstr "シンプルにはじめよう"

#: 01.3-Learning-through-Play.md:26
msgid ""
"When you're learning, it's tempting to want to do amazing things *now*. Howeve"
"r, just hold that thought and see it as a distant goal to reach *later*. For n"
"ow, instead think of the *simplest* thing you could write which would be fun a"
"nd rewarding that's a small step towards the amazing thing you have in your he"
"ad. Once you have an idea about that simple step, then try and build it, play "
"with it and then see what new ideas it gives you. Before long you'll be too bu"
"sy having fun and making real progress."
msgstr ""
"学習していると、*今すぐ*すごいことをしたい気持ちに駆られます。しかし、今はその気持ちをこらえ、それは*後に*到達する遠い目標として持ってください。その代わ"
"り、今のところは、あなたが楽しくやりがいをもって書くことができる*最も単純な*事を考えていきましょう。それが、あなたの頭の中のすごいことへの小さな一歩になる"
"のです。一度その単純な一歩についてアイデアを思いついたら、それを作って遊んでみてください。そして、そこからどのような新しいアイデアを得られるか見てみましょう"
"。すぐに、あなたは楽しみながら確実に上達することに大忙しになっているでしょう。"

#: 01.3-Learning-through-Play.md:35
msgid "Just make sure to share your work with others!"
msgstr "でも、みんなと作品をシェア（共有）することは忘れないでください！"

#: 02-Synths.md:1
msgid "2 Synths"
msgstr "2 シンセ"

#: 02-Synths.md:3 02.3-Switching-Synths.md:11
msgid "Synths"
msgstr "シンセ"

#: 02-Synths.md:5
msgid "OK, enough of the intros - let's get into some sound."
msgstr "Sonic Piの紹介はこれくらいにして、さっそく音を試してみましょう。"

#: 02-Synths.md:7
#, fuzzy
msgid ""
"In this section we'll cover the basics of triggering and manipulating synths. "
"Synth is short for synthesiser which is a fancy word for something which creat"
"es sounds. Typically synths are quite complicated to use - especially analog s"
"ynths such as Eurorack modules connected together by a mess of wires. However,"
" Sonic Pi gives you much of that power in a very simple and approachable manne"
"r."
msgstr ""
"この章では、基本的なシンセ（synth）の出し方と操作方法を紹介します。シンセは、音を作り出すシンセサイザーという響きのよい言葉を短縮したものです。典型的な"
"シンセは、非常に使うのが複雑です。特にアナログのシンセは、沢山のパッチワイヤーとモジュールがついています。ですが、Sonic Piでは、とても簡単で親しみや"
"すい方法で、このシンセの力を手に入れることが出来ます。"

#: 02-Synths.md:14
msgid ""
"Don't be fooled by the immediate simplicity of Sonic Pi's interface. You can g"
"et very deep into very sophisticated sound manipulation if that's your thing. "
"Hold on to your hats..."
msgstr "Sonic Piの分かりやすくシンプルな操作画面に騙されないでください。もし使いこなせたら、洗練されたサウンド操作を可能にします。きっと驚くはずです。"

#: 02.1-Your-First-Beeps.md:1
msgid "2.1 Your First Beeps"
msgstr "2.1 初めての音"

#: 02.1-Your-First-Beeps.md:3
msgid "Your First Beeps"
msgstr "初めての音"

#: 02.1-Your-First-Beeps.md:5
msgid "Take a look at the following code:"
msgstr "次のコードを見てください。"

#: 02.1-Your-First-Beeps.md:7 02.4-Durations-with-Envelopes.md:49
#: A.20-creative-coding-in-the-classroom.md:158
#, no-wrap
msgid "play 70"
msgstr "play 70"

#: 02.1-Your-First-Beeps.md:11
msgid ""
"This is where it all starts. Go ahead, copy and paste it into the code window "
"at the top of the app (the big white space under the Run button). Now, press R"
"un..."
msgstr ""
"ここからすべてが始まります。アプリケーションの上部のコードウィンドウ（`Run`ボタンの下の大きな空白）にコピーして貼り付けます。そして、`Run`ボタンを"
"押してみましょう。"

#: 02.1-Your-First-Beeps.md:15
msgid "Beep!"
msgstr "ビープ音が鳴った！"

#: 02.1-Your-First-Beeps.md:17
msgid "Intense. Press it again. And again. *And again...*"
msgstr "ビックリした？ もう1回、押してみましょう。*そしてもう1回…*"

#: 02.1-Your-First-Beeps.md:19
msgid ""
"Woah, crazy, I'm sure you could keep doing that all day. But wait, before you "
"lose yourself in an infinite stream of beeps, try changing the number:"
msgstr "わお！ すごい！ 一日中楽しんで居られそうだけど、でも待って。ビープ音の無限の流れに夢中になる前に、数値を変えてみましょう。"

#: 02.1-Your-First-Beeps.md:23
#, no-wrap
msgid "play 75"
msgstr "play 75"

#: 02.1-Your-First-Beeps.md:27
msgid "Can you hear the difference? Try a lower number:"
msgstr "違いが分かりますか？ より低い値も試してみましょう。"

#: 02.1-Your-First-Beeps.md:29
#, no-wrap
msgid "play 60"
msgstr "play 60"

#: 02.1-Your-First-Beeps.md:33
msgid ""
"So, lower numbers make lower pitched beeps and higher numbers make higher pitc"
"hed beeps. Just like on a piano, the keys at the lower part of the piano (the "
"left hand side) play lower notes and the keys on the higher part of the piano "
"(the right hand side) play higher notes."
msgstr ""
"したがって、数値が小さいほどビープ音のピッチが低くなり、数値が大きいほどビープ音のピッチが高くなります。 "
"ピアノと同じように、ピアノの下部（左側）のキーは低い音を演奏し、ピアノの上部（右側）のキーは高い音を演奏します。"

#: 02.1-Your-First-Beeps.md:38
msgid ""
"It turns out that the C of the 4th octave (C in English notation) is identifie"
"d by the number 60. `play 60` therefore plays the C of the 4th octave. To play"
" the next piano key to the right, you have to add 1 to 60 and then type `play "
"61`, which in this case is the black key of the C sharp. To play the D, the ne"
"xt key to the right, `play 62`."
msgstr ""
"ド(英語圏でのCの第4オクターブ)は数値60で表せます。よって、`play "
"60`はドを再生します。ピアノの次の音を奏でるには、数値60に1を足して`play 61`と"
"入力する、この場合はピアノの黒鍵、ド#が再生されます。レを再生するにはこの次の"
"鍵盤の数値である、`play 62`で再生することができます。"

#: 02.1-Your-First-Beeps.md:40
msgid ""
"*Don't worry* if this means nothing to you - it didn't to me when I first star"
"ted. All that matters right now is that you know that *low numbers make lower "
"beeps* and *high numbers make higher beeps*."
msgstr ""
"もし、これがあなたにとって何の意味か分からなくても*心配しない*でください。私も始めた時は同じでした。いま重要なことは、*小さい数値は低い音*を、*大きい"
"数値は高い音*を生み出す、ということを知っておくことです。"

#: 02.1-Your-First-Beeps.md:44 08.2-Chords.md:3
msgid "Chords"
msgstr "和音"

#: 02.1-Your-First-Beeps.md:46
msgid ""
"Playing a note is quite fun, but playing many at the same time can be even bet"
"ter. Try it:"
msgstr "音符を奏でることはとても楽しいですが、同時にたくさんの音符を鳴らすとさらに楽しくなります。これを試してみましょう。"

#: 02.1-Your-First-Beeps.md:49
#, no-wrap
msgid ""
"play 72\n"
"play 75\n"
"play 79"
msgstr ""
"play 72\n"
"play 75\n"
"play 79"

#: 02.1-Your-First-Beeps.md:55
msgid ""
"Jazzy! So, when you write multiple `play`s, they all play at the same time. Tr"
"y it for yourself - which numbers sound good together? Which sound terrible? E"
"xperiment, explore and find out for yourself."
msgstr ""
"華やかです！ 複数の`play`を書くと、全て同時に演奏されます。自分で試してみましょう。どの数値がいい組み合わせでしょうか？ どれがひどい音？ 実験、探求"
"しながら、自分自身で見つけていきましょう。"

#: 02.1-Your-First-Beeps.md:59
msgid "Melody"
msgstr "メロディー"

#: 02.1-Your-First-Beeps.md:61
msgid ""
"So, playing notes and chords is fun - but how about a melody? What if you want"
"ed to play one note after another and not at the same time? Well, that's easy,"
" you just need to `sleep` between the notes:"
msgstr ""
"音符と和音を演奏するのは楽しいですね。でも、メロディーの演奏はどうすればよい"
"でしょうか？一音ずつ、同時ではなく演奏したい場合は？ "
"それは簡単です。音符の間に`sleep`を入れば可能です。"

#: 02.1-Your-First-Beeps.md:65
#, no-wrap
msgid ""
"play 72\n"
"sleep 1\n"
"play 75\n"
"sleep 1\n"
"play 79"
msgstr ""
"play 72\n"
"sleep 1\n"
"play 75\n"
"sleep 1\n"
"play 79"

#: 02.1-Your-First-Beeps.md:73
msgid ""
"How lovely, a little arpeggio. So what does the `1` mean in `sleep 1`? Well it"
" means the *duration of the sleep*. It actually means sleep for one beat, but "
"for now we can think about it as sleeping for 1 second. So, what if we wanted "
"to make our arpeggio a little faster? Well, we need to use shorter sleep value"
"s. What about a half i.e. `0.5`:"
msgstr ""
"なんて素敵なアルペジオ（和音を続けて弾くこと）！ では、`sleep 1`の`1`は何を意味するのでしょうか？ これは1拍休む、という意味ですが、とりあえず"
"今は、1秒休む、と考えましょう。では、アルペジオをもう少し早くしたいと思ったら？ それは、短い値を使えばよいのです。例えば半分の値`0.5`ではどうでしょう"
"？"

#: 02.1-Your-First-Beeps.md:79
#, no-wrap
msgid ""
"play 72\n"
"sleep 0.5\n"
"play 75\n"
"sleep 0.5\n"
"play 79"
msgstr ""
"play 72\n"
"sleep 0.5\n"
"play 75\n"
"sleep 0.5\n"
"play 79"

#: 02.1-Your-First-Beeps.md:87
msgid ""
"Notice how it plays faster. Now, try for yourself, change the times - use diff"
"erent times and notes."
msgstr "早くなりましたね。では、自分で時間を変えてみましょう。違う時間と音符を使ってみましょう。"

#: 02.1-Your-First-Beeps.md:90
msgid ""
"One thing to try is in-between notes such as `play 52.3` and `play 52.63`. The"
"re's absolutely no need to stick to standard whole notes. Play around and have"
" fun."
msgstr ""
"たとえば`play 52.3`や`play 52.63`のような中間的な値でも演奏してみてください。通常の音符にこだわる必要は全くありません。遊んで、楽しん"
"でみてください。"

#: 02.1-Your-First-Beeps.md:95
msgid "Traditional Note Names"
msgstr "伝統的な音符の名前"

#: 02.1-Your-First-Beeps.md:97
msgid ""
"For those of you that already know some musical notation (don't worry if you d"
"on't - you don't need it to have fun) you might want to write a melody using n"
"ote names such as C and F# rather than numbers. Sonic Pi has you covered. You "
"can do the following:"
msgstr ""
"みなさんの中で、すでにいくつかの音楽記号を知っている人は、たとえばCとかF#などの音名を使ってメロディーを書きたいかも知れません（もし知らなくても心配無用で"
"す。それが必要というわけではありません）。Sonic Piはそれをカバーしてくれます。以下のことをやってみましょう。"

#: 02.1-Your-First-Beeps.md:102
#, no-wrap
msgid ""
"play :C\n"
"sleep 0.5\n"
"play :D\n"
"sleep 0.5\n"
"play :E"
msgstr ""
"play :C\n"
"sleep 0.5\n"
"play :D\n"
"sleep 0.5\n"
"play :E"

#: 02.1-Your-First-Beeps.md:110
msgid ""
"Remember to put the colon `:` in front of your note name so that it goes pink."
" Also, you can specify the octave by adding a number after the note name:"
msgstr ""
"演奏する音階の前にコロン':'を入れることを忘れないでください。コロンを置くと、Cが`:C`のように色が変わります。また、音名のあとに数値を追加してオクター"
"ヴを指定することもできます。"

#: 02.1-Your-First-Beeps.md:114
#, no-wrap
msgid ""
"play :C3\n"
"sleep 0.5\n"
"play :D3\n"
"sleep 0.5\n"
"play :E4"
msgstr ""
"play :C3\n"
"sleep 0.5\n"
"play :D3\n"
"sleep 0.5\n"
"play :E4"

#: 02.1-Your-First-Beeps.md:122
msgid ""
"If you want to make a note sharp, add an `s` after the note name such as `play"
" :Fs3` and if you want to make a note flat, add a `b` such as `play :Eb3`."
msgstr ""
"半音♯（シャープ）にしたい場合は、’play :Fs3'のように音名の後に's'を追加します。半音♭（フラット）にしたい場合は、'play :Eb3'のよう"
"に'b'を追加します。"

#: 02.1-Your-First-Beeps.md:125
msgid "Now go *crazy* and have fun making your own tunes."
msgstr "*夢中*になって、自分の曲を作って楽しみましょう。"

#: 02.2-Synth-Params.md:1
msgid "2.2 Synth Options"
msgstr "2.2 シンセのオプション"

#: 02.2-Synth-Params.md:3
msgid "Synth Options: Amp and Pan"
msgstr "シンセのオプション: ampとpan"

#: 02.2-Synth-Params.md:5
msgid ""
"As well as allowing you to control which note to play or which sample to trigg"
"er, Sonic Pi provides a whole range of options to craft and control the sounds"
". We'll be covering many of these in this tutorial and there's extensive docum"
"entation for each in the help system. However, for now we'll introduce two of "
"the most useful: *amplitude* and *pan*. First, let's look at what options actu"
"ally are."
msgstr ""
"Sonic Piは、演奏した音符や再生したサンプルを制御可能なだけでなく、音の作成や制御のための様々なオプションを提供しています。このチュートリアルではこれ"
"らの多くを紹介していく予定です。また、ヘルプシステムにはそれぞれについての詳細なドキュメントがあります。ここでは、その中でも最も有用なものの2つ、*ampl"
"itude（音量）*と*pan（パン）*を紹介します。では最初に、オプションが実際にどのようなものか見てみましょう。"

#: 02.2-Synth-Params.md:13
msgid "Options"
msgstr "オプション"

#: 02.2-Synth-Params.md:15
msgid ""
"Sonic Pi supports the notion of options (or opts for short) for its synths. Op"
"ts are controls you pass to `play` which modify and control aspects of the sou"
"nd you hear. Each synth has its own set of opts for finely tuning its sound. H"
"owever, there are common sets of opts shared by many sounds such as `amp:` and"
" envelope opts (covered in another section)."
msgstr ""
"Sonic Piはシンセのためにオプションという概念を備えています。オプションは、サウンドの特徴をコントロールしたり変更するための手段で、`play`に渡さ"
"れます。シンセはそれぞれ独自に細かく音をチューニングするためのオプションを持っています。その一方で、`amp:`（音量）やエンベロープ（他の章で紹介します）"
"のような、多くのサウンドに共通するオプションもあります。"

#: 02.2-Synth-Params.md:22
msgid ""
"Opts have two major parts, their name (the name of the control) and their valu"
"e (the value you want to set the control at). For example, you might have a op"
"t called `cheese:` and want to set it with a value of `1`."
msgstr ""
"オプションは2つの主要な部分からなり、1つはその名前（制御の名前）で、もう1つはその値（制御に設定したい値）です。例えば、`cheese:`というオプション"
"があったとして、`1`の値にセットしたいとします。"

#: 02.2-Synth-Params.md:27
msgid ""
"Opts are passed to calls to `play` by using a comma `,` and then the name of t"
"he opt such as `amp:` (don't forget the colon `:`) and then a space and the va"
"lue of the opt. For example:"
msgstr ""
"オプションは、`play`の後にカンマ`,`を入れて、その後、`amp:`（コロン`:`を忘れずに）のようなオプションの名前、スペース、そしてオプションの値"
"、というように渡していきます。例えば、"

#: 02.2-Synth-Params.md:31
#, no-wrap
msgid "play 50, cheese: 1"
msgstr "play 50, cheese: 1"

#: 02.2-Synth-Params.md:35
msgid "(Note that `cheese:` isn't a valid opt, we're just using it as an example)."
msgstr "（`cheese:`は無効なオプションです。例として使っています）"

#: 02.2-Synth-Params.md:37
msgid "You can pass multiple opts by separating them with a comma:"
msgstr "カンマを使って区切り、複数のオプションを使用することができます。"

#: 02.2-Synth-Params.md:39
#, no-wrap
msgid "play 50, cheese: 1, beans: 0.5"
msgstr "play 50, cheese: 1, beans: 0.5"

#: 02.2-Synth-Params.md:43
msgid "The order of the opts doesn't matter, so the following is identical:"
msgstr "オプションの順番は問題ではないので、以下は同じものです。"

#: 02.2-Synth-Params.md:45
#, no-wrap
msgid "play 50, beans: 0.5, cheese: 1"
msgstr "play 50, beans: 0.5, cheese: 1"

#: 02.2-Synth-Params.md:49
msgid ""
"Opts that aren't recognised by the synth are just ignored (like `cheese` and `"
"beans` which are clearly ridiculous opt names!)"
msgstr "シンセで認識されないオプションは無視されます（`cheese`（チーズ）と`beans`（豆）などは明らかに馬鹿げた名前でしょう！）"

#: 02.2-Synth-Params.md:52
msgid ""
"If you accidentally use the same opt twice with different values, the last one"
" wins. For example, `beans:` here will have the value 2 rather than 0.5:"
msgstr "もし偶然同じオプションを2回、違う値で使った場合は、最後のものが有効になります。例えば、ここでの`beans:`は、0.5ではなく2の値が採用されます。"

#: 02.2-Synth-Params.md:56
#, no-wrap
msgid "play 50, beans: 0.5, cheese: 3, eggs: 0.1, beans: 2"
msgstr "play 50, beans: 0.5, cheese: 3, eggs: 0.1, beans: 2"

#: 02.2-Synth-Params.md:60
msgid ""
"Many things in Sonic Pi accept opts, so just spend a little time learning how "
"to use them and you'll be set! Let's play with our first opt: `amp:`."
msgstr ""
"Sonic Piの多くの命令にはオプションが用意されているので、ちょっとだけ時間を使って、その使い方を習得しましょう！ それでは最初のオプション`amp:`"
"で演奏してみましょう。"

#: 02.2-Synth-Params.md:64 02.4-Durations-with-Envelopes.md:25
msgid "Amplitude"
msgstr "アンプ（音量）"

#: 02.2-Synth-Params.md:66
msgid ""
"Amplitude is a computer representation of the loudness of a sound. A *high amp"
"litude produces a loud sound* and a *low amplitude produces a quiet sound*. Ju"
"st as Sonic Pi uses numbers to represent time and notes, it uses numbers to re"
"present amplitude. An amplitude of 0 is silent (you'll hear nothing) whereas a"
"n amplitude of 1 is normal volume. You can even crank up the amplitude higher "
"to 2, 10, 100. However, you should note that when the overall amplitude of all"
" the sounds gets too high, Sonic Pi uses what's called a compressor to squash "
"them all to make sure things aren't too loud for your ears. This can often mak"
"e the sound muddy and strange. So try to use low amplitudes, i.e. in the range"
" 0 to 0.5 to avoid compression."
msgstr ""
"アンプは音の大きさをコンピュータで表したものです。*アンプが大きいと大きな音を出し*、*アンプが小さいと静かな音を出し*ます。Sonic Piは時間と音符を"
"数字を使って表現するので、アンプにも数字を使用します。1の値が通常の音量であるのに対して、0はサイレント（無音）です（何も聞こえませんよ）。2、10、100"
" というふうに、アンプを上げることができます。ただし、全体の音を増幅しすぎると、大きな音になりすぎないように、Sonic Piはコンプレッサー（圧縮）と呼ば"
"れるエフェクトを使用して確実な音量に抑えることを覚えておいてください。これは多くの場合、音がこもって奇妙に聞こえます。ですから、圧縮を防ぐために0から0.5"
"のような値で使用してみてください。"

#: 02.2-Synth-Params.md:79
msgid "Amp it up"
msgstr "音量を上げる"

#: 02.2-Synth-Params.md:81
msgid ""
"To change the amplitude of a sound, you can use the `amp:` opt. For example, t"
"o play at half amplitude pass 0.5:"
msgstr "音の大きさを変えるために、`amp:`オプションを使います。例として、半分の音量で演奏するために、0.5にしてみます。"

#: 02.2-Synth-Params.md:84
#, no-wrap
msgid "play 60, amp: 0.5"
msgstr "play 60, amp: 0.5"

#: 02.2-Synth-Params.md:88
msgid "To play at double amplitude pass 2:"
msgstr "倍の音量で演奏するために、2にしてみます。"

#: 02.2-Synth-Params.md:90
#, no-wrap
msgid "play 60, amp: 2"
msgstr "play 60, amp: 2"

#: 02.2-Synth-Params.md:94
msgid ""
"The `amp:` opt only modifies the call to `play` it's associated with. So, in t"
"his example, the first call to play is at half volume and the second is back t"
"o the default (1):"
msgstr ""
"`amp:`オプションは、関連付けられている`play`への命令だけを変更します。ですから、この例では、最初の命令は半分の音量になり、次はデフォルトの値（1"
"）に戻ります。"

#: 02.2-Synth-Params.md:98
#, no-wrap
msgid ""
"play 60, amp: 0.5\n"
"sleep 0.5\n"
"play 65"
msgstr ""
"play 60, amp: 0.5\n"
"sleep 0.5\n"
"play 65"

#: 02.2-Synth-Params.md:104
msgid "Of course, you can use different `amp:` values for each call to play:"
msgstr "もちろん、それぞれの命令で異なった`amp:`の値を設定して演奏することもできます。"

#: 02.2-Synth-Params.md:106
#, no-wrap
msgid ""
"play 50, amp: 0.1\n"
"sleep 0.25\n"
"play 55, amp: 0.2\n"
"sleep 0.25\n"
"play 57, amp: 0.4\n"
"sleep 0.25\n"
"play 62, amp: 1"
msgstr ""
"play 50, amp: 0.1\n"
"sleep 0.25\n"
"play 55, amp: 0.2\n"
"sleep 0.25\n"
"play 57, amp: 0.4\n"
"sleep 0.25\n"
"play 62, amp: 1"

#: 02.2-Synth-Params.md:116
msgid "Panning"
msgstr "パンニング"

#: 02.2-Synth-Params.md:118
msgid ""
"Another fun opt to use is `pan:` which controls the panning of a sound in ster"
"eo. Panning a sound to the left means that you hear it out of the left speaker"
", and panning it to the right means you hear it out of your right speaker. For"
" our values, we use a -1 to represent fully left, 0 to represent center and 1 "
"to represent fully right in the stereo field. Of course, we're free to use any"
" value between -1 and 1 to control the exact positioning of our sound."
msgstr ""
"もうひとつの面白いオプションは`pan:`です。ステレオで音の位置を制御します。左に音をパンすることは左のスピーカーから音が聞こえることを意味し、右にパンす"
"れば右のスピーカーから聞こえます。値としては、-1は最も左、0は中心、1は最も右、というようにステレオの領域で表現することができます。もちろん、音の正確な位"
"置をコントロールするために、-1から1の間のどの値でも使用することができます。"

#: 02.2-Synth-Params.md:126
msgid "Let's play a beep out of the left speaker:"
msgstr "左のスピーカーから音を鳴らしてみましょう。"

#: 02.2-Synth-Params.md:128
#, no-wrap
msgid "play 60, pan: -1"
msgstr "play 60, pan: -1"

#: 02.2-Synth-Params.md:132
msgid "Now, let's play it out of the right speaker:"
msgstr "では、右のスピーカーから鳴らします。"

#: 02.2-Synth-Params.md:134
#, no-wrap
msgid "play 60, pan: 1"
msgstr "play 60, pan: 1"

#: 02.2-Synth-Params.md:138
msgid "Finally let's play it back out of the center of both (the default position):"
msgstr "最後に元の通り、中心から鳴らしてみます（デフォルトの位置です）。"

#: 02.2-Synth-Params.md:141
#, no-wrap
msgid "play 60, pan: 0"
msgstr "play 60, pan: 0"

#: 02.2-Synth-Params.md:145
msgid "Now, go and have fun changing the amplitude and panning of your sounds!"
msgstr "では、続けてあなたの音のアンプやパンを変えて楽しんでみましょう！"

#: 02.3-Switching-Synths.md:1
msgid "2.3 Switching Synths"
msgstr "2.3 シンセの切り替え"

#: 02.3-Switching-Synths.md:3
msgid "Switching Synths"
msgstr "シンセの切り替え"

#: 02.3-Switching-Synths.md:5
msgid ""
"So far we've had quite a lot of fun making beeps. However, you're probably sta"
"rting to get bored of the basic beep noise. Is that all Sonic Pi has to offer?"
" Surely there's more to live coding than just playing beeps? Yes there is, and"
" in this section we'll explore some of the exciting range of sounds that Sonic"
" Pi has to offer."
msgstr ""
"これまで、ビープ音を鳴らして楽しんできました。けれども、もしかするとあなたは"
"このベーシックなビープ音に退屈し始めているかも知れません。これがSonic "
"Piが提供してくれるサウンドの全てなのでしょうか？ もちろん、ビープ音だけではな"
"くて、もっと他にもたくさんのライブコーディングがありますよね？ "
"はい、あります。この章ではSonic "
"Piが作り出すワクワクさせる音を試してみましょう。"

#: 02.3-Switching-Synths.md:13
msgid ""
"Sonic Pi has a number of different instruments it calls synths (which is *shor"
"t for synthesisers*). Whereas samples represent pre-recorded sounds, synths ar"
"e capable of generating new sounds depending on how you control them (which we"
"'ll explore later in this tutorial). Sonic Pi's synths are very powerful and e"
"xpressive and you'll have a lot of fun exploring and playing with them. First,"
" let's learn how to select the current synth to use."
msgstr ""
"Sonic Piは、シンセサイザーの略であるシンセと呼ばれる楽器の機能を持っています"
"。サンプルがすでに録音された音であるのに対して、シンセはあなたがそれをコント"
"ロールすることに応じて新しいサウンドを生み出すことができます（このチュートリ"
"アルの後半でみていきます）。Sonic Piのシンセは、パワフルで表現力に富んでいて"
"、試しながら演奏したり、楽しめるはずです。最初に、ひとまずここでシンセを使う"
"ために、選び方を学んでみましょう。"

#: 02.3-Switching-Synths.md:21
msgid "Buzzy saws and prophets"
msgstr "賑やかなsawとprophet"

#: 02.3-Switching-Synths.md:23
msgid "A fun sound is the *saw wave* - let's give it a try:"
msgstr "面白い音は、*ノコギリ（saw）波*です。試してみましょう。"

#: 02.3-Switching-Synths.md:25
#, no-wrap
msgid ""
"use_synth :saw\n"
"play 38\n"
"sleep 0.25\n"
"play 50\n"
"sleep 0.25\n"
"play 62"
msgstr ""
"use_synth :saw\n"
"play 38\n"
"sleep 0.25\n"
"play 50\n"
"sleep 0.25\n"
"play 62"

#: 02.3-Switching-Synths.md:34
msgid "Let's try another sound - the *prophet*:"
msgstr "他の音*prophet*を試してみましょう。"

#: 02.3-Switching-Synths.md:36
#, no-wrap
msgid ""
"use_synth :prophet\n"
"play 38\n"
"sleep 0.25\n"
"play 50\n"
"sleep 0.25\n"
"play 62"
msgstr ""
"use_synth :prophet\n"
"play 38\n"
"sleep 0.25\n"
"play 50\n"
"sleep 0.25\n"
"play 62"

#: 02.3-Switching-Synths.md:45
msgid "How about combining two sounds. First one after another:"
msgstr "2つを一緒にしたらどうでしょう。一方のあとに、もう一方を。"

#: 02.3-Switching-Synths.md:47
#, no-wrap
msgid ""
"use_synth :saw\n"
"play 38\n"
"sleep 0.25\n"
"play 50\n"
"sleep 0.25\n"
"use_synth :prophet\n"
"play 57"
msgstr ""
"use_synth :saw\n"
"play 38\n"
"sleep 0.25\n"
"play 50\n"
"sleep 0.25\n"
"use_synth :prophet\n"
"play 57"

#: 02.3-Switching-Synths.md:57
msgid ""
"Now multiple sounds at the same time (by not sleeping between successive calls"
" to `play`):"
msgstr "（連続する `play`の間にスリープを入れないことで）同時に複数のサウンドが鳴ります："

#: 02.3-Switching-Synths.md:60
#, no-wrap
msgid ""
"use_synth :tb303\n"
"play 38\n"
"use_synth :dsaw\n"
"play 50\n"
"use_synth :prophet\n"
"play 57"
msgstr ""
"use_synth :tb303\n"
"play 38\n"
"use_synth :dsaw\n"
"play 50\n"
"use_synth :prophet\n"
"play 57"

#: 02.3-Switching-Synths.md:69
msgid ""
"Notice that the `use_synth` command only affects the following calls to `play`"
". Think of it like a *big switch* - new calls to `play` will play whatever syn"
"th it's currently pointing to. You can move the switch to a new synth with `us"
"e_synth`."
msgstr ""
"`use_synth`コマンドは、下の`play`にだけ影響していることに注意してください。大きなスイッチのようなものだと考えてください。指定したどんなシン"
"セでも、新しい`play`へ命令として演奏されます。`use_synth`で新しいシンセにスイッチすることができます。"

#: 02.3-Switching-Synths.md:75
msgid "Discovering Synths"
msgstr "シンセを見つける"

#: 02.3-Switching-Synths.md:77
msgid ""
"To see which synths Sonic Pi has for you to play with take a look at the Synth"
"s option in the menu at the bottom of this help screen (between Examples & Fx)"
". There are over 20 to choose from. Here are a few of my favourites:"
msgstr ""
"Sonic Piにあるシンセを確認するには、このヘルプ画面の下部にあるメニューのシンセ・オプション確認してください（ExamplesとFxの間）。20種類"
"以上あります。その中から私のお気に入りをいくつか紹介します："

#: 02.3-Switching-Synths.md:81
msgid "`:prophet`"
msgstr "`:prophet`"

#: 02.3-Switching-Synths.md:82
msgid "`:dsaw`"
msgstr "`:dsaw`"

#: 02.3-Switching-Synths.md:83
msgid "`:fm`"
msgstr "`:fm`"

#: 02.3-Switching-Synths.md:84
msgid "`:tb303`"
msgstr "`:tb303`"

#: 02.3-Switching-Synths.md:85
msgid "`:pulse`"
msgstr "`:pulse`"

#: 02.3-Switching-Synths.md:87
msgid ""
"Now play around with *switching synths during your music*. Have fun combining "
"synths to make new sounds as well as using different synths for different sect"
"ions of your music."
msgstr ""
"では、*音楽の中でシンセを切り替えて*遊んでみてください。音楽の異なるセクションに違うシンセを使うように、シンセを組み合わせて新しい音を作って楽しんでくださ"
"い。"

#: 02.4-Durations-with-Envelopes.md:1
msgid "2.4 Duration with Envelopes"
msgstr "2.4 エンベロープでのデュレーション"

#: 02.4-Durations-with-Envelopes.md:3
msgid "Duration with Envelopes"
msgstr "エンベロープでのデュレーション"

#: 02.4-Durations-with-Envelopes.md:5
msgid ""
"In an earlier section, we looked at how we can use the `sleep` command to cont"
"rol when to trigger our sounds. However, we haven't yet been able to control t"
"he duration of our sounds."
msgstr ""
"前のほうのセクションで、音をいつ再生するか制御するのに、どのように`sleep`コマンドを使用可能か見てきました。しかし、まだ我々は音のデュレーション（長さ"
"）を制御できていないですね。"

#: 02.4-Durations-with-Envelopes.md:9
msgid ""
"In order to give us a simple, yet powerful means of *controlling the duration*"
" of our sounds, Sonic Pi provides the notion of an *ADSR amplitude envelope* ("
"we'll cover what ADSR means later in this section). An amplitude envelope offe"
"rs two useful aspects of control:"
msgstr ""
"音のデュレーションを制御するための、パワフルでシンプルな手段として、Sonic Piには*ADSR amplitude envelope*（ADSR・アンプ"
"・エンベロープ）という概念があります（ADSRが何を意味するかはこのセクションの後半で紹介します）。アンプ・エンベロープは制御のための便利な2つの側面を持っ"
"ています。"

#: 02.4-Durations-with-Envelopes.md:14
msgid "control over the duration of a sound"
msgstr "音のデュレーション（長さ）を制御する"

#: 02.4-Durations-with-Envelopes.md:15
msgid "control over the amplitude of a sound"
msgstr "音のアンプ（音量）を制御する"

#: 02.4-Durations-with-Envelopes.md:17
msgid "Duration"
msgstr "デュレーション"

#: 02.4-Durations-with-Envelopes.md:19
msgid ""
"The duration is the length the sound lasts for. A longer duration means that y"
"ou hear the sound for longer. Sonic Pi's sounds all have a controllable amplit"
"ude envelope, and the total duration of that envelope is the duration of the s"
"ound. Therefore, by controlling the envelope you control the duration."
msgstr ""
"デュレーションは音の持続する長さのことです。長いデュレーションは、より長く音が鳴ることを意味します。Sonic Piの全てのサウンドは、アンプ・エンベロープ"
"で制御でき、ひとつのエンベロープ（音量や音色の時間的な変化）の長さは、音の長さでもあります。"

#: 02.4-Durations-with-Envelopes.md:27
msgid ""
"The ADSR envelope not only controls duration, it also gives you *fine control "
"over the amplitude of the sound*. All audible sounds start and end silent and "
"contain some non-silent part in-between. Envelopes allow you to slide and hold"
" the amplitude of non-silent parts of the sound. It's like giving someone inst"
"ructions on how to turn up and down the volume of a guitar amplifier. For exam"
"ple you might ask someone to \"start at silence, slowly move up to full volume,"
" hold it for a bit, then quickly fall back to silence.\" Sonic Pi allows you to"
" program exactly this behaviour with envelopes."
msgstr ""
"ADSRエンベロープは、デュレーションの制御だけでなく、*アンプ（音量）の緻密な制御*も可能にします。全てのサウンドは、サイレント（無音）で始まり、間に音が"
"あり、またサイレントで終了します。エンベロープを使用すると、サウンドの音がある部分の音量をスライドさせたり、保持したりすることができます。これは、音楽の音量"
"を上げたり下げたりするのを、誰かに指示するような感じです。例えば、あなたは誰かに「無音で始めて、ゆっくりとフル・ボリュームにして、少しそのままで、そして一気"
"に無音に戻る」と頼むとします。Sonic Piはエンベロープでこれをプログラムできるようにしてくれます。"

#: 02.4-Durations-with-Envelopes.md:37
msgid ""
"Just to recap, as we have seen before, an amplitude of 0 is silence and an amp"
"litude of 1 is normal volume."
msgstr "前のセクションで見てきたように、アンプの`0`は無音、`1`は通常の音量です。"

#: 02.4-Durations-with-Envelopes.md:40
msgid "Now, let us look at each of the parts of the envelopes in turn."
msgstr "では、エンベロープのそれぞれの部分を順番に見ていきましょう。"

#: 02.4-Durations-with-Envelopes.md:42
msgid "Release Phase"
msgstr "リリース・フェーズ（終わるまでの時間）"

#: 02.4-Durations-with-Envelopes.md:44
msgid ""
"The only part of the envelope that's used by default is the release time. This"
" is the time it takes for the synth's sound to fade out. All synths have a rel"
"ease time of 1 which means that by default they have a duration of 1 beat (whi"
"ch at the default BPM of 60 is 1 second):"
msgstr ""
"エンベロープのうちデフォルトで使われている唯一の部分はリリース・フェーズです。通常、全てのシンセのリリース・フェーズ（終わるまでの時間）は1で、これは終了す"
"るまでに1拍（デフォルトBPMの60の場合には1秒）のデュレーションを持っているということです。"

#: 02.4-Durations-with-Envelopes.md:53
msgid ""
"The note will be audible for 1 second. Go ahead and time it :-) This is short "
"hand for the longer more explicit version:"
msgstr "この音は1秒間だけ聞こえます。続いて時間を指定しよう。上の記述は、次の明示的で長い記述を簡略化したものです。"

#: 02.4-Durations-with-Envelopes.md:56
#, no-wrap
msgid "play 70, release: 1"
msgstr "play 70, release: 1"

#: 02.4-Durations-with-Envelopes.md:60
msgid ""
"Notice how this sounds exactly the same (the sound lasts for one second). Howe"
"ver, it's now very easy to change the duration by modifying the value of the `"
"release:` opt:"
msgstr ""
"これも全く同じように（1秒間持続する）音が出たと思います。しかし、`release:`のオプションを変更することでとても簡単に持続時間を変更することができる"
"ようになりました。"

#: 02.4-Durations-with-Envelopes.md:64
#, no-wrap
msgid "play 60, release: 2"
msgstr "play 60, release: 2"

#: 02.4-Durations-with-Envelopes.md:68
msgid ""
"We can make the synth sound for a very short amount of time by using a very sm"
"all release time:"
msgstr "また、非常に小さなリリース・フェーズの値を使って、シンセのサウンドをとても短くすることができます。"

#: 02.4-Durations-with-Envelopes.md:71
#, no-wrap
msgid "play 60, release: 0.2"
msgstr "play 60, release: 0.2"

#: 02.4-Durations-with-Envelopes.md:75
msgid ""
"The duration of the release of the sound is called the *release phase* and by "
"default is a linear transition (i.e. a straight line). The following diagram i"
"llustrates this transition:"
msgstr ""
"音がリリースされるまでの持続時間はリリース・フェーズと呼ばれていて、デフォルトではリニア・トランジション（直線的な移行、つまり真っ直ぐ）です。以下の図は、こ"
"の移行を表したものです。"

#: 02.4-Durations-with-Envelopes.md:79
#, fuzzy
msgid "![release envelope](../../../etc/doc/images/tutorial/env-release.png)"
msgstr "![release envelope](../../../etc/doc/images/tutorial/env-release.png)"

#: 02.4-Durations-with-Envelopes.md:81
msgid ""
"The vertical line at the far left of the diagram shows that the sound starts a"
"t 0 amplitude, but goes up to full amplitude immediately (this is the attack p"
"hase which we'll cover next). Once at full amplitude it then moves in a straig"
"ht line down to zero taking the amount of time specified by `release:`. *Longe"
"r release times produce longer synth fade outs.*"
msgstr ""
"図の左端の縦の線は、サウンドが`0`の音量（ゼロ・アンプ）からスタートしているこ"
"とを示しています。しかし、すぐに最大アンプに上がります（これは私たちが後で学"
"ぶ、アタック・フェーズというものです）。いったん最大アンプになり、それから`re"
"lease:`で指定した値を取りながら、直線的にゼロに下がります。*長いリリース・タ"
"イムは長いシンセ・フェード・アウト（徐々に消えること）を生成します。*"

#: 02.4-Durations-with-Envelopes.md:88
msgid ""
"You can therefore change the duration of your sound by changing the release ti"
"me. Have a play adding release times to your music."
msgstr "これにより、リリース・フェーズを変更して、あなたのサウンドのデュレーションを変えることができます。自分の音楽にリリース・タイムを追加して演奏してみましょう。"

#: 02.4-Durations-with-Envelopes.md:91
msgid "Attack Phase"
msgstr "アタック・フェーズ"

#: 02.4-Durations-with-Envelopes.md:93
msgid ""
"By default, the *attack phase* is 0 for all synths which means they move from "
"0 amplitude to 1 immediately. This gives the synth an initial percussive sound"
". However, you may wish to fade your sound in. This can be achieved with the `"
"attack:` opt. Try fading in some sounds:"
msgstr ""
"通常、アタック・フェーズは全てのシンセにおいて`0`です。つまり、`0`アンプから`1`にただちに移動することを意味します。シンセは最初から音が打たれます。"
"けれども、あなたは音をフェード・イン（徐々に大きく）したいかも知れません。これは、`attack:`のオプションで実現することができます。いくつかの音をフェ"
"ード・インしてみましょう。"

#: 02.4-Durations-with-Envelopes.md:98
#, no-wrap
msgid ""
"play 60, attack: 2\n"
"sleep 3\n"
"play 65, attack: 0.5"
msgstr ""
"play 60, attack: 2\n"
"sleep 3\n"
"play 65, attack: 0.5"

#: 02.4-Durations-with-Envelopes.md:104
msgid ""
"You may use multiple opts at the same time. For example for a short attack and"
" a long release try:"
msgstr "複数のオプションを使うこともできます。例えば、短いアタック、長いリリースに、変更してみましょう。"

#: 02.4-Durations-with-Envelopes.md:107
#, no-wrap
msgid "play 60, attack: 0.7, release: 4"
msgstr "play 60, attack: 0.7, release: 4"

#: 02.4-Durations-with-Envelopes.md:111
msgid ""
"This short attack and long release envelope is illustrated in the following di"
"agram:"
msgstr "この、短いアタックに長いリリースのエンベロープは、以下の図のように表します。"

#: 02.4-Durations-with-Envelopes.md:114
#, fuzzy
msgid ""
"![attack release envelope](../../../etc/doc/images/tutorial/env-attack-release"
".png)"
msgstr ""
"![attack release envelope](../../../etc/doc/images/tutorial/env-attack-release"
".png)"

#: 02.4-Durations-with-Envelopes.md:116
msgid ""
"Of course, you may switch things around. Try a long attack and a short release"
":"
msgstr "もちろん、ほかに変更することもできます。長いアタックに短いリリースを試してみましょう。"

#: 02.4-Durations-with-Envelopes.md:119
#, no-wrap
msgid "play 60, attack: 4, release: 0.7"
msgstr "play 60, attack: 4, release: 0.7"

#: 02.4-Durations-with-Envelopes.md:123
#, fuzzy
msgid ""
"![long attack short release envelope](../../../etc/doc/images/tutorial/env-lon"
"g-attack-short-release.png)"
msgstr ""
"![long attack short release envelope](../../../etc/doc/images/tutorial/env-lon"
"g-attack-short-release.png)"

#: 02.4-Durations-with-Envelopes.md:125
msgid ""
"Finally, you can also have both short attack and release times for shorter sou"
"nds."
msgstr "そして、アタックとリリース両方短くして、短いサウンドにもできます。"

#: 02.4-Durations-with-Envelopes.md:128
#, no-wrap
msgid "play 60, attack: 0.5, release: 0.5"
msgstr "play 60, attack: 0.5, release: 0.5"

#: 02.4-Durations-with-Envelopes.md:132
#, fuzzy
msgid ""
"![short attack short release envelope](../../../etc/doc/images/tutorial/env-sh"
"ort-attack-short-release.png)"
msgstr ""
"![short attack short release envelope](../../../etc/doc/images/tutorial/env-sh"
"ort-attack-short-release.png)"

#: 02.4-Durations-with-Envelopes.md:134
msgid "Sustain Phase"
msgstr "サステイン・フェーズ（持続時間）"

#: 02.4-Durations-with-Envelopes.md:136
msgid ""
"In addition to specifying attack and release times, you may also specify a sus"
"tain time to control the *sustain phase*. This is the time for which the sound"
" is maintained at full amplitude between the attack and release phases."
msgstr ""
"アタック・フェーズとリリース・フェーズの設定に付け加えて、サステイン・フェーズ（持続時間）を指定することができます。サステイン・フェーズとは、アタックとリリ"
"ースの間でフル・アンプの音が鳴り続ける時間のことです。"

#: 02.4-Durations-with-Envelopes.md:141
#, no-wrap
msgid "play 60, attack: 0.3, sustain: 1, release: 1"
msgstr "play 60, attack: 0.3, sustain: 1, release: 1"

#: 02.4-Durations-with-Envelopes.md:145
#, fuzzy
msgid ""
"![ASR envelope](../../../etc/doc/images/tutorial/env-attack-sustain-release.pn"
"g)"
msgstr ""
"![ASR envelope](../../../etc/doc/images/tutorial/env-attack-sustain-release.pn"
"g)"

#: 02.4-Durations-with-Envelopes.md:147
msgid ""
"The sustain time is useful for important sounds you wish to give full presence"
" in the mix before entering an optional release phase. Of course, it's totally"
" valid to set both the `attack:` and `release:` opts to 0 and just use the sus"
"tain to have absolutely no fade in or fade out to the sound. However, be warne"
"d, a release of 0 can produce clicks in the audio and it's often better to use"
" a very small value such as 0.2."
msgstr ""
"サステイン・フェーズは、オプションのリリース・フェーズに入る前に、ミックスの中で主となる存在感を与えたい重要なサウンドにとって有効です。もちろん、`atta"
"ck:`と`release:`両方のオプションを0に設定することもとても有効ですし、サウンドに対して、完全にフェード・インなし、フェード・アウトなしにするた"
"めにサステインを使えば良いのです。けれど、注意してください、0のリリースはオーディオの中にクリック音を生成します。たいていの場合、0.2のようなごく小さい値"
"を使う方が良いです。"

#: 02.4-Durations-with-Envelopes.md:154
msgid "Decay Phase"
msgstr "ディケイ・フェーズ（減衰時間）"

#: 02.4-Durations-with-Envelopes.md:156
msgid ""
"For an extra level of control, you can also specify a decay time. This is a ph"
"ase of the envelope that fits between the attack and sustain phases and specif"
"ies a time where the amplitude will drop from the `attack_level:` to the `deca"
"y_level:` (which unless you explicitly set it will be set to the `sustain_leve"
"l:`). By default, the `decay:` opt is 0 and both the attack and sustain levels"
" are 1 so you'll need to specify them for the decay time to have any effect:"
msgstr ""
"そして、今あなたがさらなる制御のレベルを必要としているならば、ディケイ・タイムというものを設定することもできます。これは、アタックとサステインの間にくるエン"
"ベロープのフェーズで、音量が`attack_level:`から`decay_level:`（もしこれを明示的に指定しなければ、この値は`sustain_le"
"vel:`と同じ値に設定されます）に落ちる時間を指定します。通常では、`decay:`のオプションは0で、アタックとサステインのレベルは両方とも1です。です"
"から、ディケイ・フェーズで効果を得るには、アタック、サステインのレベルも指定しなくてはなりません。"

#: 02.4-Durations-with-Envelopes.md:164
#, no-wrap
msgid ""
"play 60, attack: 0.1, attack_level: 1, decay: 0.2, sustain_level: 0.4, sustain"
": 1, release: 0.5"
msgstr ""
"play 60, attack: 0.1, attack_level: 1, decay: 0.2, sustain_level: 0.4, sustain"
": 1, release: 0.5"

#: 02.4-Durations-with-Envelopes.md:168
#, fuzzy
msgid ""
"![ADSR envelope](../../../etc/doc/images/tutorial/env-attack-decay-sustain-rel"
"ease.png)"
msgstr ""
"![ADSR envelope](../../../etc/doc/images/tutorial/env-attack-decay-sustain-rel"
"ease.png)"

#: 02.4-Durations-with-Envelopes.md:170
msgid "Decay Level"
msgstr "ディケイレベル"

#: 02.4-Durations-with-Envelopes.md:172
msgid ""
"One last trick is that although the `decay_level:` opt defaults to be the same"
" value as `sustain_level:` you can explicitly set them to different values for"
" full control over the envelope. This allows you to to create envelopes such a"
"s the following:"
msgstr ""
"最後の仕掛けは、`decay_level:`オプションがデフォルトでは`sustain_level:`と同じ値に設定されていて、エンベロープを完全に制御した"
"い場合に明示的に別な値に設定できることです。これにより次のようなエンベロープを作ることができるでしょう。"

#: 02.4-Durations-with-Envelopes.md:177
#, no-wrap
msgid ""
"play 60, attack: 0.1, attack_level: 1, decay: 0.2, decay_level: 0.3, sustain: "
"1, sustain_level: 0.4, release: 0.5"
msgstr ""
"play 60, attack: 0.1, attack_level: 1, decay: 0.2, decay_level: 0.3, sustain: "
"1, sustain_level: 0.4, release: 0.5"

#: 02.4-Durations-with-Envelopes.md:181
#, fuzzy
msgid "![ASR envelope](../../../etc/doc/images/tutorial/env-decay-level.png)"
msgstr "![ASR envelope](../../../etc/doc/images/tutorial/env-decay-level.png)"

#: 02.4-Durations-with-Envelopes.md:183
msgid ""
"It's also possible to set the `decay_level:` to be higher than `sustain_level:"
"`:"
msgstr "また`decay_level:`を`sustain_level:`より大きく設定することもできます。"

#: 02.4-Durations-with-Envelopes.md:185
#, no-wrap
msgid ""
"play 60, attack: 0.1, attack_level: 0.1, decay: 0.2, decay_level: 1, sustain: "
"0.5, sustain_level: 0.8, release: 1.5"
msgstr ""
"play 60, attack: 0.1, attack_level: 0.1, decay: 0.2, decay_level: 1, sustain: "
"0.5, sustain_level: 0.8, release: 1.5"

#: 02.4-Durations-with-Envelopes.md:189
#, fuzzy
msgid "![ASR envelope](../../../etc/doc/images/tutorial/env-decay-level-2.png)"
msgstr "![ASR envelope](../../../etc/doc/images/tutorial/env-decay-level-2.png)"

#: 02.4-Durations-with-Envelopes.md:191
msgid "ADSR Envelopes"
msgstr "ADSR エンベロープ"

#: 02.4-Durations-with-Envelopes.md:193
msgid "So to summarise, Sonic Pi's ADSR envelopes have the following phases:"
msgstr "つまり要約すると、Sonic PiのADSRエンベロープには、以下のフェーズがあります。"

#: 02.4-Durations-with-Envelopes.md:195
msgid "*attack* - time from 0 amplitude to the `attack_level`,"
msgstr "*attack*（アタック）- 音量を0から`attack_level`まで移行させる時間"

#: 02.4-Durations-with-Envelopes.md:196
msgid "*decay* - time to move amplitude from `attack_level` to `decay_level`,"
msgstr "*decay*（ディケイ）- 音量を`attack_level`から`decay_level`まで移行させる時間"

#: 02.4-Durations-with-Envelopes.md:197
msgid "*sustain* - time to move the amplitude from `decay_level` to `sustain_level`,"
msgstr "*sustain*（サステイン）- 音量を`decay_level`から`sustain_level`まで移行させる時間"

#: 02.4-Durations-with-Envelopes.md:198
msgid "*release* - time to move amplitude from `sustain_level` to 0"
msgstr "*release*（リリース）- 音量を`sustain_level`から0に移行させる時間"

#: 02.4-Durations-with-Envelopes.md:200
msgid ""
"It's important to note that the duration of a sound is the summation of the ti"
"mes of each of these phases. Therefore the following sound will have a duratio"
"n of 0.5 + 1 + 2 + 0.5 = 4 beats:"
msgstr ""
"サウンドのデュレーションは、これらのフェーズの合計であることに注意することが大切です。したがって、以下のサウンドは、0.5 + 1 + 2 + 0.5 = "
"4 で、4秒のデュレーションになります。"

#: 02.4-Durations-with-Envelopes.md:204
#, no-wrap
msgid ""
"play 60, attack: 0.5, attack_level: 1, decay: 1, sustain_level: 0.4, sustain: "
"2, release: 0.5"
msgstr ""
"play 60, attack: 0.5, attack_level: 1, decay: 1, sustain_level: 0.4, sustain: "
"2, release: 0.5"

#: 02.4-Durations-with-Envelopes.md:208
msgid "Now go and have a play adding envelopes to your sounds..."
msgstr "ではあなたのサウンドにエンベロープを追加して演奏してみましょう。"

#: 03-Samples.md:1
msgid "3 Samples"
msgstr "3 サンプル"

#: 03-Samples.md:3
msgid "Samples"
msgstr "サンプル"

#: 03-Samples.md:5
msgid ""
"Another great way to develop your music is to use pre-recorded sounds. In grea"
"t hip-hop tradition, we call these pre-recorded sounds *samples*. So, if you t"
"ake a microphone outside, go and record the gentle sound of rain hitting canva"
"s, you've just created a sample."
msgstr ""
"あなたの音楽を発展させる方法は他にもあります。すでに録音された音を使うことです。偉大なヒップホップの伝統では、これらのあらかじめ録音された音のことを、*サン"
"プル*と呼びます。つまり、マイクを持って外に出て、雨が優しくキャンバスを打つ音を録音しに行けば、それだけでサンプルを作ることができます。"

#: 03-Samples.md:10
msgid ""
"Sonic Pi lets you do lots of fun things with samples. Not only does it ship wi"
"th 130 public domain samples ready for you to jam with, it lets you play and m"
"anipulate your own. Let's get to it..."
msgstr ""
"Sonic Piは、サンプルで楽しいことがたくさんできるようになっています。130以上のパブリック・ドメイン（著作権がない）サンプルが、ジャム（即興演奏）す"
"るために同梱されているだけでなく、あなたが持っているサンプルを操作して演奏することも可能です。さっそく見てみましょう…"

#: 03.1-Triggering-Samples.md:1
msgid "3.1 Triggering Samples"
msgstr "3.1 サンプルを使う"

#: 03.1-Triggering-Samples.md:3
msgid "Triggering Samples"
msgstr "サンプルを使う"

#: 03.1-Triggering-Samples.md:5
msgid ""
"Playing beeps is only the beginning. Something that's a lot of fun is triggeri"
"ng pre-recorded samples. Try it:"
msgstr "ビープ音を演奏するのは最初だけです。もっと面白いのは、録音済みのサンプルを使うことです。やってみましょう。"

#: 03.1-Triggering-Samples.md:8
#, no-wrap
msgid "sample :ambi_lunar_land"
msgstr "sample :ambi_lunar_land"

#: 03.1-Triggering-Samples.md:12
msgid ""
"Sonic Pi includes many samples for you to play with. You can use them just lik"
"e you use the `play` command. To play multiple samples and notes just write th"
"em one after another:"
msgstr ""
"Sonic Piは演奏のためにたくさんのサンプルを持っています。`play`コマンドを使うようにサンプルを使えばよいのです。複数のサンプルや音符を演奏するに"
"は、それらをひとつひとつ順番に書いていきます。"

#: 03.1-Triggering-Samples.md:16
#, no-wrap
msgid ""
"play 36\n"
"play 48\n"
"sample :ambi_lunar_land\n"
"sample :ambi_drone"
msgstr ""
"play 36\n"
"play 48\n"
"sample :ambi_lunar_land\n"
"sample :ambi_drone"

#: 03.1-Triggering-Samples.md:23
msgid "If you want to space them out in time, use the `sleep` command:"
msgstr "もし間を空けたいなら、`sleep`を使います。"

#: 03.1-Triggering-Samples.md:25
#, no-wrap
msgid ""
"sample :ambi_lunar_land\n"
"sleep 1\n"
"play 48\n"
"sleep 0.5\n"
"play 36\n"
"sample :ambi_drone\n"
"sleep 1\n"
"play 36"
msgstr ""
"sample :ambi_lunar_land\n"
"sleep 1\n"
"play 48\n"
"sleep 0.5\n"
"play 36\n"
"sample :ambi_drone\n"
"sleep 1\n"
"play 36"

#: 03.1-Triggering-Samples.md:36
#, fuzzy
msgid ""
"Notice how Sonic Pi doesn't wait for a sound to finish before starting the nex"
"t sound. The `sleep` command only describes the separation of the *triggering*"
" of the sounds. This allows you to easily layer sounds together creating inter"
"esting overlap effects."
msgstr ""
"最初のサウンドが終わる前に、次のサウンドが始まることに注意してください。`sleep`コマンドは、サウンドの開始の間隔だけを記述しています。これによって、簡"
"単にサウンドを重ね合わせて、おもしろいオーバー・ラップ（重複）のエフェクト（効果）を生み出すことができるのです。このチュートリアルの後半で、エンベロープでサ"
"ウンドの`duration`（長さ）を制御する方法についてみていきます。"

#: 03.1-Triggering-Samples.md:42
msgid "Discovering Samples"
msgstr "サンプルを探す"

#: 03.1-Triggering-Samples.md:44
#, fuzzy
msgid ""
"There are two ways to discover the range of samples provided in Sonic Pi. Firs"
"t, you can use this help system. Click on Samples in the menu at the bottom of"
" this help screen, choose your category and then you'll see a list of availabl"
"e sounds."
msgstr ""
"Sonic Piが収録しているサンプルの種類を知るには、2つの方法があります。1つ目は、このヘルプシステムを使うことです。下のメニューの中の`サンプル`をク"
"リックし、カテゴリを選ぶと、使用できるサウンドのリストが表示されます。"

#: 03.1-Triggering-Samples.md:49
msgid ""
"Alternatively you can use the *auto-completion system*. Simply type the start "
"of a sample group such as: `sample :ambi_` and you'll see a drop-down of sampl"
"e names appear for you to select. Try the following category prefixes:"
msgstr ""
"あるいは、オート・コンプリーション（自動補完）システムを使うこともできます。`sample :ambi_`のような複数のサンプルを束ねるグループ名をタイプし"
"始めると、同じグループ内から選択できるサンプルの名前がドロップ・ダウンして表れます。以下のサンプル・グループの接頭語を入力してみましょう。"

#: 03.1-Triggering-Samples.md:54
msgid "`:ambi_`"
msgstr "`:ambi_`"

#: 03.1-Triggering-Samples.md:55
msgid "`:bass_`"
msgstr "`:bass_`"

#: 03.1-Triggering-Samples.md:56
msgid "`:elec_`"
msgstr "`:elec_`"

#: 03.1-Triggering-Samples.md:57
msgid "`:perc_`"
msgstr "`:perc_`"

#: 03.1-Triggering-Samples.md:58
msgid "`:guit_`"
msgstr "`:guit_`"

#: 03.1-Triggering-Samples.md:59
msgid "`:drum_`"
msgstr "`:drum_`"

#: 03.1-Triggering-Samples.md:60
msgid "`:misc_`"
msgstr "`:misc_`"

#: 03.1-Triggering-Samples.md:61
msgid "`:bd_`"
msgstr "`:bd_`"

#: 03.1-Triggering-Samples.md:63
msgid "Now start mixing samples into your compositions!"
msgstr "さあ、あなたの曲でサンプルのミックスを始めてみましょう！"

#: 03.2-Sample-Params.md:1
msgid "3.2 Sample Parameters"
msgstr "3.2 サンプル・パラメータ"

#: 03.2-Sample-Params.md:3
msgid "Sample Parameters: Amp and Pan"
msgstr "サンプル・パラメータ：アンプとパン"

#: 03.2-Sample-Params.md:5
msgid ""
"As we saw with synths, we can easily control our sounds with parameters. Sampl"
"es support exactly the same parameterisation mechanism. Let's revisit our frie"
"nds `amp:` and `pan:`."
msgstr ""
"シンセの項目で見てきたように、パラメータで簡単にサウンドを制御することができます。サンプルは全く同じパラメータの仕組みを備えています。何度も登場する、`am"
"p:`と`pan:`をもう一度見てみましょう。"

#: 03.2-Sample-Params.md:9
msgid "Amping samples"
msgstr "サンプルの音量を変更する"

#: 03.2-Sample-Params.md:11
msgid ""
"You can change the amplitude of samples with exactly the same approach you use"
"d for synths:"
msgstr "シンセで使った書き方と全く同じ方法で、サンプルのアンプ（音量）を変えることができます。"

#: 03.2-Sample-Params.md:14
#, no-wrap
msgid "sample :ambi_lunar_land, amp: 0.5"
msgstr "sample :ambi_lunar_land, amp: 0.5"

#: 03.2-Sample-Params.md:18
msgid "Panning samples"
msgstr "サンプルをパンする"

#: 03.2-Sample-Params.md:20
msgid ""
"We're also able to use the `pan:` parameter on samples. For example, here's ho"
"w we'd play the amen break in the left ear and then half way through play it a"
"gain through the right ear:"
msgstr ""
"サンプルで`pan:`のパラメータを使うこともできます。例えば、次のコードは、定番のドラムフレーズのアーメン・ブレイクを左耳で再生し、半分まで来たところで再"
"度右耳で再生する方法です。"

#: 03.2-Sample-Params.md:24
#, no-wrap
msgid ""
"sample :loop_amen, pan: -1\n"
"sleep 0.877\n"
"sample :loop_amen, pan: 1"
msgstr ""
"sample :loop_amen, pan: -1\n"
"sleep 0.877\n"
"sample :loop_amen, pan: 1"

#: 03.2-Sample-Params.md:30
msgid "Note that 0.877 is half the duration of the `:loop_amen` sample in seconds."
msgstr "0.877は、`:loop_amen`サンプルの半分の再生時間であることに注意してください。"

#: 03.2-Sample-Params.md:33
msgid ""
"Finally, note that if you set some synth defaults with `use_synth_defaults` (w"
"hich we will discuss later), these will be ignored by `sample`."
msgstr "そして、`use_synth_defaults`（あとで説明します）をシンセに設定している場合、サンプルはこれを無視して再生します。"

#: 03.3-Stretching-Samples.md:1
msgid "3.3 Stretching Samples"
msgstr "3.3 サンプルを引き延ばす"

#: 03.3-Stretching-Samples.md:3
msgid "Stretching Samples"
msgstr "サンプルを引き延ばす"

#: 03.3-Stretching-Samples.md:5
msgid ""
"Now that we can play a variety of synths and samples to create some music, it'"
"s time to learn how to modify both the synths and samples to make the music ev"
"en more unique and interesting. First, let's explore the ability to *stretch* "
"and *squash* samples."
msgstr ""
"すでに私たちは、音楽を作るために様々なシンセやサンプルを演奏することができます。そろそろ、音楽をもっとユニークで面白くするために、シンセとサンプルを編集する"
"方法を学ぶ時間です。まずは、サンプルを引き延ばしたり圧縮する方法をみてみましょう。"

#: 03.3-Stretching-Samples.md:10
msgid "Sample Representation"
msgstr "サンプルで表現する"

#: 03.3-Stretching-Samples.md:12
msgid ""
"Samples are pre-recorded sounds stored as numbers which represent how to move "
"the speaker cone to reproduce the sound. The speaker cone can move in and out,"
" and so the numbers just need to represent how far in and out the cone needs t"
"o be for each moment in time. To be able to faithfully reproduce a recorded so"
"und the sample typically needs to store many thousands of numbers per second! "
"Sonic Pi takes this list of numbers and feeds them at the right speed to move "
"your computer's speaker in and out in just the right way to reproduce the soun"
"d. However, it's also fun to change the speed with which the numbers are fed t"
"o the speaker to change the sound."
msgstr ""
"サンプルとは、あらかじめ録音されたサウンドで、サウンドを再生するためにスピーカーのコーン（振動板）をどう動かすかを表す数値が格納されています。スピーカーのコ"
"ーンは行ったり来たり（振動）するため、数値は、その時々でコーンがどれくらいの距離を行ったり来たりすべきかをその時々で表す必要があります。録音された音を忠実に"
"再生するために、サンプルは概して1秒間に何千もの数値を格納しておく必要があるのです！ Sonic Piはこの数値のリストを使って、適切なスピードでサウンドを"
"再生するための正しい方法をあなたのコンピュータのスピーカーに伝え、振動させるのです。けれども、サウンドを変えるためにスピーカーに与えられる数値のスピードを変"
"えるのも楽しいですよ。"

#: 03.3-Stretching-Samples.md:23
msgid "Changing Rate"
msgstr "レートを変える"

#: 03.3-Stretching-Samples.md:25
msgid ""
"Let's play with one of the ambient sounds: `:ambi_choir`. To play it with the "
"default rate, you can pass a `rate:` opt to `sample`:"
msgstr ""
"アンビエント・サウンドのひとつ、`:ambi_choir`で演奏してみましょう。デフォルトのレートで演奏するには、`sample`に`rate:` のオプシ"
"ョンを渡します。"

#: 03.3-Stretching-Samples.md:28
#, no-wrap
msgid "sample :ambi_choir, rate: 1"
msgstr "sample :ambi_choir, rate: 1"

#: 03.3-Stretching-Samples.md:32
msgid ""
"This plays it at normal rate (1), so nothing special yet. However, we're free "
"to change that number to something else. How about `0.5`:"
msgstr "これはデフォルトのレート（1）で演奏するので、まだ何も変わったところはありません。ですが、数値を何か他の値に変えてもよいのです。`0.5`はどうでしょう。"

#: 03.3-Stretching-Samples.md:35
#, no-wrap
msgid "sample :ambi_choir, rate: 0.5"
msgstr "sample :ambi_choir, rate: 0.5"

#: 03.3-Stretching-Samples.md:39
msgid ""
"Woah! What's going on here? Well, two things. Firstly, the sample takes twice "
"as long to play, secondly the sound is an octave lower. Let's explore these th"
"ings in a little more detail."
msgstr ""
"ワオ！ 何が起きたのでしょう？ そう、2つのことが起こりました。1つ目は、サンプルは再生に2倍の時間をかけていました。2つ目は、サウンドは1オクターブ低くな"
"っていました。もう少し詳しく、これらのことを探ってみましょう。"

#: 03.3-Stretching-Samples.md:43
msgid "Let's stretch"
msgstr "引き延ばしてみる"

#: 03.3-Stretching-Samples.md:45
msgid ""
"A sample that's fun to stretch and compress is the Amen Break. At normal rate,"
" we might imagine throwing it into a *drum 'n' bass* track:"
msgstr ""
"引き延ばしたり圧縮したりして楽しいサンプルは、定番のアーメン・ブレイクです。通常のレートでは、*ドラムン・ベース（音楽ジャンルのひとつ）*のトラックを思わせ"
"ます。"

#: 03.3-Stretching-Samples.md:48 03.4-Enveloped-Samples.md:17
#: 03.5-Partial-Samples.md:9 A.03-coded-beats.md:33 A.12-sample-slicing.md:22
#: A.20-creative-coding-in-the-classroom.md:185
#, no-wrap
msgid "sample :loop_amen"
msgstr "sample :loop_amen"

#: 03.3-Stretching-Samples.md:52
msgid ""
"However by changing the rate we can switch up genres. Try half speed for *old "
"school hip-hop*:"
msgstr ""
":loop_amenですが、レート（速度）を変えると、音楽のジャンルが切り替わったように聞こえます。半分のスピードにすると、*オールドスクールのヒップホップ"
"*に。"

#: 03.3-Stretching-Samples.md:55 03.5-Partial-Samples.md:16
#: A.20-creative-coding-in-the-classroom.md:194
#, no-wrap
msgid "sample :loop_amen, rate: 0.5"
msgstr "sample :loop_amen, rate: 0.5"

#: 03.3-Stretching-Samples.md:59
msgid "If we speed it up, we enter *jungle* territory:"
msgstr "スピードを上げると、*ジャングル*のジャンルになりますね。"

#: 03.3-Stretching-Samples.md:61 A.17-sample-stretching.md:46
#, no-wrap
msgid "sample :loop_amen, rate: 1.5"
msgstr "sample :loop_amen, rate: 1.5"

#: 03.3-Stretching-Samples.md:65
msgid ""
"Now for our final party trick - let's see what happens if we use a negative ra"
"te:"
msgstr "では、パーティーの最後の仕掛けに、マイナスのレートを使うと何が起きるでしょうか。"

#: 03.3-Stretching-Samples.md:68
#, no-wrap
msgid "sample :loop_amen, rate: -1"
msgstr "sample :loop_amen, rate: -1"

#: 03.3-Stretching-Samples.md:72
msgid ""
"Woah! It plays it *backwards*! Now try playing with lots of different samples "
"at different rates. Try very fast rates. Try crazy slow rates. See what intere"
"sting sounds you can produce."
msgstr ""
"ワオ！ 逆再生！ いろいろな異なったサンプルで、異なったレートで演奏してみましょう。ものすごく速い数値や、おかしなくらいゆっくりになる数値を使って、どんなお"
"もしろいサウンドを作れるか、試してみましょう。"

#: 03.3-Stretching-Samples.md:76
msgid "A Simple Explanation of Sample Rate"
msgstr "サンプル・レートの解説"

#: 03.3-Stretching-Samples.md:78
msgid ""
"A useful way to think of samples is as springs. Playback rate is like squashin"
"g and stretching the spring. If you play the sample at rate 2, you're *squashi"
"ng the spring* to half its normal length. The sample therefore takes half the "
"amount of time to play as it's shorter. If you play the sample at half rate, y"
"ou're *stretching the spring* to double its length. The sample therefore takes"
" twice the amount of time to play as it's longer. The more you squash (higher "
"rate), the shorter it gets, the more you stretch (lower rate), the longer it g"
"ets."
msgstr ""
"サンプルは、バネのように考えると便利です。再生速度（プレイバック）は、バネを縮めたり伸ばしたりするようなものです。もしサンプルをレート 2 で再生した場合、"
"通常の長さの半分に、*バネを縮める*ことになります。ですので、サンプルは半分の時間で演奏するので、より短くなります。もしサンプルを半分のレートで再生した場合"
"、2倍の長さに*バネを伸ばす*ことになります。そのため、サンプルは再生に2倍の時間をかけるため、より長くなるのです。もっと縮める（レートを上げる）と、短く再"
"生され、さらに伸ばす（レートを下げる）と、さらに長く再生されます。"

#: 03.3-Stretching-Samples.md:87
msgid ""
"Compressing a spring increases its density (the number of coils per cm) - this"
" is similar to the sample sounding *higher pitched*. Stretching the spring dec"
"reases its density and is similar to the sound having a *lower pitch*."
msgstr ""
"バネを縮めることは、その密度（1cmあたりのコイルの数）を増やすことです。これは*高いピッチ（音程）*のサンプルに近づくことになります。バネを伸ばすことは、"
"密度を減らすことで、*低いピッチ（音程）*のサウンドに近づいていきます。"

#: 03.3-Stretching-Samples.md:93
msgid "The Maths Behind Sample Rate"
msgstr "サンプル・レートの背後にある計算"

#: 03.3-Stretching-Samples.md:95
msgid ""
"(This section is provided for those that are interested in the details. Please"
" feel free to skip it...)"
msgstr "（このセクションはさらに細かい部分に興味がある人向けです。飛ばしても構いませんよ…）"

#: 03.3-Stretching-Samples.md:98
msgid ""
"As we saw above, a sample is represented by a big long list of numbers represe"
"nting where the speaker should be through time. We can take this list of numbe"
"rs and use it to draw a graph which would look similar to this:"
msgstr ""
"上記で見てきたように、サンプルは、スピーカーが一定の時間でどのように振動すべきかを表現した長大な数値のリストによって表されています。この数値のリストで、これ"
"と同じようなグラフを描いてみます。"

#: 03.3-Stretching-Samples.md:103
#, fuzzy
msgid "![sample graph](../../../etc/doc/images/tutorial/sample.png)"
msgstr "![sample graph](../../../etc/doc/images/tutorial/sample.png)"

#: 03.3-Stretching-Samples.md:105
msgid ""
"You might have seen pictures like this before. It's called the *waveform* of a"
" sample. It's just a graph of numbers. Typically a waveform like this will hav"
"e 44100 points of data per second (this is due to the Nyquist-Shannon sampling"
" theorem). So, if the sample lasts for 2 seconds, the waveform will be represe"
"nted by 88200 numbers which we would feed to the speaker at a rate of 44100 po"
"ints per second. Of course, we could feed it at double rate which would be 882"
"00 points per second. This would therefore take only 1 second to play back. We"
" could also play it back at half rate which would be 22050 points per second t"
"aking 4 seconds to play back."
msgstr ""
"あなたはこれと同じような図を、以前に見たことがあるかも知れません。これはサンプルの*波形*と呼ばれるものです。これは数値のグラフです。このような波形はだいた"
"い、1秒間に44100ポイントのデータを有しています（これはナイキスト・シャノンのサンプリング定理によるものです）。サンプルが2秒間続くなら、スピーカーに1"
"秒間に44100ポイントのレート（長さ）を与えることで88200の数値で表現されます。もちろん、1秒間に88200ポイントで、2倍のレートとすることもできま"
"す。ですので、これは1秒間で再生されます。1秒間に22050ポイントで、半分のレートで再生することも可能です。この場合、4秒で再生されます。"

#: 03.3-Stretching-Samples.md:116
msgid "The duration of the sample is affected by the playback rate:"
msgstr "サンプルのデュレーションは、再生するレートの影響を受けます："

#: 03.3-Stretching-Samples.md:118
msgid "Doubling the playback rate halves the playback time,"
msgstr "2倍の再生レートは、再生時間を半分にする"

#: 03.3-Stretching-Samples.md:119
msgid "Halving the playback rate doubles the playback time,"
msgstr "半分の再生レートは、再生時間を2倍にする"

#: 03.3-Stretching-Samples.md:120
msgid "Using a playback rate of one fourth quadruples the playback time,"
msgstr "4分の1の再生レートは、再生時間を4倍にする"

#: 03.3-Stretching-Samples.md:121
msgid "Using a playback rate of 1/10 makes playback last 10 times longer."
msgstr "10分の1の再生レートは、10倍長く再生させる"

#: 03.3-Stretching-Samples.md:123
msgid "We can represent this with the formula:"
msgstr "これを以下の数式で表します。"

#: 03.3-Stretching-Samples.md:125
#, no-wrap
msgid "new_sample_duration = (1 / rate) * sample_duration "
msgstr "new_sample_duration = (1 / rate) * sample_duration "

#: 03.3-Stretching-Samples.md:129
msgid ""
"Changing the playback rate also affects the pitch of the sample. The frequency"
" or pitch of a waveform is determined by how fast it moves up and down. Our br"
"ains somehow turn fast movement of speakers into high notes and slow movement "
"of speakers into low notes. This is why you can sometimes even see a big bass "
"speaker move as it pumps out super low bass - it's actually moving a lot slowe"
"r in and out than a speaker producing higher notes."
msgstr ""
"再生レートを変えることは、サンプルのピッチ（音程）にも影響します。周波数や波形のピッチがどれくらい速く上下に動くかで決定されます。我々の脳は、どういうわけか"
"、スピーカーの速い動きを高い音階に、遅い動きを低い音階に捉えます。だからあなたは時々、大きなベース・スピーカーが超低音を吐き出すのを見ることができるのです。"
"実際に高い音を出しているときのスピーカーよりも、ゆっくりと振動しているのです。"

#: 03.3-Stretching-Samples.md:137
msgid ""
"If you take a waveform and squash it it will move up and down more times per s"
"econd. This will make it sound higher pitched. It turns out that doubling the "
"amount of up and down movements (oscillations) doubles the frequency. So, *pla"
"ying your sample at double rate will double the frequency you hear it*. Also, "
"*halving the rate will halve the frequency*. Other rates will affect the frequ"
"ency accordingly."
msgstr ""
"もし波形を取り出して圧縮したら、1秒間でさらに頻繁に上下します。これがサウンドをより高い音にするのです。上下の運動を2倍にすると、周波数が2倍になるというこ"
"とになります。そのため、*サンプルを2倍のレートで再生すると、聞こえる周波数が2倍になる*ということです。また、*レートを半分にすると、周波数が半分になる*"
"ということでもあります。他のレートはそれに応じて周波数に影響します。"

#: 03.4-Enveloped-Samples.md:1
msgid "3.4 Enveloped Samples"
msgstr "3.4 エンベロープ・サンプル"

#: 03.4-Enveloped-Samples.md:3
msgid "Enveloped Samples"
msgstr "エンベロープ・サンプル"

#: 03.4-Enveloped-Samples.md:5
msgid ""
"It is also possible to modify the *duration* and *amplitude* of a sample using"
" an ADSR envelope. However, this works slightly differently to the ADSR envelo"
"pe available on synths. Sample envelopes only allow you to reduce the amplitud"
"e and duration of a sample - and never to increase it. The sample will stop wh"
"en either the sample has finished playing or the envelope has completed - whic"
"hever is first. So, if you use a very long `release:`, it won't extend the dur"
"ation of the sample."
msgstr ""
"ADSRエンベロープを用いて、サンプルのデュレーション（再生時間）とアンプ（音量）を編集することもできます。しかしながら、シンセのADSRエンベロープとは少"
"しだけ異なったように作用します。サンプルに使用するエンベロープは、サンプルのアンプとデュレーションを減らすことしかできません。決して増やすことはできないので"
"す。サンプルは、それが再生され終わったときか、エンベロープが完了したときのいずれかで停止します。どちらが先でも停止します。非常に長い`release:`を使"
"ったとしても、サンプルのデュレーションは延長されません。"

#: 03.4-Enveloped-Samples.md:13
msgid "Amen Envelopes"
msgstr "アーメン・エンベロープ"

#: 03.4-Enveloped-Samples.md:15
msgid "Let's return to our trusty friend the Amen Break:"
msgstr "では、我々にはすっかりお馴染みのフレーズ、アーメン・ブレイクに戻りましょう："

#: 03.4-Enveloped-Samples.md:21
msgid ""
"With no opts, we hear the full sample at full amplitude. If we want to fade th"
"is in over 1 second we can use the `attack:` param:"
msgstr ""
"オプションが設定されていない場合、全サンプルがフル・アンプ（最大音量）で聞こえます。もし1秒間のフェード・インを使いたい場合、`attack:`パラメータを"
"使います（フェード・インとは徐々に音が大きくなることです）。"

#: 03.4-Enveloped-Samples.md:24
#, no-wrap
msgid "sample :loop_amen, attack: 1"
msgstr "sample :loop_amen, attack: 1"

#: 03.4-Enveloped-Samples.md:28
msgid "For a shorter fade in, choose a shorter attack value:"
msgstr "もっと短いフェード・インの場合は、`attack:`の値を小さくします。"

#: 03.4-Enveloped-Samples.md:30
#, no-wrap
msgid "sample :loop_amen, attack: 0.3"
msgstr "sample :loop_amen, attack: 0.3"

#: 03.4-Enveloped-Samples.md:34
msgid "Auto Sustain"
msgstr "オート・サステイン"

#: 03.4-Enveloped-Samples.md:36
msgid ""
"Where the ADSR envelope's behaviour differs from the standard synth envelope i"
"s in the *sustain* value. In the standard synth envelope, the sustain defaulte"
"d to 0 unless you set it manually. With samples, the sustain value defaults to"
" an *automagical* value - the time left to play the rest of the sample. This i"
"s why we hear the full sample when we pass no defaults. If the attack, decay, "
"sustain and release values were all 0 we'd never hear a peep. Sonic Pi therefo"
"re calculates how long the sample is, deducts any attack, decay and release ti"
"mes and uses the result as your sustain time. If the attack, decay and release"
" values add up to more than the duration of the sample, the sustain is simply "
"set to 0."
msgstr ""
"ADSR エンベロープの特徴が標準的なシンセ・エンベロープと異なる点は、*サステイン（持続時間）*の値です。標準的なシンセのエンベロープでは、もし手動で変更"
"しなければ、0に設定されています。ですが、サンプルでは、サステインの値は通常、*魔法のように全自動*にセットされます。サステインの時間は、サンプルの残りを演"
"奏するように調整されます。デフォルトの値を渡さないときに、サンプルがフルで流れるのはこのためです。アタック、ディケイ、サステイン、リリース（この4つの頭文字"
"がADSR）の値が全て0のときは、何の音も聞こえません。Sonic Piはサンプルの長さがどれくらいなのか計算し、アタック、ディケイ、リリース・タイムを差し"
"引いて、あなたのサステイン・タイムの結果を使用します。もし、アタック、ディケイ、リリースの値がサンプルのデュレーションより長く追加された場合、サステインは0"
"にセットされます。"

#: 03.4-Enveloped-Samples.md:48
msgid "Fade Outs"
msgstr "フェード・アウト"

#: 03.4-Enveloped-Samples.md:50
msgid ""
"To explore this, let's consider our Amen break in more detail. If we ask Sonic"
" Pi how long the sample is:"
msgstr ""
"これまでのことを探索するために、アーメン・ブレイクをさらに詳細に見てみましょう。アーメン・ブレイクのサンプルがどれくらいの長さなのか、Sonic Piに尋ね"
"てみてはどうでしょう："

#: 03.4-Enveloped-Samples.md:53
#, no-wrap
msgid "print sample_duration :loop_amen"
msgstr "print sample_duration :loop_amen"

#: 03.4-Enveloped-Samples.md:57
msgid ""
"It will print out `1.753310657596372` which is the length of the sample in sec"
"onds. Let's just round that to `1.75` for convenience here. Now, if we set the"
" release to `0.75`, something surprising will happen:"
msgstr ""
"1秒間のサンプルの長さは`1.753310657596372`と答えるでしょう。ここでは、便宜的に`1.75`としますリリース・タイムを`0.75`にすると"
"、驚くべきことが起こります。"

#: 03.4-Enveloped-Samples.md:61
#, no-wrap
msgid "sample :loop_amen, release: 0.75"
msgstr "sample :loop_amen, release: 0.75"

#: 03.4-Enveloped-Samples.md:65
msgid ""
"It will play the first second of the sample at full amplitude before then fadi"
"ng out over a period of 0.75 seconds. This is the *auto sustain* in action. By"
" default, the release always works from the end of the sample. If our sample w"
"as 10.75 seconds long, it would play the first 10 seconds at full amplitude be"
"fore fading out over 0.75s."
msgstr ""
"サンプルの最初の1秒をフル・アンプで再生し、最後の0.75秒はフェード・アウトします。これが*オート・サステイン*の動きです。標準では、`release:`"
"はいつもサンプルの最後から動作します。もしサンプルの長さが10.75秒なら、最初の10秒はフル・アンプで再生し、最後の0.75秒はフェード・アウトします。"

#: 03.4-Enveloped-Samples.md:71
msgid "Remember: by default, `release:` fades out at the end of a sample."
msgstr "通常、`release:`はサンプルの最後でフェード・アウトするということを覚えておいてください。"

#: 03.4-Enveloped-Samples.md:73
msgid "Fade In and Out"
msgstr "フェード・インとフェード・アウト"

#: 03.4-Enveloped-Samples.md:75
msgid ""
"We can use both `attack:` and `release:` together with the auto sustain behavi"
"our to fade both in and out over the duration of the sample:"
msgstr ""
"サンプルのデュレーションの間にフェード・アウトとインを行うには`attack:`と`release:`の両方を使うことができます。オート・サステインの仕組み"
"と一緒に、使用できます。"

#: 03.4-Enveloped-Samples.md:78
#, no-wrap
msgid "sample :loop_amen, attack: 0.75, release: 0.75"
msgstr "sample :loop_amen, attack: 0.75, release: 0.75"

#: 03.4-Enveloped-Samples.md:82
msgid ""
"As the full duration of the sample is 1.75s and our attack and release phases "
"add up to 1.5s, the sustain is automatically set to 0.25s. This allows us to e"
"asily fade the sample in and out."
msgstr ""
"サンプルのアーメン・ブレイク全体のデュレーションは1.75秒なので、アタックとリリースの時間が1.5秒まで追加されると、サステインは自動的に0.25秒にセッ"
"トされます。これで簡単にサンプルをフェード・イン、アウトすることができます。"

#: 03.4-Enveloped-Samples.md:86
msgid "Explicit sustain"
msgstr "サステインの明示的な指定"

#: 03.4-Enveloped-Samples.md:88
msgid ""
"We can easily get back to our normal synth ADSR behaviour by manually setting "
"`sustain:` to a value such as 0:"
msgstr "手動で`sustain:`を0などにセットして、通常のADSRシンセの挙動に簡単に戻すこともできます。"

#: 03.4-Enveloped-Samples.md:91
#, no-wrap
msgid "sample :loop_amen, sustain: 0, release: 0.75"
msgstr "sample :loop_amen, sustain: 0, release: 0.75"

#: 03.4-Enveloped-Samples.md:95
msgid ""
"Now, our sample only plays for 0.75 seconds in total. With the default for `at"
"tack:` and `decay:` at 0, the sample jumps straight to full amplitude, sustain"
"s there for 0s then releases back down to 0 amplitude over the release period "
"- 0.75s."
msgstr ""
"いま、サンプルはトータルで0.75秒間だけ再生されました。`attack:`と`decay:`のデフォルト値が0ですので、サンプルはフル・アンプ（最大音量）"
"に直接変わり、0秒間サステイン（持続）し、リリースの0.75秒間で0アンプに戻ります。"

#: 03.4-Enveloped-Samples.md:100
msgid "Percussive cymbals"
msgstr "打楽器のシンバル"

#: 03.4-Enveloped-Samples.md:102
msgid ""
"We can use this behaviour to good effect to turn longer sounding samples into "
"shorter, more percussive versions. Consider the sample `:drum_cymbal_open`:"
msgstr "この仕様を、長いサウンドのサンプルを短く、より打楽器的にするために、効果的に使うことができます。`:drum_cymbal_open`:"

#: 03.4-Enveloped-Samples.md:106
#, no-wrap
msgid "sample :drum_cymbal_open"
msgstr "sample :drum_cymbal_open"

#: 03.4-Enveloped-Samples.md:110
msgid ""
"You can hear the cymbal sound ringing out over a period of time. However, we c"
"an use our envelope to make it more percussive:"
msgstr "上のサンプルでは一定時間シンバルの音が鳴っているのが聞こえます。ですが、もっとパーカッシブ（打楽器的）にしてみましょう。"

#: 03.4-Enveloped-Samples.md:113
#, no-wrap
msgid "sample :drum_cymbal_open, attack: 0.01, sustain: 0, release: 0.1"
msgstr "sample :drum_cymbal_open, attack: 0.01, sustain: 0, release: 0.1"

#: 03.4-Enveloped-Samples.md:117
msgid ""
"You can then emulate hitting the cymbal and then dampening it by increasing th"
"e sustain period:"
msgstr "サステイン（持続時間）を増やすことで、シンバルを叩いた後の減衰の効果も出すことができます："

#: 03.4-Enveloped-Samples.md:120
#, no-wrap
msgid "sample :drum_cymbal_open, attack: 0.01, sustain: 0.3, release: 0.1"
msgstr "sample :drum_cymbal_open, attack: 0.01, sustain: 0.3, release: 0.1"

#: 03.4-Enveloped-Samples.md:124
msgid ""
"Now go and have fun putting envelopes over the samples. Try changing the rate "
"too for really interesting results."
msgstr "今すぐ、サンプルを楽しくさせるエンベロープをいじってみましょう。面白い結果を得るために数値を思いきり変更してみましょう。"

#: 03.5-Partial-Samples.md:1
msgid "3.5 Partial Samples"
msgstr "3.5 部分的なサンプル"

#: 03.5-Partial-Samples.md:3
msgid "Partial Samples"
msgstr "部分的なサンプル"

#: 03.5-Partial-Samples.md:5
msgid ""
"This section will conclude our exploration of Sonic Pi's sample player. Let's "
"do a quick recap. So far we've looked at how we can trigger samples:"
msgstr ""
"このセクションでは、Sonic Piのサンプルの再生について私たちが探求してきたことをまとめます。簡単にまとめてみましょう。これまで、サンプルを再生する方法"
"をみてきました。"

#: 03.5-Partial-Samples.md:13
msgid ""
"We then looked at how we can change the rate of samples such as playing them a"
"t half speed:"
msgstr "まず、サンプルのレート（速さ）を変更する方法を見つけて、このように半分の速度で再生してみました。"

#: 03.5-Partial-Samples.md:20
msgid "Next, we looked at how we could fade a sample in (let's do it at half speed):"
msgstr "次に、サンプルを徐々に大きくするフェードインを知りました（半分の速度でやってみましょう）。"

#: 03.5-Partial-Samples.md:23
#, no-wrap
msgid "sample :loop_amen, rate: 0.5, attack: 1"
msgstr "sample :loop_amen, rate: 0.5, attack: 1"

#: 03.5-Partial-Samples.md:27
msgid ""
"We also looked at how we could use the start of a sample percussively by givin"
"g `sustain:` an explicit value and setting both the attack and release to be s"
"hort values:"
msgstr "また、`sustain:`に明確な値とアタックとリリースの両方の短い値を設定することで、サンプルを打楽器のように使用する方法を見つけました。"

#: 03.5-Partial-Samples.md:31
#, no-wrap
msgid "sample :loop_amen, rate: 2, attack: 0.01, sustain: 0, release: 0.35"
msgstr "sample :loop_amen, rate: 2, attack: 0.01, sustain: 0, release: 0.35"

#: 03.5-Partial-Samples.md:35
msgid ""
"However, wouldn't it be nice if we didn't have to always start at the beginnin"
"g of the sample? Wouldn't it also be nice if we didn't have to always finish a"
"t the end of the sample?"
msgstr "では、いつもサンプルの先頭から開始する必要はあるのでしょうか？ そして、いつもサンプルの最後まで終了する必要はあるのでしょうか？"

#: 03.5-Partial-Samples.md:39
msgid "Choosing a starting point"
msgstr "開始点の選択"

#: 03.5-Partial-Samples.md:41
msgid ""
"It is possible to choose an arbitrary starting point in the sample as a value "
"between 0 and 1 where 0 is the start of the sample, 1 is the end and 0.5 is ha"
"lf way through the sample. Let's try playing only the last half of the amen br"
"eak:"
msgstr ""
"サンプルのどこからでも、好きな場所を選んで音を再生することが可能です。0はサンプルの開始で、1は終了です。0.5はサンプルの途中です。アーメン・ブレイクの最"
"後の半分を再生してみましょう。"

#: 03.5-Partial-Samples.md:46
#, no-wrap
msgid "sample :loop_amen, start: 0.5"
msgstr "sample :loop_amen, start: 0.5"

#: 03.5-Partial-Samples.md:50
msgid "How about the last quarter of the sample:"
msgstr "どのようにすればサンプルの最後の1/4を再生できますか？"

#: 03.5-Partial-Samples.md:52
#, no-wrap
msgid "sample :loop_amen, start: 0.75"
msgstr "sample :loop_amen, start: 0.75"

#: 03.5-Partial-Samples.md:56
msgid "Choosing a finish point"
msgstr "終了点を選択する"

#: 03.5-Partial-Samples.md:58
msgid ""
"Similarly, it is possible to choose an arbitrary finish point in the sample as"
" a value between 0 and 1. Let's finish the amen break half way through:"
msgstr "同様に、サンプルの0から1の間の値を終了点として選ぶことができます。アーメン・ブレイクの半分までで終わらせてみましょう。"

#: 03.5-Partial-Samples.md:62 A.12-sample-slicing.md:62
#, no-wrap
msgid "sample :loop_amen, finish: 0.5"
msgstr "sample :loop_amen, finish: 0.5"

#: 03.5-Partial-Samples.md:66
msgid "Specifying start and finish"
msgstr "開始と終了の指定"

#: 03.5-Partial-Samples.md:68
msgid ""
"Of course, we can combine these two to play arbitrary segments of the audio fi"
"le. How about only a small section in the middle:"
msgstr ""
"もちろん、私たちは好きな部分を再生するために、これまでの開始と終了の2つを組み合わせることができます。どのようにすれば真ん中あたりの短い場所だけを選べるので"
"しょうか？"

#: 03.5-Partial-Samples.md:71
#, no-wrap
msgid "sample :loop_amen, start: 0.4, finish: 0.6"
msgstr "sample :loop_amen, start: 0.4, finish: 0.6"

#: 03.5-Partial-Samples.md:75
msgid "What happens if we choose a start position after the finish position?"
msgstr "もし、終了位置のあとを、開始位置として選ぶとどうなるでしょう？"

#: 03.5-Partial-Samples.md:78
#, no-wrap
msgid "sample :loop_amen, start: 0.6, finish: 0.4"
msgstr "sample :loop_amen, start: 0.6, finish: 0.4"

#: 03.5-Partial-Samples.md:82
msgid "Cool! It plays it backwards!"
msgstr "かっこいい！ 逆再生になりますね！"

#: 03.5-Partial-Samples.md:84
msgid "Combining with rate"
msgstr "レートと組み合わせ"

#: 03.5-Partial-Samples.md:86
msgid ""
"We can combine this new ability to play arbitrary segments of audio with our f"
"riend `rate:`. For example, we can play a very small section of the middle of "
"the amen break very slowly:"
msgstr ""
"ここで紹介した部分再生の機能を、すでに学んだ`rate:`を組み合わせることができます。例えば、アーメン・ブレイクの真ん中のとても小さな部分をとてもゆっくり"
"と再生することができます："

#: 03.5-Partial-Samples.md:90
#, no-wrap
msgid "sample :loop_amen, start: 0.5, finish: 0.7, rate: 0.2"
msgstr "sample :loop_amen, start: 0.5, finish: 0.7, rate: 0.2"

#: 03.5-Partial-Samples.md:94
msgid "Combining with envelopes"
msgstr "エンベロープとの組み合わせ"

#: 03.5-Partial-Samples.md:96
msgid ""
"Finally, we can combine all of this with our ADSR envelopes to produce interes"
"ting results:"
msgstr "そして、面白い結果を創りだすために、ADSRエンベロープと、いままでの全てを組み合わせることができます。"

#: 03.5-Partial-Samples.md:99
#, no-wrap
msgid ""
"sample :loop_amen, start: 0.5, finish: 0.8, rate: -0.2, attack: 0.3, release: "
"1"
msgstr ""
"sample :loop_amen, start: 0.5, finish: 0.8, rate: -0.2, attack: 0.3, release: "
"1"

#: 03.5-Partial-Samples.md:103
msgid "Now go and have a play mashing up samples with all of this fun stuff..."
msgstr "今すぐ、サンプルとこれまでに紹介した楽しい内容を組み合わせて演奏してみましょう！"

#: 03.6-External-Samples.md:1
msgid "3.6 External Samples"
msgstr "3.6 外部サンプル"

#: 03.6-External-Samples.md:3
msgid "External Samples"
msgstr "外部サンプル"

#: 03.6-External-Samples.md:5
msgid ""
"Whilst the built-in samples can get you up and started quickly, you might wish"
" to experiment with other recorded sounds in your music. Sonic Pi totally supp"
"orts this. First though, let's have a quick discussion on the portability of y"
"our piece."
msgstr ""
"内蔵のサンプルは、すぐに使用でき、再生することができる一方で、あなたは自分で録音した音を試してみたいと思うかもしれません。Sonic Piはこれに完全に対応"
"しています。最初に、あなたの録音した音の携帯性について少し議論してみましょう。"

#: 03.6-External-Samples.md:10
msgid "Portability"
msgstr "携帯性"

#: 03.6-External-Samples.md:12
msgid ""
"When you compose your piece purely with built-in synths and samples, the code "
"is all you need to faithfully reproduce your music. Think about that for a mom"
"ent - that's amazing! A simple piece of text you can email around or stick in "
"a [Gist](https://gist.github.com) represents everything you need to reproduce "
"your sounds. That makes it *really easy to share* with your friends as they ju"
"st need to get hold of the code."
msgstr ""
"あなたが内蔵のシンセやサンプルだけを使って作曲した場合、音楽を忠実に再現するために必要なものは、コードだけになります。でもちょっと考えてみてください。それは"
"、実はとても凄いことなのですよね！ あなたの音楽を忠実に再現する作品は、テキストによるシンプルなものなので、電子メールで周りに送ったり、[Gist](htt"
"ps://gist.github.com)に埋め込んで公開することができます。コードを持っていれば友人と本当に簡単に共有することができます。"

#: 03.6-External-Samples.md:19
msgid ""
"However, if you start using your own pre-recorded samples, you lose this porta"
"bility. This is because to reproduce your music other people not only need you"
"r code, they need your samples too. This limits the ability for others to mani"
"pulate, mash-up and experiment with your work. Of course this shouldn't stop y"
"ou from using your own samples, it's just something to consider."
msgstr ""
"しかし、もしあなたが、自身で記録したサンプルを使ってしまうと、この携帯性が失われてしまいます。なぜならば、あなたの音楽を他の人達が再現しようとしても、あなた"
"のコードだけでは再生することができず、記録したサンプルが必要になってしまうからです。この事は、あなたの音楽を他の人が操作したり編集したり、試してみることを制"
"限してしまうことがあるということです。もちろん、あなた自身が録音したサンプルを使うことを止めるということではなく、方法（データを送って、正しく共有するなど）"
"に配慮していけばよいという事です。"

#: 03.6-External-Samples.md:26
msgid "Local Samples"
msgstr "自分で録音した（ローカルな）サンプル"

#: 03.6-External-Samples.md:28
#, fuzzy
msgid ""
"So how do you play any arbitrary WAV, AIFF, OGG, OGA or FLAC file on your comp"
"uter? All you need to do is pass the path of that file to `sample`:"
msgstr ""
"では、どうやって、あなたが録音したWAVファイルやAIFFファイルをコンピュータで再生するのでしょうか？ `sample`のファイルを置く場所を指定（パスを"
"通す）するだけで、再生できるようになります。"

#: 03.6-External-Samples.md:31
#, no-wrap
msgid ""
"# Raspberry Pi, Mac, Linux\n"
"sample \"/Users/sam/Desktop/my-sound.wav\"\n"
"# Windows\n"
"sample \"C:/Users/sam/Desktop/my-sound.wav\""
msgstr ""
"# Raspberry Pi, Mac, Linux\n"
"sample \"/Users/sam/Desktop/my-sound.wav\"\n"
"# Windows\n"
"sample \"C:/Users/sam/Desktop/my-sound.wav\""

#: 03.6-External-Samples.md:38
msgid ""
"Sonic Pi will automatically load and play the sample. You can also pass all th"
"e standard params you're used to passing `sample`:"
msgstr ""
"Sonic Piは自動的にサンプルを読み込んで再生します。あなたは、`sample`に今まで使ってきた全てのパラメータを、あなたが録音した音に使うことができ"
"ます。"

#: 03.6-External-Samples.md:41
#, no-wrap
msgid ""
"# Raspberry Pi, Mac, Linux\n"
"sample \"/Users/sam/Desktop/my-sound.wav\", rate: 0.5, amp: 0.3\n"
"# Windows\n"
"sample \"C:/Users/sam/Desktop/my-sound.wav\", rate: 0.5, amp: 0.3"
msgstr ""
"# Raspberry Pi, Mac, Linux\n"
"sample \"/Users/sam/Desktop/my-sound.wav\", rate: 0.5, amp: 0.3\n"
"# Windows\n"
"sample \"C:/Users/sam/Desktop/my-sound.wav\", rate: 0.5, amp: 0.3"

#: 03.7-Sample-Packs.md:1
msgid "3.7 Sample Packs"
msgstr "3.7 サンプルパック"

#: 03.7-Sample-Packs.md:3
msgid "Sample Packs"
msgstr "サンプルパック"

#: 03.7-Sample-Packs.md:5
msgid ""
"**Note: this section of the tutorial covers the advanced topic of working with"
" large directories of your own samples. This will be the case if you've downlo"
"aded or bought your own sample packs and wish to use them within Sonic Pi.**"
msgstr ""
"**注: このセクションは外部サンプルのある巨大なディレクトリを扱う際の高度なトピックを扱っています。あなたがサンプルパックをダウンロードしたり購入したりし"
"て、それをSonic Piから使いたい場合が当てはまるでしょう。**"

#: 03.7-Sample-Packs.md:10
msgid "**Feel free to skip this if you're happy working with the built-in samples.**"
msgstr "**内蔵サンプルで問題なければ、このセクションは飛ばしても構いませんよ。**"

#: 03.7-Sample-Packs.md:13
msgid ""
"When working with large folders of external samples it can be cumbersome to ha"
"ve to type the whole path every time to trigger an individual sample."
msgstr "外部サンプルのある大きなフォルダを扱う際に、個々のサンプルを再生する度にパス全体をタイプするのは、面倒かもしれません。"

#: 03.7-Sample-Packs.md:17
msgid "For example, say you have the following folder on your machine:"
msgstr "例えば、次のようなフォルダがあなたのマシンにあるとします。"

#: 03.7-Sample-Packs.md:19
#, no-wrap
msgid "/path/to/my/samples/"
msgstr "/path/to/my/samples/"

#: 03.7-Sample-Packs.md:23
msgid "When we look inside that folder we find the following samples:"
msgstr "そしてそのフォルダの中の次のようなサンプルがあるとします。"

#: 03.7-Sample-Packs.md:25 03.7-Sample-Packs.md:86
msgid "`100_A#_melody1.wav`"
msgstr "`100_A#_melody1.wav`"

#: 03.7-Sample-Packs.md:26 03.7-Sample-Packs.md:87
msgid "`100_A#_melody2.wav`"
msgstr "`100_A#_melody2.wav`"

#: 03.7-Sample-Packs.md:27 03.7-Sample-Packs.md:88
msgid "`100_A#_melody3.wav`"
msgstr "`100_A#_melody3.wav`"

#: 03.7-Sample-Packs.md:28 03.7-Sample-Packs.md:89
msgid "`120_A#_melody4.wav`"
msgstr "`120_A#_melody4.wav`"

#: 03.7-Sample-Packs.md:29 03.7-Sample-Packs.md:90
msgid "`120_Bb_guit1.wav`"
msgstr "`120_Bb_guit1.wav`"

#: 03.7-Sample-Packs.md:30 03.7-Sample-Packs.md:91
msgid "`120_Bb_piano1.wav`"
msgstr "`120_Bb_piano1.wav`"

#: 03.7-Sample-Packs.md:32
msgid "Typically in order to play the piano sample we can use the full path:"
msgstr "例えばピアノのサンプルを再生したい場合、次のようなフルパスでの指定が可能です。"

#: 03.7-Sample-Packs.md:34
#, no-wrap
msgid "sample \"/path/to/my/samples/120_Bb_piano1.wav\""
msgstr "sample \"/path/to/my/samples/120_Bb_piano1.wav\""

#: 03.7-Sample-Packs.md:38
msgid "If we want to then play the guitar sample we can use its full path too:"
msgstr "次にギターのサンプルを再生したい場合、また同じようにフルパスでの指定が可能です。"

#: 03.7-Sample-Packs.md:40
#, no-wrap
msgid "sample \"/path/to/my/samples/120_Bb_guit.wav\""
msgstr "sample \"/path/to/my/samples/120_Bb_guit.wav\""

#: 03.7-Sample-Packs.md:44
msgid ""
"However, both of these calls to sample requires us to *know* the names of the "
"samples within our directory. What if we just want to listen to each sample in"
" turn quickly?"
msgstr ""
"しかしながら、これらのどちらのサンプルの呼び出しでも、ディレクトリ内のファイル名を知っている必要があります。もしサンプルを順番に聴いて行きたい場合どうしたら"
"良いでしょう？"

#: 03.7-Sample-Packs.md:48
msgid "Indexing Sample Packs"
msgstr "サンプルパックのインデックス"

#: 03.7-Sample-Packs.md:50
msgid ""
"If we want to play the first sample in a directory we just need to pass the di"
"rectory's name to `sample` and the index `0` as follows:"
msgstr "もしディレクトリの1番目のサンプルを再生したい場合、必要なことは次のように`sample`にディレクトリ名と'0'のインデックスを渡すだけです。"

#: 03.7-Sample-Packs.md:53
#, no-wrap
msgid "sample \"/path/to/my/samples/\", 0"
msgstr "sample \"/path/to/my/samples/\", 0"

#: 03.7-Sample-Packs.md:57
msgid "We can even make a shortcut to our directory path using a variable:"
msgstr "さらにディレクトリ名は変数を使ってショートカットを作ることも可能です。"

#: 03.7-Sample-Packs.md:59
#, no-wrap
msgid ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, 0"
msgstr ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, 0"

#: 03.7-Sample-Packs.md:64
msgid ""
"Now, if we want to play the second sample in our directory, we just need to ad"
"d 1 to our index:"
msgstr "次に、ディレクトリの2番目のサンプルを再生したい場合、先ほどのインデックスに1を追加すれば出来ます。"

#: 03.7-Sample-Packs.md:67
#, no-wrap
msgid ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, 1"
msgstr ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, 1"

#: 03.7-Sample-Packs.md:72
msgid ""
"Notice that we no longer need to know the names of the samples in the director"
"y - we just need to know the directory itself (or have a shortcut to it). If w"
"e ask for an index which is larger than the number of samples, it simply wraps"
" round just like Rings. Therefore, whatever number we use we're guaranteed to "
"get one of the samples in that directory."
msgstr ""
"もはやディレクトリ内のサンプルの名前を知る必要がないことに注意してください。必要なのはディレクトリそのもの（もしくはそのショートカット）を知っていることです"
"。もしディレクトリ内のサンプルの数より大きい値をインデックスに指定した場合、リングのように単純に先頭に戻ります。したがって、どのような数字もディレクトリ内の"
"どれかのサンプルを取得することが保証されているのです。"

#: 03.7-Sample-Packs.md:79
msgid "Filtering Sample Packs"
msgstr "サンプルパックのフィルタ"

#: 03.7-Sample-Packs.md:81
msgid ""
"Usually indexing is enough, but sometimes we need more power to sort and organ"
"ise our samples. Luckily many sample packs add useful information in the filen"
"ames. Let's take another look at the sample file names in our directory:"
msgstr ""
"インデックスは機能的には十分かもしれませんが、サンプルを分類するもっと強力な方法が必要になるかもしれません。幸いにして、いくつかのサンプルパックではファイル"
"名に意味のある情報を付加してくれています。ディレクトリ内のファイル名を別な観点から見てみましょう。"

#: 03.7-Sample-Packs.md:93
msgid ""
"Notice that in these filenames we have quite a bit of information. Firstly, we"
" have the BPM of the sample (beats per minute) at the start. So, the piano sam"
"ple is at 120 BPM and our first three melodies are at 100 BPM. Also, our sampl"
"e names contain the key. So the guitar sample is in Bb and the melodies are in"
" A#. This information is very useful for mixing in these samples with our othe"
"r code. For example, we know we can only play the piano sample with code that'"
"s in 120 BPM and in the key of Bb."
msgstr ""
"これらのファイル名はかなりの情報を持っていることに注目してください。最初にサンプルのBPM（beats per minute）があります。ピアノのサンプルは"
"BPMが120で最初の3つのメロディーはBPMが100であることが分かると思います。また、サンプルのファイル名はキーを含んでいます。ギターのサンプルはキーが"
"BbでメロディーのキーはA#です。この情報は我々の他のコードと組み合わせるのにとても役立ちます。例えば、ピアノのサンプルをBPM120でBbのキーのソースコ"
"ードとしか使えないことが分かると思います。"

#: 03.7-Sample-Packs.md:102
msgid ""
"It turns out that we can use this particular naming convention of our sample s"
"ets in the code to help us filter out the ones we want. For example, if we're "
"working at 120 BPM, we can filter down to all the samples that contain the str"
"ing `\"120\"` with the following:"
msgstr ""
"サンプルの特定の命名規則を使って、我々が必要とするファイルをフィルタできることが分かりました。例えば、BPM120で演奏している場合に、`\"120\"`という"
"文字列を含む全てのサンプルを次のようにフィルタできます。"

#: 03.7-Sample-Packs.md:107
#, no-wrap
msgid ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, \"120\""
msgstr ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, \"120\""

#: 03.7-Sample-Packs.md:112
msgid ""
"This will play us the first match. If we want the second match we just need to"
" use the index:"
msgstr "これは最初にマッチしたものを再生します。もし2番目にマッチしたものを再生したい場合には、インデックスを使用します。"

#: 03.7-Sample-Packs.md:115
#, no-wrap
msgid ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, \"120\", 1"
msgstr ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, \"120\", 1"

#: 03.7-Sample-Packs.md:120
#, fuzzy
msgid ""
"We can even use multiple filters at the same time. For example, if we want a s"
"ample whose filename contains both the substrings `\"120\"` and `\"A#\"` we can fi"
"nd it easily with the following code:"
msgstr "さらに複数のフィルタを使うこともできます。例えば、\"120\"と\"A#\"をファイル名に含むサンプルが必要な場合、次のような簡単なコードで実現できます。"

#: 03.7-Sample-Packs.md:124
#, no-wrap
msgid ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, \"120\", \"A#\""
msgstr ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, \"120\", \"A#\""

#: 03.7-Sample-Packs.md:129
msgid "Finally, we're still free to add our usual opts to the call to `sample`:"
msgstr "最後に、フィルタを使用した場合にも`sample`で通常使用されるオプションをそのまま自由に追加できます。"

#: 03.7-Sample-Packs.md:131
#, no-wrap
msgid ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, \"120\", \"Bb\", 1, lpf: 70, amp: 2"
msgstr ""
"samps = \"/path/to/my/samples/\"\n"
"sample samps, \"120\", \"Bb\", 1, lpf: 70, amp: 2"

#: 03.7-Sample-Packs.md:136
msgid "Sources"
msgstr "ソース"

#: 03.7-Sample-Packs.md:138
#, fuzzy
msgid ""
"The sample filter pre-arg system understands two types of information: *source"
"s* and *filters*. Sources are information used to create the list of potential"
" candidates. A source can take two forms:"
msgstr ""
"サンプルフィルタの引数前の処理システムは、ソースとフィルタという2つタイプの情報を認識します。ソースは、候補となる可能性のあるサンプルのリストを作成するのに"
"使われる情報です。ソースは次の2つの形式を取ることができます。"

#: 03.7-Sample-Packs.md:142
#, fuzzy
msgid "`\"/path/to/samples\"` - a string representing a valid path to a directory"
msgstr "\"/path/to/samples\" - 有効なディレクトリを表す文字列"

#: 03.7-Sample-Packs.md:143
#, fuzzy
msgid "`\"/path/to/samples/foo.wav\"` - a string representing a valid path to a sample"
msgstr "\"/path/to/samples/foo.wav\" - サンプルへの有効なパスを表す文字列"

#: 03.7-Sample-Packs.md:145
msgid ""
"The `sample` fn will first gather all sources and use them to create a large l"
"ist of candidates. This list is constructed by first adding all valid paths an"
"d then by adding all the valid `.flac`, `.aif`, `.aiff`, `.wav`, `.wave` files"
" contained within the directories."
msgstr ""
"`sample`関数は、最初に全てのソースを集めてサンプルの候補の巨大なリストを作成します。このリストは最初に全ての有効なパスを追加した後、次にディレクトリ"
"内にある全ての有効な`.flac`, `.aif`, `.aiff`, `.wav`, `.wave`ファイルを追加します。"

#: 03.7-Sample-Packs.md:150
msgid "For example, take a look at the following code:"
msgstr "例として、次のコードを見てください。"

#: 03.7-Sample-Packs.md:152
#, no-wrap
msgid ""
"samps = \"/path/to/my/samples/\"\n"
"samps2 = \"/path/to/my/samples2/\"\n"
"path = \"/path/to/my/samples3/foo.wav\"\n"
"sample samps, samps2, path, 0"
msgstr ""
"samps = \"/path/to/my/samples/\"\n"
"samps2 = \"/path/to/my/samples2/\"\n"
"path = \"/path/to/my/samples3/foo.wav\"\n"
"sample samps, samps2, path, 0"

#: 03.7-Sample-Packs.md:160
msgid ""
"Here, we're combining the contents of the samples within two directories and a"
"dding a specific sample. If `\"/path/to/my/samples/\"` contained 3 samples and `"
"\"/path/to/my/samples2/\"` contained 12, we'd have 16 potential samples to index"
" and filter (3 + 12 + 1)."
msgstr ""
"ここでは、2つのディレクトリの内容と1つの特定のサンプルを組み合わせています。もし`\"/path/to/my/samples/\"`に3つのサンプルがあり、`"
"\"/path/to/my/samples2/\"`に12個のサンプルがあるとすると、インデックスやフィルタ可能となるサンプルは16(3 + 12 + 1)にな"
"ります。"

#: 03.7-Sample-Packs.md:165
msgid ""
"By default, only the sample files within a directory are gathered into the can"
"didate list. Sometimes you might have a number of nested folders of samples yo"
"u wish to search and filter within. You can therefore do a recursive search fo"
"r all samples within all subfolders of a particular folder by adding `**` to t"
"he end of the path:"
msgstr ""
"デフォルトでは、ディレクトリ内のサンプルファイルのみが候補リストに集められますが、ときにはネストした数多くのフォルダ内のサンプルを検索したりフィルタしたりし"
"たいことがあるかもしれません。その場合には、次のように`**`をパスの最後に付けることで、全てのサブディレクトリ内のサンプルを再帰的に検索することができます"
"。"

#: 03.7-Sample-Packs.md:171
#, no-wrap
msgid ""
"samps = \"/path/to/nested/samples/**\"\n"
"sample samps, 0"
msgstr ""
"samps = \"/path/to/nested/samples/**\"\n"
"sample samps, 0"

#: 03.7-Sample-Packs.md:176
msgid ""
"Take care though as searching through a very large set of folders may take a l"
"ong time. However, the contents of all folder sources are cached, so the delay"
" will only happen the first time."
msgstr ""
"とても大きなフォルダのセットを検索するのは、長い時間が掛かるかもしれないことに気をつけてください。しかし、フォルダーのソースの内容は全てキャッシュされるので"
"、この遅延は一度目しか発生しません。"

#: 03.7-Sample-Packs.md:180
msgid ""
"Finally, note that the sources *must go first*. If no source is given, then th"
"e set of built-in samples will be selected as the default list of candidates t"
"o work with."
msgstr "最後に、ソースの指定は「必ず先頭に」付けるようにしてください。もし何もソースが指定されない場合、内蔵サンプルのセットが候補リストして選択されます。"

#: 03.7-Sample-Packs.md:184 A.19-subtractive-synthesis.md:47
msgid "Filters"
msgstr "フィルタ"

#: 03.7-Sample-Packs.md:186
msgid ""
"Once you have a list of candidates you may use the following filtering types t"
"o further reduce the selection:"
msgstr "候補リストを取得した後、選択肢を減らすために次のようなフィルタのタイプを使うことができます。"

#: 03.7-Sample-Packs.md:189
msgid ""
"`\"foo\"` Strings will filter on substring occurrence within file name (minus di"
"rectory path and extension)."
msgstr "`\"foo\"`という文字列は、（ディレクトリパスと拡張子を除いた）ファイル名の部分一致を抽出します。"

#: 03.7-Sample-Packs.md:190
msgid ""
"`/fo[oO]/` Regular Expressions will filter on pattern matching of file name (m"
"inus directory path and extension)."
msgstr "`/fo[oO]/`という正規表現は、（ディレクトリパスと拡張子を除いた）ファイル名のパターンマッチを抽出します。"

#: 03.7-Sample-Packs.md:191
msgid ""
"`:foo` - Keywords will filter candidates on whether the keyword is a direct ma"
"tch of the filename (minus directory path and extension)."
msgstr "`:foo`というキーワードは、（ディレクトリパスと拡張子を除いた）ファイル名の完全一致を抽出します。"

#: 03.7-Sample-Packs.md:192
msgid ""
"`lambda{|a| ... }` - Procs with one argument will be treated as a candidate fi"
"lter or generator function. It will be passed the list of current candidates a"
"nd must return a new list of candidates (a list of valid paths to sample files"
")."
msgstr ""
"`lambda{|a| ... }`という1つの引数を伴ったProc（手続きオブジェクト）は、候補リストのフィルタまたは生成する関数として扱われます。この関"
"数は、現在の候補リストが引数として渡され、新しい候補リスト（サンプルの有効なパスのリスト）を返却する必要があります。"

#: 03.7-Sample-Packs.md:193
msgid ""
"`1` - Numbers will select the candidate with that index (wrapping round like a"
" ring if necessary)."
msgstr "`1`のような数値は、インデックス（必要があればリングのように先頭に戻る）で、候補から選択します。"

#: 03.7-Sample-Packs.md:195
msgid ""
"For example, we can filter over all the samples in a directory containing the "
"string `\"foo\"` and play the first matching sample at half speed:"
msgstr "例として、あるディレクトリから`\"foo\"`の文字列を含むサンプルを抽出し、そのうちの最初のものを半分のレートで再生するには、次のように書きます。"

#: 03.7-Sample-Packs.md:199
#, no-wrap
msgid "sample \"/path/to/samples\", \"foo\", rate: 0.5"
msgstr "sample \"/path/to/samples\", \"foo\", rate: 0.5"

#: 03.7-Sample-Packs.md:203
msgid ""
"See the help for `sample` for many detailed usage examples. Note that the orde"
"ring of the filters is honoured."
msgstr "詳細な使用例は`sample`のヘルプを参照してください。また、フィルタの順序が尊重されることに注意してください。"

#: 03.7-Sample-Packs.md:206
msgid "Composites"
msgstr "複合"

#: 03.7-Sample-Packs.md:208
msgid ""
"Finally, you may use lists wherever you may place a source or filter. The list"
" will be automatically flattened and the contents will be treated as regular s"
"ources and filters. Therefore the following calls to `sample` are semantically"
" equivalent:"
msgstr ""
"最後に、ソースまたはフィルタを配置することが可能な位置であればどこでもリストを使用することができます。リストは自動的に平坦化され、正規のソースとフィルタとし"
"て扱われます。したがって、次に示す`sample`の呼び出しは意味的には全て同じものになります。"

#: 03.7-Sample-Packs.md:213
#, no-wrap
msgid ""
"sample \"/path/to/dir\", \"100\", \"C#\"\n"
"sample [\"/path/to/dir\", \"100\", \"C#\"]\n"
"sample \"/path/to/dir\", [\"100\", \"C#\"]\n"
"sample [\"/path/to/dir\", [\"100\", [\"C#\"]]]"
msgstr ""
"sample \"/path/to/dir\", \"100\", \"C#\"\n"
"sample [\"/path/to/dir\", \"100\", \"C#\"]\n"
"sample \"/path/to/dir\", [\"100\", \"C#\"]\n"
"sample [\"/path/to/dir\", [\"100\", [\"C#\"]]]"

#: 03.7-Sample-Packs.md:220
msgid "Wrapping Up"
msgstr "まとめ"

#: 03.7-Sample-Packs.md:222
msgid ""
"This was an advanced section for people that need real power to manipulate and"
" use sample packs. If most of this section didn't make too much sense, don't w"
"orry. It's likely you don't need any of this functionality just yet. However, "
"you'll know when you do need it and you can come back and re-read this when yo"
"u start working with large directories of samples."
msgstr ""
"このセクションでは、サンプルパックを操作・使用する強力な方法を必要とする人のための高度な内容を紹介しました。このセクションの大部分があまり意味があるように思"
"えなかったとしても心配しないでください。それは、これらの機能のどれもまだあなたが必要としていないというだけだと思います。しかし、サンプルの巨大なディレクトリ"
"を扱うことになり、これらの機能が必要なことが分かったときに、またこのセクションに戻って読み直すことができるでしょう。"

#: 04-Randomisation.md:1
msgid "4 Randomisation"
msgstr "4 ランダム化"

#: 04-Randomisation.md:3
msgid "Randomisation"
msgstr "ランダム化"

#: 04-Randomisation.md:5
msgid ""
"A great way to add some interest into your music is using some random numbers."
" Sonic Pi has some great functionality for adding randomness to your music, bu"
"t before we start we need to learn a shocking truth: in Sonic Pi *random is no"
"t truly random*. What on earth does this mean? Well, let's see."
msgstr ""
"音楽にすこし面白さを加えるために、ランダムという素晴らしい方法があります。Sonic Piは音楽にランダム性を追加するためにいくつかの素晴らしい機能を持って"
"いますが、Sonic Piのランダムは、真のランダムではありません。これは一体何を意味しているのでしょう？ 勉強を開始する前に、この衝撃的な真実を見ていきま"
"しょう。"

#: 04-Randomisation.md:11
msgid "Repeatability"
msgstr "再現性"

#: 04-Randomisation.md:13
msgid ""
"A really useful random function is `rrand` which will give you a random value "
"between two numbers - a *min* and a *max*. (`rrand` is short for ranged random"
"). Let's try playing a random note:"
msgstr ""
"たいへん便利なランダム関数に、2つの数字の間（最小値と最大値）で乱数（ランダムな値）が得られる`rrand`があります（rrandはレンジド・ランダムの略で"
"す）。ランダムな音階を演奏してみましょう。"

#: 04-Randomisation.md:17
#, no-wrap
msgid "play rrand(50, 95)"
msgstr "play rrand(50, 95)"

#: 04-Randomisation.md:21
msgid ""
"Ooh, it played a random note. It played note `83.7527`. A nice random note bet"
"ween 50 and 95. Woah, wait, did I just predict the exact random note you got t"
"oo? Something fishy is going on here. Try running the code again. What? It cho"
"se `83.7527` again? That can't be random!"
msgstr ""
"おぉー、ランダムな音符を演奏しましたね。これは、`83.7527`の音符を演奏しました。50と95との間のランダムな音符でしたね。でも、ちょっと待ってくださ"
"い、上記で、私はあなたが再生したランダムな音符を正確に予測していませんか？ 何か怪しくないですか？ 再度コードを実行してみてください。ランダムのはずが、再び"
"`83.7527`が選ばれましたよね？ 実は、ランダムにすることができないのです！"

#: 04-Randomisation.md:26
msgid ""
"The answer is that it is not truly random, it's pseudo-random. Sonic Pi will g"
"ive you random-like numbers in a repeatable manner. This is very useful for en"
"suring that the music you create on your machine sounds identical on everybody"
" else's machine - even if you use some randomness in your composition."
msgstr ""
"答えは、それが真のランダムではなく、擬似ランダムであるということです。Sonic Piは、再現可能なランダム風の数を用意しています。これは、あなたのマシンで"
"作成した音楽が、たとえその中でいくつかランダム性を使用している場合でも、誰か他の人のマシンで同じように聞こえることを保証するのに大変便利な機能です。"

#: 04-Randomisation.md:32
msgid ""
"Of course, in a given piece of music, if it 'randomly' chose `83.7527` every t"
"ime, then it wouldn't be very interesting. However, it doesn't. Try the follow"
"ing:"
msgstr ""
"もちろん、ある音楽作品において、もし`83.7527`が「ランダムに」毎回選択された場合、それは非常に面白くありません。しかし、そうにはなっていません。以下"
"のことを試してみてください。"

#: 04-Randomisation.md:36
#, no-wrap
msgid ""
"loop do\n"
"  play rrand(50, 95)\n"
"  sleep 0.5\n"
"end "
msgstr ""
"loop do\n"
"  play rrand(50, 95)\n"
"  sleep 0.5\n"
"end "

#: 04-Randomisation.md:43
msgid ""
"Yes! It finally sounds random. Within a given *run* subsequent calls to random"
" functions will return random values. However, the next run will produce exact"
"ly the same sequence of random values and sound exactly the same. It's as if a"
"ll Sonic Pi code went back in time to exactly the same point every time the Ru"
"n button was pressed. It's the Groundhog Day of music synthesis!"
msgstr ""
"そう！ 最終的には、ランダムに聞こえますね。ランダム関数へ続いて呼び出されるその後の実行結果はランダムな値を返します。ただし、また再生する場合は正確に乱数値"
"の同じシーケンスを生成し、まったく同じ音が鳴ります。Runボタンが押されるたびに、まるですべてのSonic Piコードが毎回、同じ時間に戻るかように蘇ります"
"。それはまさに映画「恋はデジャ・ブ」のようにシンセの音が繰り返されるのです！"

#: 04-Randomisation.md:50
msgid "Haunted Bells"
msgstr "ホーンテッド・ベル"

#: 04-Randomisation.md:52
msgid ""
"A lovely illustration of randomisation in action is the haunted bells example "
"which loops the `:perc_bell` sample with a random rate and sleep time between "
"bell sounds:"
msgstr ""
"ランダム動作を取り入れたゾクッとするようなベルの音を使った楽しい作例です。繰り返しサンプルのベル音:perc_bellをループさせ、ベル音の再生速度と音の間"
"のsleepにランダムな数値を用いています。"

#: 04-Randomisation.md:56
#, no-wrap
#, fuzzy
msgid ""
"loop do\n"
"  sample :perc_bell, rate: rrand(0.125, 1.5)\n"
"  sleep rrand(0.2, 2)\n"
"end"
msgstr ""
"loop do\n"
"  sample :perc_bell, rate: (rrand 0.125, 1.5)\n"
"  sleep rrand(0.2, 2)\n"
"end"

#: 04-Randomisation.md:63
msgid "Random cutoff"
msgstr "ランダムなカットオフ"

#: 04-Randomisation.md:65
msgid ""
"Another fun example of randomisation is to modify the cutoff of a synth random"
"ly. A great synth to try this out on is the `:tb303` emulator:"
msgstr "ランダム化のもう1つの楽しみ方の例は、ランダムにシンセのカットオフを加えることです。これを試してみるのに絶好のシンセは、:tb303 エミュレータです。"

#: 04-Randomisation.md:69
#, no-wrap
msgid ""
"use_synth :tb303\n"
"loop do\n"
"  play 50, release: 0.1, cutoff: rrand(60, 120)\n"
"  sleep 0.125\n"
"end"
msgstr ""
"use_synth :tb303\n"
"loop do\n"
"  play 50, release: 0.1, cutoff: rrand(60, 120)\n"
"  sleep 0.125\n"
"end"

#: 04-Randomisation.md:78
msgid "Random seeds"
msgstr "ランダムシード"

#: 04-Randomisation.md:80
msgid ""
"So, what if you don't like this particular sequence of random numbers Sonic Pi"
" provides? Well it's totally possible to choose a different starting point via"
" `use_random_seed`. The default seed happens to be 0, so choose a different se"
"ed for a different random experience!"
msgstr ""
"もし、Sonic Piが提供する乱数の特定の配列が気に入らない場合、`use_random_seed`を介すことで別の開始点を選択することが可能です。シード"
"のデフォルト値は0であるため、異なる乱数を試すために別のシードの値を入力してみましょう！"

#: 04-Randomisation.md:85
msgid "Consider the following:"
msgstr "下記を考えてみてください："

#: 04-Randomisation.md:87
#, no-wrap
msgid ""
"5.times do\n"
"  play rrand(50, 100)\n"
"  sleep 0.5\n"
"end"
msgstr ""
"5.times do\n"
"  play rrand(50, 100)\n"
"  sleep 0.5\n"
"end"

#: 04-Randomisation.md:94
msgid ""
"Every time you run this code, you'll hear the same sequence of 5 notes. To get"
" a different sequence simply change the seed:"
msgstr "このコードを実行するたびに、5音階の同じシーケンスが聞けるでしょう。異なるシーケンスを聞くには、シードの値を変更します。"

#: 04-Randomisation.md:97
#, no-wrap
msgid ""
"use_random_seed 40\n"
"5.times do\n"
"  play rrand(50, 100)\n"
"  sleep 0.5\n"
"end"
msgstr ""
"use_random_seed 40\n"
"5.times do\n"
"  play rrand(50, 100)\n"
"  sleep 0.5\n"
"end"

#: 04-Randomisation.md:105
msgid ""
"This will produce a different sequence of 5 notes. By changing the seed and li"
"stening to the results you can find something that you like - and when you sha"
"re it with others, they will hear exactly what you heard too."
msgstr ""
"こうして異なる5音階のシーケンスを生成します。シードの値を変更することによって、あなたの好きなフレーズを見つけることができます。他の人と共有するとき、あなた"
"が聞いたものとまったく同様のフレーズを彼らも聞くことができるでしょう。"

#: 04-Randomisation.md:110
msgid "Let's have a look at some other useful random functions."
msgstr "有用なランダム関数をもう少し見ていきましょう。"

#: 04-Randomisation.md:113
msgid "choose"
msgstr "choose：選択"

#: 04-Randomisation.md:115
msgid ""
"A very common thing to do is to choose an item randomly from a list of known i"
"tems. For example, I may want to play one note from the following: 60, 65 or 7"
"2. I can achieve this with `choose` which lets me choose an item from a list. "
"First, I need to put my numbers in a list which is done by wrapping them in sq"
"uare brackets and separating them with commas: `[60, 65, 72]`. Next I just nee"
"d to pass them to `choose`:"
msgstr ""
"あらかじめ用意した数値をリストの中からランダムに選択することは、一般的に行われていることでしょう。例えば、60、65または72の中から1音を演奏することがで"
"きます。`choose`を用いれば、リストから1つの項目をで選択することができます。まず、カンマで区切った番号のリストを角括弧でラップ（包んで）し、配置する"
"必要があります：`[60, 65, 72]`。次にそれらを`choose`に渡す必要があります。"

#: 04-Randomisation.md:122
#, no-wrap
msgid "choose([60, 65, 72])"
msgstr "choose([60, 65, 72])"

#: 04-Randomisation.md:126
msgid "Let's hear what that sounds like:"
msgstr "どんな音になるか聞いてみましょう。"

#: 04-Randomisation.md:128
#, no-wrap
msgid ""
"loop do\n"
"  play choose([60, 65, 72])\n"
"  sleep 1\n"
"end"
msgstr ""
"loop do\n"
"  play choose([60, 65, 72])\n"
"  sleep 1\n"
"end"

#: 04-Randomisation.md:135
msgid "rrand"
msgstr "rrand"

#: 04-Randomisation.md:137
msgid ""
"We've already seen `rrand`, but let's run over it again. It returns a random n"
"umber between two values exclusively. That means it will never return either t"
"he top or bottom number - always something in between the two. The number will"
" always be a float - meaning it's not a whole number but a fraction of a numbe"
"r. Examples of floats returned by `rrand(20, 110)`:"
msgstr ""
"すでに`rrand`について触れてきましたが、再び実行してみましょう。これは、2つの値の間の乱数（排他的）を返します。この意味するところは上部または下部の番"
"号いずれの値も含まれません。常に両者の間にある値です。そして、その番号は常に浮動小数点になります - それは整数ではなく、分数です。`rrand(20, 1"
"10)`で返される浮動小数点数の例は次のとおりです。"

#: 04-Randomisation.md:148
msgid "rrand_i"
msgstr "rrand_i"

#: 04-Randomisation.md:150
msgid ""
"Occasionally you'll want a whole random number, not a float. This is where `rr"
"and_i` comes to the rescue. It works similarly to `rrand` except it may return"
" the min and max values as potential random values (which means it's inclusive"
" rather than exclusive of the range). Examples of numbers returned by `rrand_i"
"(20, 110)` are:"
msgstr ""
"時々、あなたは小数点ではなく、整数の乱数を望むこともあるでしょう。これは`rrand_i`を用いることで解決できます。それは小数点を除いて`rrand`と同"
"様に最小値および最大値の範囲（この場合、最長値と最大値も含まれます）に潜在するランダム値を返す動作をします。下記は、`rrand_i(20, 110)`によ"
"って返される数値の例です。"

#: 04-Randomisation.md:160
msgid "rand"
msgstr "rand"

#: 04-Randomisation.md:162
msgid ""
"This will return a random float between 0 (inclusive) and the max value you sp"
"ecify (exclusive). By default it will return a value between 0 and one. It's t"
"herefore useful for choosing random `amp:` values:"
msgstr ""
"`rand`は、`0`を含む最小値と、引数として指定した最大値未満の間のランダムな浮動小数点数を返します。デフォルトでは`0`と`1`の間の値を返します。こ"
"のため、`amp:`値をランダム化する際に便利です。"

#: 04-Randomisation.md:167
#, no-wrap
msgid ""
"loop do\n"
"  play 60, amp: rand\n"
"  sleep 0.25\n"
"end"
msgstr ""
"loop do\n"
"  play 60, amp: rand\n"
"  sleep 0.25\n"
"end"

#: 04-Randomisation.md:174
msgid "rand_i"
msgstr "rand_i"

#: 04-Randomisation.md:176
msgid ""
"Similar to the relationship between `rrand_i` and `rrand`, `rand_i` will retur"
"n a random whole number between 0 and the max value you specify."
msgstr "`rrand_i`と`rrand`の関係と同様に、`rand_i`は`0`と引数として指定した最大値の間の整数値を返します。"

#: 04-Randomisation.md:179
msgid "dice"
msgstr "dice:サイコロ"

#: 04-Randomisation.md:181
msgid ""
"Sometimes you want to emulate a dice throw - this is a special case of `rrand_"
"i` where the lower value is always 1. A call to `dice` requires you to specify"
" the number of sides on the dice. A standard dice has 6 sides, so `dice(6)` wi"
"ll act very similarly - returning values of either 1, 2, 3, 4, 5, or 6. Howeve"
"r, just like fantasy role-play games, you might find value in a 4 sided dice, "
"or a 12 sided dice, or a 20 sided dice - perhaps even a 120 sided dice!"
msgstr ""
"ランダムな数字を出す際に、サイコロ投げをまねてみたくなることもあるでしょう。これは、常に下の値が1である`rrand_i`の特殊なケースです。`dice`を"
"呼び出す時は、サイコロの面の数を指定する必要があります。標準的なサイコロは6面で、`dice(6)`では、1, 2, 3, 4, 5または6を返すサイコロと"
"同様の作用をします。しかし、空想のボードゲームのように、4面、12面または20面サイコロ、さらには120面のサイコロで値を見つけたいこともあるでしょう。"

#: 04-Randomisation.md:189
msgid "one_in"
msgstr "one_in"

#: 04-Randomisation.md:191
msgid ""
"Finally you may wish to emulate throwing the top score of a dice such as a 6 i"
"n a standard dice. `one_in` therefore returns true with a probability of one i"
"n the number of sides on the dice. Therefore `one_in(6)` will return true with"
" a probability of 1 in 6 or false otherwise. True and false values are very us"
"eful for `if` statements which we will cover in a subsequent section of this t"
"utorial."
msgstr ""
"最後に、一般的なサイコロを振って、例えば6を出すということをやってみたくなることもあるでしょう。`one_in`はサイコロの面の数分の1の確率でtrueを返"
"します。したがって`one_in(6)`では6分1の確率でtrue、それ以外の場合はfalseを返します。`true`と`false`の値は、このチュートリ"
"アルの次のセクションで説明するif文で非常に有用です。"

#: 04-Randomisation.md:198
msgid "Now, go and jumble up your code with some randomness!"
msgstr "さあ、ランダム性を使いこなしてコードをまぜこぜにしていきましょう！"

#: 05-Programming-Structures.md:1
msgid "5 Programming Structures"
msgstr "5 プログラミングの構造"

#: 05-Programming-Structures.md:3
msgid "Programming Structures"
msgstr "プログラミングの構造"

#: 05-Programming-Structures.md:5
msgid ""
"Now that you've learned the basics of creating sounds with `play` and `sample`"
" and creating simple melodies and rhythms by `sleep`ing between sounds, you mi"
"ght be wondering what else the world of code can offer you..."
msgstr ""
"これまでの章で、みなさんは`play`や`sample`コマンドを使ったり、`sleep`を使ってシンプルなメロディーやリズムを作曲することを通して音楽制作"
"（サウンドプログラミング）の基礎を学ぶことができました。Sonic Piのコードの世界で他にどんなことができるか興味が出てきたことでしょう…"

#: 05-Programming-Structures.md:10
msgid ""
"Well, you're in for an exciting treat! It turns out that basic programming str"
"uctures such as looping, conditionals, functions and threads give you amazingl"
"y powerful tools to express your musical ideas."
msgstr ""
"それでは、プログラミングの基礎となるループや条件文、ファンクション（関数）やスレッドなどに進みましょう。それらが、音楽的なアイデアを実現するための驚くほど強"
"力なツールになることでしょう。"

#: 05-Programming-Structures.md:14
msgid "Let's get stuck in with the basics..."
msgstr "それでは、やってみましょう。"

#: 05.1-Blocks.md:1
msgid "5.1 Blocks"
msgstr "5.1 ブロック"

#: 05.1-Blocks.md:3
msgid "Blocks"
msgstr "ブロック"

#: 05.1-Blocks.md:5
msgid ""
"A structure you'll see a lot in Sonic Pi is the block. Blocks allow us to do u"
"seful things with large chunks of code. For example, with synth and sample par"
"ameters we were able to change something that happened on a single line. Howev"
"er, sometimes we want to do something meaningful to a number of lines of code."
" For example, we may wish to loop it, to add reverb to it, to only run it 1 ti"
"me out of 5, etc. Consider the following code:"
msgstr ""
"Sonic Piでよく見る構造はブロック（`block`）といいます。ブロックは沢山のコードをひとかたまりとして、便利に扱うことができます。たとえば`syn"
"th`や`sample`では、その後ろのパラメータによって音を変えることができました。しかし、場合によってはコード数行に同じ変更内容を反映させたい時などが出"
"てきます。たとえばループする時に、5回のうち1回だけリバーブを加えたい場合を考えてみます。"

#: 05.1-Blocks.md:13
#, no-wrap
msgid ""
"play 50\n"
"sleep 0.5\n"
"sample :elec_plip\n"
"sleep 0.5\n"
"play 62"
msgstr ""
"play 50\n"
"sleep 0.5\n"
"sample :elec_plip\n"
"sleep 0.5\n"
"play 62"

#: 05.1-Blocks.md:21
msgid ""
"To do something with a chunk of code, we need to tell Sonic Pi where the code "
"block *starts* and where it *ends*. We use `do` for start and `end` for end. F"
"or example:"
msgstr ""
"コードのまとまりを使って何かをしようとするときに、コードのブロックの始まりと終わりをSonic Piに伝える必要があります。その際に`do`を*始まり*に、"
"`end`を*終わり*として使用します。"

#: 05.1-Blocks.md:25
#, no-wrap
msgid ""
"do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"
msgstr ""
"do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"

#: 05.1-Blocks.md:35
msgid ""
"However, this isn't yet complete and won't work (try it and you'll get an erro"
"r) as we haven't told Sonic Pi what we want to do with this *do/end block*. We"
" tell Sonic Pi this by writing some special code before the `do`. We'll see a "
"number of these special pieces of code later on in this tutorial. For now, it'"
"s important to know that wrapping your code within `do` and `end` tells Sonic "
"Pi you wish to do something special with that chunk of code."
msgstr ""
"しかし、これではまだ完璧ではないので、実行されません（動かしてみてもエラーメッセージが出るだけです）。実行したい*始まり*と*終わり*のブロックをSonic"
" Piへ伝達が完了していないからです。`do`の前に特別なコードをすこし書くことによってこのブロックをSonic Piに教えることができます。このチュートリ"
"アルの後半でこれらの特別なコードを使ったいくつかの事例を紹介していきます。ひとまず、みなさんが特別なコードを使ってSonic Piを動かしたい場合、`do`"
"と`end`でコードをまとめることが重要であることを覚えておいてください。"

#: 05.2-Iteration-and-Loops.md:1
msgid "5.2 Iteration and Loops"
msgstr "5.2 イテレーション（反復）とループ"

#: 05.2-Iteration-and-Loops.md:3
msgid "Iteration and Loops"
msgstr "イテレーション（反復）とループ"

#: 05.2-Iteration-and-Loops.md:5
msgid ""
"So far we've spent a lot of time looking at the different sounds you can make "
"with `play` and `sample` blocks. We've also learned how to trigger these sound"
"s through time using `sleep`."
msgstr ""
"以前に我々は、`play`と`sample`のブロックで、様々な音を作り出せることを見てきました。また、`sleep`を使うことで、これらの音を時間に沿って"
"再生する方法も学びました。"

#: 05.2-Iteration-and-Loops.md:9
msgid ""
"As you've probably found out, there's a *lot* of fun you can have with these b"
"asic building blocks. However, a whole new dimension of fun opens up when you "
"start using the power of code to structure your music and compositions. In the"
" next few sections we'll explore some of these powerful new tools. First up is"
" iteration and loops."
msgstr ""
"これらの基本的なブロックを使用することで*多く*の楽しさがあることを理解してもらえたのではないでしょうか。しかし、音楽を作るための強力なコードを学べば、その"
"楽しさの次元はまた新しい段階に向かうでしょう。次のいくつかのセクションではパワフルな新しいツールを探っていきます。はじめに「イテレーション（反復）とループ」"
"を学びます。"

#: 05.2-Iteration-and-Loops.md:15
msgid "Repetition"
msgstr "リピート"

#: 05.2-Iteration-and-Loops.md:17
msgid ""
"Have you written some code you'd like to repeat a few times? For example, you "
"might have something like this:"
msgstr "何回か繰り返しを行うためにはどのようにコードを書いたらよいでしょう？ 例えばこのようなコードです。"

#: 05.2-Iteration-and-Loops.md:20
#, no-wrap
msgid ""
"play 50\n"
"sleep 0.5\n"
"sample :elec_blup\n"
"sleep 0.5\n"
"play 62\n"
"sleep 0.25"
msgstr ""
"play 50\n"
"sleep 0.5\n"
"sample :elec_blup\n"
"sleep 0.5\n"
"play 62\n"
"sleep 0.25"

#: 05.2-Iteration-and-Loops.md:29
msgid ""
"What if we wished to repeat this 3 times? Well, we could do something simple a"
"nd just copy and paste it three times:"
msgstr "これを3回繰り返したい場合、どうしたら良いでしょう？ 単純に考えればコピーして貼り付けを3回繰り返せば可能です。"

#: 05.2-Iteration-and-Loops.md:32
#, no-wrap
msgid ""
"play 50\n"
"sleep 0.5\n"
"sample :elec_blup\n"
"sleep 0.5\n"
"play 62\n"
"sleep 0.25\n"
"play 50\n"
"sleep 0.5\n"
"sample :elec_blup\n"
"sleep 0.5\n"
"play 62\n"
"sleep 0.25\n"
"play 50\n"
"sleep 0.5\n"
"sample :elec_blup\n"
"sleep 0.5\n"
"play 62\n"
"sleep 0.25"
msgstr ""
"play 50\n"
"sleep 0.5\n"
"sample :elec_blup\n"
"sleep 0.5\n"
"play 62\n"
"sleep 0.25\n"
"play 50\n"
"sleep 0.5\n"
"sample :elec_blup\n"
"sleep 0.5\n"
"play 62\n"
"sleep 0.25\n"
"play 50\n"
"sleep 0.5\n"
"sample :elec_blup\n"
"sleep 0.5\n"
"play 62\n"
"sleep 0.25"

#: 05.2-Iteration-and-Loops.md:55
msgid ""
"Now that's a lot of code! What happens if you want to change the sample to `:e"
"lec_plip`? You're going to have to find all the places with the original `:ele"
"c_blup` and switch them over. More importantly, what if you wanted to repeat t"
"he original piece of code 50 times or 1000? Now that would be a lot of code, a"
"nd a lot of lines of code to alter if you wanted to make a change."
msgstr ""
"ちょっと長過ぎますよね。もしサンプルを`:elec_plip`に変更させたい場合、どうしたら良いでしょうか？ 3か所全部の`:elec_blup` をひとつ"
"ひとつ変えなくてはいけません。さらに重要なことですが、繰り返しが50回とか1000回になったとしたらどうでしょう？ 変更したいコードがすごくたくさんになって"
"しまいます。"

#: 05.2-Iteration-and-Loops.md:62
msgid "Iteration"
msgstr "イテレーション（反復）"

#: 05.2-Iteration-and-Loops.md:64
msgid ""
"In fact, repeating the code should be as easy as saying *do this three times*."
" Well, it pretty much is. Remember our old friend the code block? We can use i"
"t to mark the start and end of the code we'd like to repeat three times. We th"
"en use the special code `3.times`. So, instead of writing *do this three times"
"*, we write `3.times do` - that's not too hard. Just remember to write `end` a"
"t the end of the code you'd like to repeat:"
msgstr ""
"コードの繰り返しは、*これを3回やって*と言うくらい簡単に出来るべきだし、実際のところ簡単に出来ます。先ほど学んだコードブロックを思い出してください。3回繰"
"り返したいコードのブロックには「始まり」と「終わり」が記されていますね。そんな時にこの特別なコードである`3.times`を使いましょう。同じコードを*3回"
"繰り返す*代わりに、`3.times`を書くことで、とても簡単に出来るようになります。その時にコードの最終行に`end`を書き入れることも忘れないようにしま"
"しょう。"

#: 05.2-Iteration-and-Loops.md:72
#, no-wrap
msgid ""
"3.times do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_blup\n"
"  sleep 0.5\n"
"  play 62\n"
"  sleep 0.25\n"
"end"
msgstr ""
"3.times do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_blup\n"
"  sleep 0.5\n"
"  play 62\n"
"  sleep 0.25\n"
"end"

#: 05.2-Iteration-and-Loops.md:83
msgid ""
"Now isn't that much neater than cutting and pasting! We can use this to create"
" lots of nice repeating structures:"
msgstr ""
"コピーと貼り付けを繰り返すより、ずっと美しいコードになったと思いませんか？こ"
"のようにブロックを使うと、沢山の繰り返しの構造を作ることが出来るのです。"

#: 05.2-Iteration-and-Loops.md:86
#, no-wrap
msgid ""
"4.times do\n"
"  play 50\n"
"  sleep 0.5\n"
"end\n"
"8.times do\n"
"  play 55, release: 0.2\n"
"  sleep 0.25\n"
"end\n"
"4.times do\n"
"  play 50\n"
"  sleep 0.5\n"
"end"
msgstr ""
"4.times do\n"
"  play 50\n"
"  sleep 0.5\n"
"end\n"
"8.times do\n"
"  play 55, release: 0.2\n"
"  sleep 0.25\n"
"end\n"
"4.times do\n"
"  play 50\n"
"  sleep 0.5\n"
"end"

#: 05.2-Iteration-and-Loops.md:103
msgid "Nesting Iterations"
msgstr "イテレーション（反復）のネスティング（入れ子）"

#: 05.2-Iteration-and-Loops.md:105
msgid ""
"We can put iterations inside other iterations to create interesting patterns. "
"For example:"
msgstr "繰り返しの中にさらに繰り返しを入れることによって面白いパターンを作ることが出来ます。例えば"

#: 05.2-Iteration-and-Loops.md:108
#, no-wrap
msgid ""
"4.times do\n"
"  sample :drum_heavy_kick\n"
"  2.times do\n"
"    sample :elec_blip2, rate: 2\n"
"    sleep 0.25\n"
"  end\n"
"  sample :elec_snare\n"
"  4.times do\n"
"    sample :drum_tom_mid_soft\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"4.times do\n"
"  sample :drum_heavy_kick\n"
"  2.times do\n"
"    sample :elec_blip2, rate: 2\n"
"    sleep 0.25\n"
"  end\n"
"  sample :elec_snare\n"
"  4.times do\n"
"    sample :drum_tom_mid_soft\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: 05.2-Iteration-and-Loops.md:123
msgid "Looping"
msgstr "ループ（終わりのない繰り返し）"

#: 05.2-Iteration-and-Loops.md:125
msgid ""
"If you want something to repeat a lot of times, you might find yourself using "
"really large numbers such as `1000.times do`. In this case, you're probably be"
"tter off asking Sonic Pi to repeat forever (at least until you press the stop "
"button!). Let's loop the amen break forever:"
msgstr ""
"もしすごくたくさんの繰り返しをしたい場合、`1000.times do`のようにすごく大きな数値の繰り返しをさせることになってしまいます。こういった場合は、"
"おそらく（stopボタンを押すまで）無限に繰り返す機能がほしいと思うでしょう。さあ、アーメン・ブレイクのサンプルを無限にループさせてみましょう。"

#: 05.2-Iteration-and-Loops.md:130
#, no-wrap
msgid ""
"loop do\n"
"  sample :loop_amen\n"
"  sleep sample_duration :loop_amen\n"
"end"
msgstr ""
"loop do\n"
"  sample :loop_amen\n"
"  sleep sample_duration :loop_amen\n"
"end"

#: 05.2-Iteration-and-Loops.md:137
msgid ""
"The important thing to know about loops is that they act like black holes for "
"code. Once the code enters a loop it can never leave until you press stop - it"
" will just go round and round the loop forever. This means if you have code af"
"ter the loop you will *never* hear it. For example, the cymbal after this loop"
" will never play:"
msgstr ""
"loopについて知っておかなくてはならない重要な点は、これはコードの中でブラックホールのように動いてしまう点です。一度loop機能が動いてしまうと、`sto"
"p`ボタンを押さない限り永遠に再生されるということです。つまり、これはloopより後ろにあるコードを*絶対に*聞くことが出来ないということを意味しています。"
"例えば、下の例で言うと、シンバルの音はloopより後ろにあるため、決して再生されることはありません。"

#: 05.2-Iteration-and-Loops.md:143
#, no-wrap
msgid ""
"loop do\n"
"  play 50\n"
"  sleep 1\n"
"end\n"
"sample :drum_cymbal_open"
msgstr ""
"loop do\n"
"  play 50\n"
"  sleep 1\n"
"end\n"
"sample :drum_cymbal_open"

#: 05.2-Iteration-and-Loops.md:152
msgid "Now, get structuring your code with iteration and loops!"
msgstr "さあ、これで回数を指定するイテレーション（反復）と永遠に繰り返すループのコーディング方法を理解することができましたね!"

#: 05.3-Conditionals.md:1
msgid "5.3 Conditionals"
msgstr "5.3 条件文"

#: 05.3-Conditionals.md:3
msgid "Conditionals"
msgstr "条件文"

#: 05.3-Conditionals.md:5
msgid ""
"A common thing you'll likely find yourself wanting to do is to not only play a"
" random note (see the previous section on randomness) but also make a random d"
"ecision and based on the outcome run some code or some other code. For example"
", you might want to randomly play a drum or a cymbal. We can achieve this with"
" an `if` statement."
msgstr ""
"ランダムな音符を再生する（前章参照）だけでなく、あるコードとそれとは別なコードの実行をランダムに決めたくなるかもしれません。例えば、ドラムとシンバルをランダ"
"ムに再生したいような場合です。このような場合、`if`文を使うことで実現できます。"

#: 05.3-Conditionals.md:11
msgid "Flipping a Coin"
msgstr "コイントス"

#: 05.3-Conditionals.md:13
msgid ""
"So, let's flip a coin: if it's heads, play a drum, if it's tails, play a cymba"
"l. Easy. We can emulate a coin flip with our `one_in` function (introduced in "
"the section on randomness) specifying a probability of 1 in 2: `one_in(2)`. We"
" can then use the result of this to decide between two pieces of code, the cod"
"e to play the drum and the code to play the cymbal:"
msgstr ""
"それではコインをトス（投げる）してみましょう。もしもコインが表であればドラムを鳴らし、裏であればシンバルを鳴らします。簡単ですね。コイントスの機能は`one"
"_in` という機能（ランダムのセクションで紹介しています）によって実現されます。2つのうちの1つというように条件を細かく指定するときには`one_in(2"
")`と記述すると、ドラムを鳴らすコードとシンバルを鳴らす2つのコードどちらかを決められるようになります。"

#: 05.3-Conditionals.md:20
#, no-wrap
msgid ""
"loop do\n"
"  if one_in(2)\n"
"    sample :drum_heavy_kick\n"
"  else\n"
"    sample :drum_cymbal_closed\n"
"  end\n"
"  \n"
"  sleep 0.5\n"
"  \n"
"end"
msgstr ""
"loop do\n"
"  if one_in(2)\n"
"    sample :drum_heavy_kick\n"
"  else\n"
"    sample :drum_cymbal_closed\n"
"  end\n"
"  \n"
"  sleep 0.5\n"
"  \n"
"end"

#: 05.3-Conditionals.md:34
msgid "Notice that `if` statements have three parts:"
msgstr "if文は3つのパートを持っていることに注目してみましょう。"

#: 05.3-Conditionals.md:36
msgid "The question to ask"
msgstr "条件"

#: 05.3-Conditionals.md:37
msgid "The first choice of code to run (if the answer to the question is yes)"
msgstr "はじめの選択によって実行されるコード（条件が正しかった場合）"

#: 05.3-Conditionals.md:38
msgid "The second choice of code to run (if the answer to the question is no)"
msgstr "次の選択によって実行されるコード（条件が間違っていた場合）"

#: 05.3-Conditionals.md:40
msgid ""
"Typically in programming languages, the notion of yes is represented by the te"
"rm `true` and the notion of no is represented by the term `false`. So we need "
"to find a question that will give us a `true` or `false` answer which is exact"
"ly what `one_in` does."
msgstr ""
"典型的なプログラム言語では、概ね、真（正しいという意味）を`true`で表現し、偽（正しくない場合）は`false`と表記します。そのため、先の例で`one"
"_in`が行っているような、`true`か`false`か答えることができる質問が必要となります。"

#: 05.3-Conditionals.md:45
msgid ""
"Notice how the first choice is wrapped between the `if` and the `else` and the"
" second choice is wrapped between the `else` and the `end`. Just like do/end b"
"locks you can put multiple lines of code in either place. For example:"
msgstr ""
"はじめの選択では `if` と`else`の間に挟まれたプログラムが実行され、そして2番目の選択では`else`と`end`の間が実行されるということに注目"
"しましょう。それは複数行のコードをまとめる*do/end*ブロックにとても似ていますね。例えば、"

#: 05.3-Conditionals.md:50
#, no-wrap
msgid ""
"loop do\n"
"  if one_in(2)\n"
"    sample :drum_heavy_kick\n"
"    sleep 0.5\n"
"  else\n"
"    sample :drum_cymbal_closed\n"
"    sleep 0.25\n"
"  end\n"
"  \n"
"end"
msgstr ""
"loop do\n"
"  if one_in(2)\n"
"    sample :drum_heavy_kick\n"
"    sleep 0.5\n"
"  else\n"
"    sample :drum_cymbal_closed\n"
"    sleep 0.25\n"
"  end\n"
"  \n"
"end"

#: 05.3-Conditionals.md:64
msgid ""
"This time we're sleeping for a different amount of time depending on which cho"
"ice we make."
msgstr "`sleep 0.5`や`sleep 0.25`など、異なる休符時間を持つ場合、そのどちらかに応じることになります。"

#: 05.3-Conditionals.md:68
msgid "Simple if"
msgstr "シンプルなif（if修飾子）"

#: 05.3-Conditionals.md:70
msgid ""
"Sometimes you want to optionally execute just one line of code. This is possib"
"le by placing `if` and then the question at the end. For example:"
msgstr "時には、任意のコードを1行だけ実行したいときがあるでしょう。これは`if`と条件を後ろに記述することで可能です。例えば、"

#: 05.3-Conditionals.md:73
#, no-wrap
msgid ""
"use_synth :dsaw\n"
"loop do\n"
"  play 50, amp: 0.3, release: 2\n"
"  play 53, amp: 0.3, release: 2 if one_in(2)\n"
"  play 57, amp: 0.3, release: 2 if one_in(3)\n"
"  play 60, amp: 0.3, release: 2 if one_in(4)\n"
"  sleep 1.5\n"
"end"
msgstr ""
"use_synth :dsaw\n"
"loop do\n"
"  play 50, amp: 0.3, release: 2\n"
"  play 53, amp: 0.3, release: 2 if one_in(2)\n"
"  play 57, amp: 0.3, release: 2 if one_in(3)\n"
"  play 60, amp: 0.3, release: 2 if one_in(4)\n"
"  sleep 1.5\n"
"end"

#: 05.3-Conditionals.md:85
msgid ""
"This will play chords of different numbers with the chance of each note playin"
"g having a different probability."
msgstr "上のコードでは、それぞれの音符が持つ別の確率によって、異なる数のコード（和音）を奏でるでしょう。"

#: 05.4-Threads.md:1
msgid "5.4 Threads"
msgstr "5.4 スレッド"

#: 05.4-Threads.md:3
msgid "Threads"
msgstr "スレッド"

#: 05.4-Threads.md:5
msgid ""
"So you've made your killer bassline and a phat beat. How do you play them at t"
"he same time? One solution is to weave them together manually - play some bass"
", then a bit of drums, then more bass... However, the timing soon gets hard to"
" think about, especially when you start weaving in more elements."
msgstr ""
"それでは、強烈なベースラインとかっこいいビートを作った場合、どのようにしてそれらを同時に鳴らしたらいいでしょう？ 1つの回答としては、手動でそれらを同時に鳴"
"らす事です ― まず、いくつかのベースを演奏し、その後にいくつかのドラム、またその後にベースというように…しかしながら、すぐに沢山の楽器を処理することが難し"
"いことに気づくでしょう。"

#: 05.4-Threads.md:11
msgid ""
"What if Sonic Pi could weave things for you automatically? Well, it can, and y"
"ou do it with a special thing called a *thread*."
msgstr "もし、Sonic Piが自動的にそれらを作り出せるとしたらどうでしょう？ *thread*（スレッド）と呼ばれる特別な命令によってそれが可能になります。"

#: 05.4-Threads.md:14
msgid "Infinite Loops"
msgstr "無限の繰り返し"

#: 05.4-Threads.md:16
msgid ""
"To keep this example simple, you'll have to imagine that this is a phat beat a"
"nd a killer bassline:"
msgstr "例を単純にするために、以下のコードを強烈なベースラインとかっこいいビートだと思ってください。"

#: 05.4-Threads.md:19
#, no-wrap
msgid ""
"loop do\n"
"  sample :drum_heavy_kick\n"
"  sleep 1\n"
"end\n"
"loop do\n"
"  use_synth :fm\n"
"  play 40, release: 0.2\n"
"  sleep 0.5\n"
"end"
msgstr ""
"loop do\n"
"  sample :drum_heavy_kick\n"
"  sleep 1\n"
"end\n"
"loop do\n"
"  use_synth :fm\n"
"  play 40, release: 0.2\n"
"  sleep 0.5\n"
"end"

#: 05.4-Threads.md:32
msgid ""
"As we've discussed previously, loops are like *black holes* for the program. O"
"nce you enter a loop you can never exit from it until you hit stop. How do we "
"play both loops at the same time? We have to tell Sonic Pi that we want to sta"
"rt something at the same time as the rest of the code. This is where threads c"
"ome to the rescue."
msgstr ""
"ループはプログラムの*ブラックホール*のようだと以前にお話しました。一度ループ"
"を入れると、stopボタンを押さない限り、そこから抜け出せなくなります。では、ど"
"うしたら同時にふたつの繰り返しを演奏することが出来るでしょう？私たちは、"
"同時にそれらのコードをタイミングを合わせスタートさせるようにSonic "
"Piに伝えなくてはいけません。これがスレッドを使った解決方法なのです。"

#: 05.4-Threads.md:38
msgid "Threads to the Rescue"
msgstr "スレッドを使った解決方法"

#: 05.4-Threads.md:40
#, no-wrap
msgid ""
"in_thread do\n"
"  loop do\n"
"    sample :drum_heavy_kick\n"
"    sleep 1\n"
"  end\n"
"end\n"
"loop do\n"
"  use_synth :fm\n"
"  play 40, release: 0.2\n"
"  sleep 0.5\n"
"end"
msgstr ""
"in_thread do\n"
"  loop do\n"
"    sample :drum_heavy_kick\n"
"    sleep 1\n"
"  end\n"
"end\n"
"loop do\n"
"  use_synth :fm\n"
"  play 40, release: 0.2\n"
"  sleep 0.5\n"
"end"

#: 05.4-Threads.md:55
msgid ""
"By wrapping the first loop in an `in_thread` do/end block we tell Sonic Pi to "
"run the contents of the do/end block at *exactly* the same time as the next st"
"atement after the do/end block (which happens to be the second loop). Try it a"
"nd you'll hear both the drums and the bassline weaved together!"
msgstr ""
"はじめの*do/end*ブロックを`in_thread`で囲むことで、次にくる*do/end*ブロックを*ぴったりと*同時にループさせるようにSonic P"
"iに命令することができます。それではドラムとベースラインを同時に鳴らすことに挑戦してみましょう！"

#: 05.4-Threads.md:61
msgid "Now, what if we wanted to add a synth on top. Something like:"
msgstr "そして、もう1つの音を追加したいので、先ほどのように繰り返しを入れてみましょう。"

#: 05.4-Threads.md:63
#, no-wrap
msgid ""
"in_thread do\n"
"  loop do\n"
"    sample :drum_heavy_kick\n"
"    sleep 1\n"
"  end\n"
"end\n"
"loop do\n"
"  use_synth :fm\n"
"  play 40, release: 0.2\n"
"  sleep 0.5\n"
"end\n"
"loop do\n"
"  use_synth :zawa\n"
"  play 52, release: 2.5, phase: 2, amp: 0.5\n"
"  sleep 2\n"
"end"
msgstr ""
"in_thread do\n"
"  loop do\n"
"    sample :drum_heavy_kick\n"
"    sleep 1\n"
"  end\n"
"end\n"
"loop do\n"
"  use_synth :fm\n"
"  play 40, release: 0.2\n"
"  sleep 0.5\n"
"end\n"
"loop do\n"
"  use_synth :zawa\n"
"  play 52, release: 2.5, phase: 2, amp: 0.5\n"
"  sleep 2\n"
"end"

#: 05.4-Threads.md:84
msgid ""
"Now we have the same problem as before. The first loop is played at the same t"
"ime as the second loop due to the `in_thread`. However, *the third loop is nev"
"er reached*. We therefore need another thread:"
msgstr ""
"前と同じ問題が出てきましたね。`in_thread`によって最初の繰り返しと2つ目の繰り返しが同時に演奏されています。しかし3番目の繰り返しが演奏されません"
"。ですので以下のように、もう1つのスレッドが必要となります。"

#: 05.4-Threads.md:88
#, no-wrap
msgid ""
"in_thread do\n"
"  loop do\n"
"    sample :drum_heavy_kick\n"
"    sleep 1\n"
"  end\n"
"end\n"
"in_thread do\n"
"  loop do\n"
"    use_synth :fm\n"
"    play 40, release: 0.2\n"
"    sleep 0.5\n"
"  end\n"
"end\n"
"loop do\n"
"  use_synth :zawa\n"
"  play 52, release: 2.5, phase: 2, amp: 0.5\n"
"  sleep 2\n"
"end"
msgstr ""
"in_thread do\n"
"  loop do\n"
"    sample :drum_heavy_kick\n"
"    sleep 1\n"
"  end\n"
"end\n"
"in_thread do\n"
"  loop do\n"
"    use_synth :fm\n"
"    play 40, release: 0.2\n"
"    sleep 0.5\n"
"  end\n"
"end\n"
"loop do\n"
"  use_synth :zawa\n"
"  play 52, release: 2.5, phase: 2, amp: 0.5\n"
"  sleep 2\n"
"end"

#: 05.4-Threads.md:111
msgid "Runs as threads"
msgstr "スレッドとして実行する"

#: 05.4-Threads.md:113
msgid ""
"What may surprise you is that when you press the Run button, you're actually c"
"reating a new thread for the code to run. This is why pressing it multiple tim"
"es will layer sounds over each other. As the runs themselves are threads, they"
" will automatically weave the sounds together for you."
msgstr ""
"驚くべきことに`Run`ボタンを押すということは、実際にはコードを実行するための新しいスレッドを作っていることになります。そのために複数回`Run`ボタンを"
"押すことは、互いの上に音を階層化することになります。`Run`それ自体がスレッドであるために、音を自動的に紡ぎ合わせることになるのです。"

#: 05.4-Threads.md:119
msgid "Scope"
msgstr "スコープ"

#: 05.4-Threads.md:121
msgid ""
"As you learn how to master Sonic Pi, you'll learn that threads are the most im"
"portant building blocks for your music. One of the important jobs they have is"
" to isolate the notion of *current settings* from other threads. What does thi"
"s mean? Well, when you switch synths using `use_synth` you're actually just sw"
"itching the synth in the *current thread* - no other thread will have their sy"
"nth switched. Let's see this in action:"
msgstr ""
"Sonic Piをマスターしようとするとき、スレッドが、音楽のために最も重要な構成要素であることに気がつくでしょう。スレッドの重要な役割の1つとして、他のス"
"レッドから*現在の設定*を分離することがあります。どういうことかというと、例えば`use_synth`を使ってシンセの種類を変更する時、*現在のスレッド*中"
"にあるシンセだけを変更します。他のどのスレッドも変更しません。そのことを確認してみましょう。"

#: 05.4-Threads.md:129
#, no-wrap
msgid ""
"play 50\n"
"sleep 1\n"
"in_thread do\n"
"  use_synth :tb303\n"
"  play 50\n"
"end\n"
"sleep 1\n"
"play 50"
msgstr ""
"play 50\n"
"sleep 1\n"
"in_thread do\n"
"  use_synth :tb303\n"
"  play 50\n"
"end\n"
"sleep 1\n"
"play 50"

#: 05.4-Threads.md:142
msgid ""
"Notice how the middle sound was different to the others? The `use_synth` state"
"ment only affected the thread it was in and not the outer main run thread."
msgstr "真ん中の音だけがほかのものと違うことに注目してみましょう。`use_synth`の宣言はスレッドの中だけに影響し、スレッドの外にあるものには影響しません。"

#: 05.4-Threads.md:146
msgid "Inheritance"
msgstr "インヘリタンス（継承機能）"

#: 05.4-Threads.md:148
msgid ""
"When you create a new thread with `in_thread`, the new thread will automatical"
"ly inherit all of the current settings from the current thread. Let's see that"
":"
msgstr "`in_thread`を使って新しいスレッドを作ると、新しいスレッドには現在のスレッドの全ての設定が自動的に継承されます。ではその機能を見てみましょう。"

#: 05.4-Threads.md:152
#, no-wrap
msgid ""
"use_synth :tb303\n"
"play 50\n"
"sleep 1\n"
"in_thread do\n"
"  play 55\n"
"end"
msgstr ""
"use_synth :tb303\n"
"play 50\n"
"sleep 1\n"
"in_thread do\n"
"  play 55\n"
"end"

#: 05.4-Threads.md:162
msgid ""
"Notice how the second note is played with the `:tb303` synth even though it wa"
"s played from a separate thread? Any of the settings modified with the various"
" `use_*` functions will behave in the same way."
msgstr ""
"2番目の音符は、それが別のスレッドから再生されたにもかかわらず`:tb303`シンセで演奏されることに注目してください。`use_*`関数を使ったいかなる設"
"定も同様に作用するでしょう。"

#: 05.4-Threads.md:166
msgid ""
"When threads are created, they inherit all the settings from their parent but "
"they don't share any changes back."
msgstr "スレッドが新規に作成されると、元のスレッドからすべての設定を継承しますが、スレッド作成以降の変更を共有することはありません。"

#: 05.4-Threads.md:169
msgid "Naming Threads"
msgstr "スレッドの命名"

#: 05.4-Threads.md:171
msgid "Finally, we can give our threads names:"
msgstr "最後に、スレッドに名前つける機能を覚えましょう。"

#: 05.4-Threads.md:173
#, no-wrap
msgid ""
"in_thread(name: :bass) do\n"
"  loop do\n"
"    use_synth :prophet\n"
"    play chord(:e2, :m7).choose, release: 0.6\n"
"    sleep 0.5\n"
"  end\n"
"end\n"
"in_thread(name: :drums) do\n"
"  loop do\n"
"    sample :elec_snare\n"
"    sleep 1\n"
"  end\n"
"end"
msgstr ""
"in_thread(name: :bass) do\n"
"  loop do\n"
"    use_synth :prophet\n"
"    play chord(:e2, :m7).choose, release: 0.6\n"
"    sleep 0.5\n"
"  end\n"
"end\n"
"in_thread(name: :drums) do\n"
"  loop do\n"
"    sample :elec_snare\n"
"    sleep 1\n"
"  end\n"
"end"

#: 05.4-Threads.md:190
msgid ""
"Look at the log pane when you run this code. See how the log reports the name "
"of the thread with the message?"
msgstr "このコードを実行した際、ログ画面を見てみましょう。ログの中にスレッドの名前が表示されることを確認できましたか？"

#: 05.4-Threads.md:193
#, no-wrap
msgid ""
"[Run 36, Time 4.0, Thread :bass]\n"
" |- synth :prophet, {release: 0.6, note: 47}"
msgstr ""
"[Run 36, Time 4.0, Thread :bass]\n"
" |- synth :prophet, {release: 0.6, note: 47}"

#: 05.4-Threads.md:198
msgid "Only One Thread per Name Allowed"
msgstr "1つの名前につき1つのスレッド"

#: 05.4-Threads.md:200
msgid ""
"One last thing to know about named threads is that only one thread of a given "
"name may be running at the same time. Let's explore this. Consider the followi"
"ng code:"
msgstr ""
"名前付きのスレッドについて知っておくべき最後のひとつは、ある名前の付いたスレッドは同時に1つだけ実行されることです。では以下を見てみましょう。次のコードを考"
"えてみてください。"

#: 05.4-Threads.md:204
#, no-wrap
msgid ""
"in_thread do\n"
"  loop do\n"
"    sample :loop_amen\n"
"    sleep sample_duration :loop_amen\n"
"  end\n"
"end"
msgstr ""
"in_thread do\n"
"  loop do\n"
"    sample :loop_amen\n"
"    sleep sample_duration :loop_amen\n"
"  end\n"
"end"

#: 05.4-Threads.md:213
msgid ""
"Go ahead and paste that into a buffer and press the Run button. Press it again"
" a couple of times. Listen to the cacophony of multiple amen breaks looping ou"
"t of time with each other. Ok, you can press Stop now."
msgstr ""
"Bufferに上のコードを貼り付けて、`Run`ボタンを押します。数回押してみましょう。複数のアーメン・ブレイクが不協和音として反復されるでしょう。もういい"
"ですよね。`Stop`ボタンを押しましょう。"

#: 05.4-Threads.md:217
msgid ""
"This is the behaviour we've seen again and again - if you press the Run button"
", sound layers on top of any existing sound. Therefore if you have a loop and "
"press the Run button three times, you'll have three layers of loops playing si"
"multaneously."
msgstr ""
"この動作はこれまで何度も見てきました。Runボタンを押すと、既に鳴っているサウンドのレイヤーの一番上にサウンドを追加します。このためループが含まれている場合"
"、Runボタンを3回押すと、3つのレイヤーが一斉に再生されます。"

#: 05.4-Threads.md:222
msgid "However, with named threads it is different:"
msgstr "ただし、名前付きのスレッドでそれは異なります。"

#: 05.4-Threads.md:224
#, no-wrap
msgid ""
"in_thread(name: :amen) do\n"
"  loop do\n"
"    sample :loop_amen\n"
"    sleep sample_duration :loop_amen\n"
"  end\n"
"end"
msgstr ""
"in_thread(name: :amen) do\n"
"  loop do\n"
"    sample :loop_amen\n"
"    sleep sample_duration :loop_amen\n"
"  end\n"
"end"

#: 05.4-Threads.md:233
msgid ""
"Try pressing the Run button multiple times with this code. You'll only ever he"
"ar one amen break loop. You'll also see this in the log:"
msgstr "このコードでRunボタン複数回、押してみてください。ひとつのアーメン・ブレイクのループのみが聞こえるでしょう。そして下記のテキストがログ画面に表示されます。"

#: 05.4-Threads.md:236
#, no-wrap
msgid "==> Skipping thread creation: thread with name :amen already exists."
msgstr "==> Skipping thread creation: thread with name :amen already exists."

#: 05.4-Threads.md:240
msgid ""
"Sonic Pi is telling you that a thread with the name `:amen` is already playing"
", so it's not creating another."
msgstr "Sonic Pi は、`:amen`という名前があるスレッドが既に存在するため、別のものを作成しませんと伝えています。"

#: 05.4-Threads.md:243
msgid ""
"This behaviour may not seem immediately useful to you now - but it will be ver"
"y handy when we start to live code..."
msgstr "この動作はすぐに使う必要性はないように思えますが、ライブコーディングを始めると、非常に便利なものになるでしょう。"

#: 05.5-Functions.md:1
msgid "5.5 Functions"
msgstr "5.5 ファンクション（関数）"

#: 05.5-Functions.md:3
msgid "Functions"
msgstr "ファンクション（関数）"

#: 05.5-Functions.md:5
msgid ""
"Once you start writing lots of code, you may wish to find a way to organise an"
"d structure things to make them tidier and easier to understand. Functions are"
" a very powerful way to do this. They give us the ability to give a name to a "
"bunch of code. Let's take a look."
msgstr ""
"一度、膨大なコードを書き始めると、それらの構造をより簡単かつ整理された状態で把握できるように、構築しまとめたいと感じることになるでしょう。`ファンクション`"
"（関数）はそんなことをとても効果的に成し遂げる方法です。この関数を使うとコードのまとまりに対して名前をつけることも可能になります。早速、見ていきましょう。"

#: 05.5-Functions.md:10
msgid "Defining functions"
msgstr "関数の定義"

#: 05.5-Functions.md:12
#, no-wrap
msgid ""
"define :foo do\n"
"  play 50\n"
"  sleep 1\n"
"  play 55\n"
"  sleep 2\n"
"end"
msgstr ""
"define :foo do\n"
"  play 50\n"
"  sleep 1\n"
"  play 55\n"
"  sleep 2\n"
"end"

#: 05.5-Functions.md:21
msgid ""
"Here, we've defined a new function called `foo`. We do this with our old frien"
"d the do/end block and the magic word `define` followed by the name we wish to"
" give to our function. We didn't have to call it `foo`, we could have called i"
"t anything we want such as `bar`, `baz` or ideally something meaningful to you"
" like `main_section` or `lead_riff`."
msgstr ""
"ここでは`foo`という名前を付けた新しい関数を定義しています。この章ではすっかりお馴染みの*do/end*ブロックと、`define`という魔法の言葉の後"
"ろに、この関数に付けたい名前を続けています。関数の名前は`foo`である必要はなく、`bar`や`baz`といったどんなものでも構いませんが、理想的には`m"
"ain_section`や`lead_riff`といった何か意味のあるものがよいでしょう。"

#: 05.5-Functions.md:27
msgid ""
"Remember to prepend a colon `:` to the name of your function when you define i"
"t."
msgstr "関数を定義するとき、その名前に`:`（コロン）を付加することを忘れないでください。"

#: 05.5-Functions.md:30
msgid "Calling functions"
msgstr "関数の呼び出し"

#: 05.5-Functions.md:32
msgid "Once we have defined our function we can call it by just writing its name:"
msgstr "いったん1つの関数を定義すると、ただ名前を書くことでそれを呼びだすことができます。"

#: 05.5-Functions.md:35
#, no-wrap
msgid ""
"define :foo do\n"
"  play 50\n"
"  sleep 1\n"
"  play 55\n"
"  sleep 0.5\n"
"end\n"
"foo\n"
"sleep 1\n"
"2.times do\n"
"  foo\n"
"end"
msgstr ""
"define :foo do\n"
"  play 50\n"
"  sleep 1\n"
"  play 55\n"
"  sleep 0.5\n"
"end\n"
"foo\n"
"sleep 1\n"
"2.times do\n"
"  foo\n"
"end"

#: 05.5-Functions.md:52
#, fuzzy
msgid ""
"We can even use `foo` inside iteration blocks or anywhere we may have written "
"`play` or `sample`. This gives us a great way to express ourselves and to crea"
"te new meaningful words for use in our compositions."
msgstr ""
"`foo`は、イテレーション（反復）ブロックの中からも使えたり、`play`や`sample`が書けるところであればどこからでも使えます。このことは、楽曲の"
"中で利用可能な意味のある言葉を作り出したり、自己表現したりする優れた方法を提供します。"

#: 05.5-Functions.md:56
msgid "Functions are remembered across runs"
msgstr "複数の`Run`を超えた関数の利用"

#: 05.5-Functions.md:58
msgid ""
"So far, every time you've pressed the Run button, Sonic Pi has started from a "
"completely blank slate. It knows nothing except for what is in the buffer. You"
" can't reference code in another buffer or another thread. However, functions "
"change that. When you define a function, Sonic Pi *remembers* it. Let's try it"
". Delete all the code in your buffer and replace it with:"
msgstr ""
"これまでのところ、`Run`ボタンを押すたびに、Sonic Piを完全に白紙の状態から始めたことにして、表示されているBuffer以外のコードは無いものとし"
"ていました。これは、別のBufferまたは別のスレッド内のコードを参照できなかったからです。しかし、関数はそれを変えることができます。あなたが関数を定義する"
"と、Sonic Piはそれを*覚える*ことができます。では、ちょっとやってみましょう。まずBufferにあるすべてのコードを消して、次のものに変更します。"

#: 05.5-Functions.md:65
#, no-wrap
msgid "foo"
msgstr "foo"

#: 05.5-Functions.md:69
msgid ""
"Press the Run button - and hear your function play. Where did the code go? How"
" did Sonic Pi know what to play? Sonic Pi just remembered your function - so e"
"ven after you deleted it from the buffer, it remembered what you had typed. Th"
"is behaviour only works with functions created using `define` (and `defonce`)."
msgstr ""
"`Run`ボタンを押して、関数の`foo`が再生されることを確認してください。コードはどこにいったのでしょう？ また、Sonic Piは、実行の仕方をどのよ"
"うに知っていたのでしょうか？ Sonic PiはBufferを消したあとでも、あなたが打ち込んだ関数を覚えていて、定義した関数をしっかりと再生してみせたので"
"す。この動作は`define`もしくは`defonce`を使用した時にだけ働く機能です。"

#: 05.5-Functions.md:75
msgid "Parameterised functions"
msgstr "引数の付いた関数"

#: 05.5-Functions.md:77
msgid ""
"You might be interested in knowing that just like you can pass min and max val"
"ues to `rrand`, you can teach your functions to accept arguments. Let's take a"
" look:"
msgstr "最小値と最大値の情報を`rrand`へ渡すように、引数を受け取る関数についても興味を持つかもしれません。ちょっと見てみましょう。"

#: 05.5-Functions.md:81
#, no-wrap
msgid ""
"define :my_player do |n|\n"
"  play n\n"
"end\n"
"my_player 80\n"
"sleep 0.5\n"
"my_player 90"
msgstr ""
"define :my_player do |n|\n"
"  play n\n"
"end\n"
"my_player 80\n"
"sleep 0.5\n"
"my_player 90"

#: 05.5-Functions.md:91
msgid ""
"This isn't very exciting, but it illustrates the point. We've created our own "
"version of `play` called `my_player` which is parameterised."
msgstr ""
"この例はあまり面白いものではありませんが、ポイントとなる点を示しています。ここでは、引数の付いた`my_player`という名前の関数を、`play`の独自"
"のバージョンとして作成しています。"

#: 05.5-Functions.md:94
msgid ""
"The parameters need to go after the `do` of the `define` do/end block, surroun"
"ded by vertical goalposts `|` and separated by commas `,`. You may use any wor"
"ds you want for the parameter names."
msgstr ""
"この引数は`define`で括られた*do/end*ブロックのdoの後に記述する必要があります。引数は、垂直のバー`|`で囲み、複数の引数を扱う場合はカンマ"
" `,`で分割し、引数の名前はどんな言葉でも付けることが出来ます。"

#: 05.5-Functions.md:98
msgid ""
"The magic happens inside the `define` do/end block. You may use the parameter "
"names as if they were real values. In this example I'm playing note `n`. You c"
"an consider the parameters as a kind of promise that when the code runs, they "
"will be replaced with actual values. You do this by passing a parameter to the"
" function when you call it. I do this with `my_player 80` to play note 80. Ins"
"ide the function definition, `n` is now replaced with 80, so `play n` turns in"
"to `play 80`. When I call it again with `my_player 90`, `n` is now replaced wi"
"th 90, so `play n` turns into `play 90`."
msgstr ""
"この魔法は、`define`を使い*do/end*ブロック内で行われます。また、実行されるための値のような変数名を使うことも出来ます。この例で言うと、`n`"
"という値の音符を鳴らしています。引数はコードが起動した際にその領域に記憶されている実際の数値に置き換えられるという約束と考えることができます。あなたが関数を"
"呼び出した際は、この数値を関数に置き換えて実行することが出来るのです。この`my_player 80`というのは、80という音符を鳴らすということです。関数"
"の定義の中で、`n`はすぐに`80`に置き換えられます。そして`play n`は`play 80`となるのです。また次に`my_player 90`という関"
"数を呼び出すと、今度は`n`が`90`に置き換えられ、`play n`は`play 90`として再生されるのです。"

#: 05.5-Functions.md:108
msgid "Let's see a more interesting example:"
msgstr "それではさらにおもしろい例を見てみましょう。"

#: 05.5-Functions.md:110
#, no-wrap
msgid ""
"define :chord_player do |root, repeats| \n"
"  repeats.times do\n"
"    play chord(root, :minor), release: 0.3\n"
"    sleep 0.5\n"
"  end\n"
"end\n"
"chord_player :e3, 2\n"
"sleep 0.5\n"
"chord_player :a3, 3\n"
"chord_player :g3, 4\n"
"sleep 0.5\n"
"chord_player :e3, 3"
msgstr ""
"define :chord_player do |root, repeats| \n"
"  repeats.times do\n"
"    play chord(root, :minor), release: 0.3\n"
"    sleep 0.5\n"
"  end\n"
"end\n"
"chord_player :e3, 2\n"
"sleep 0.5\n"
"chord_player :a3, 3\n"
"chord_player :g3, 4\n"
"sleep 0.5\n"
"chord_player :e3, 3"

#: 05.5-Functions.md:126
msgid ""
"Here I used `repeats` as if it was a number in the line `repeats.times do`. I "
"also used `root` as if it was a note name in my call to `play`."
msgstr ""
"ここでは`repeats.times do`という行の中で1つの数値のように`repeats`が使われます。また、`play`を呼び出した際の音符の名前と同"
"じように`root`が使われています。"

#: 05.5-Functions.md:129
msgid ""
"See how we're able to write something very expressive and easy to read by movi"
"ng a lot of our logic into a function!"
msgstr "関数に多くの処理を移動することによって、コードをとても表現力豊かにかつ読み易く書けることがわかりましたね！"

#: 05.6-Variables.md:1
msgid "5.6 Variables"
msgstr "5.6 変数"

#: 05.6-Variables.md:3
msgid "Variables"
msgstr "変数"

#: 05.6-Variables.md:5
#, fuzzy
msgid ""
"A useful thing to do in your code is to create names for things. Sonic Pi make"
"s this very easy: you write the name you wish to use, an equal sign (`=`), the"
"n the thing you want to remember:"
msgstr ""
"コードを書いていく中で役に立つことは、覚えやすい名前を作成することです。Sonic Piはこれをとても簡単に作ることができます。あなたが使用したいと思う名前"
"に続けて、等号のイコール（`=`）を書き、そのあとに覚えておきたい名前を書きます。"

#: 05.6-Variables.md:9
#, no-wrap
msgid "sample_name = :loop_amen"
msgstr "sample_name = :loop_amen"

#: 05.6-Variables.md:13
msgid ""
"Here, we've 'remembered' the symbol `:loop_amen` in the variable `sample_name`"
". We can now use `sample_name` everywhere we might have used `:loop_amen`. For"
" example:"
msgstr ""
"ここで、`:loop_amen`という記号は変数`sample_name`に'記憶'されました。`:loop_amen`を使いたいところではどこでも`sam"
"ple_name`を使うことが可能です。例えば次のとおりです。"

#: 05.6-Variables.md:17
#, no-wrap
msgid ""
"sample_name = :loop_amen\n"
"sample sample_name"
msgstr ""
"sample_name = :loop_amen\n"
"sample sample_name"

#: 05.6-Variables.md:22
msgid ""
"There are three main reasons for using variables in Sonic Pi: communicating me"
"aning, managing repetition and capturing the results of things."
msgstr "Sonic Piでは変数を使う際、3つの主要な使い方があります。意味の伝達、重複の管理、そして結果の獲得です。"

#: 05.6-Variables.md:26
msgid "Communicating Meaning"
msgstr "意味の伝達"

#: 05.6-Variables.md:28
msgid ""
"When you write code it's easy to just think you're telling the computer how to"
" do stuff - as long as the computer understands it's OK. However, it's importa"
"nt to remember that it's not just the computer that reads the code. Other peop"
"le may read it too and try to understand what's going on. Also, you're likely "
"to read your own code in the future and try to understand what's going on. Alt"
"hough it might seem obvious to you now - it might not be so obvious to others "
"or even your future self!"
msgstr ""
"コードを書くとき、あなたはコンピュータが理解しOKを出してくれることだけを考え、どのようにコンピュータに伝えて動作させるのかを意識するだけであれば、それは簡"
"単な事ですね。しかし、覚えておかなくてはいけない大事なことは、コンピュータがコードを読むということだけではないということです。他の人もそれを読み、何が起こっ"
"ているか理解をしようとするでしょう。あなた自身も将来、自分の書いたコードを見返して、どんなことをしたのか？ 理解する必要がある時が来るかもしれません。たぶん"
"確実にあなたにも他の人にも、そういったことが起こるのです!"

#: 05.6-Variables.md:36
msgid ""
"One way to help others understand what your code is doing is to write comments"
" (as we saw in a previous section). Another is to use meaningful variable name"
"s. Look at this code:"
msgstr ""
"あなたのコードがどのように動いているのか他人が理解をするための1つの方法として、コメントを書く（前章で確認できます）という方法があります。もう1つの方法とし"
"て、理解しやすい変数名を使うという方法があります。次のコードを見てください。"

#: 05.6-Variables.md:40
#, no-wrap
msgid "sleep 1.7533"
msgstr "sleep 1.7533"

#: 05.6-Variables.md:44
msgid ""
"Why does it use the number `1.7533`? Where did this number come from? What doe"
"s it mean? However, look at this code:"
msgstr ""
"上の例だけを見ると、なぜ`1.7533`という数値を使ったのでしょう？ その数値はどこから来たのか？ それは何を意味しているのか？ という疑問がわきます。し"
"かし、次のコードを見てみましょう。"

#: 05.6-Variables.md:47
#, no-wrap
msgid ""
"loop_amen_duration = 1.7533\n"
"sleep loop_amen_duration"
msgstr ""
"loop_amen_duration = 1.7533\n"
"sleep loop_amen_duration"

#: 05.6-Variables.md:52
msgid ""
"Now, it's much clearer what `1.7533` means: it's the duration of the sample `:"
"loop_amen`! Of course, you might say why not simply write:"
msgstr ""
"こう書くとすぐに`1.7533` がサンプル音源`:loop_amen`の長さであるということがわかりますね。もちろん、下記のように一行に書くことも可能です"
"。"

#: 05.6-Variables.md:55
#, no-wrap
msgid "sleep sample_duration(:loop_amen)"
msgstr "sleep sample_duration(:loop_amen)"

#: 05.6-Variables.md:59
msgid "Which, of course, is a very nice way of communicating the intent of the code."
msgstr "どちらを用いたとしても、コードの意味がよりわかりやすいものになりました。"

#: 05.6-Variables.md:62
msgid "Managing Repetition"
msgstr "重複の管理"

#: 05.6-Variables.md:64
msgid ""
"Often you see a lot of repetition in your code and when you want to change thi"
"ngs, you have to change it in a lot of places. Take a look at this code:"
msgstr "コードの中では沢山の重複が頻繁に見られます。また、もし何かを変更したいときは、膨大な場所を変更する必要も出てきます。次のコードをみて下さい。"

#: 05.6-Variables.md:68
#, no-wrap
msgid ""
"sample :loop_amen\n"
"sleep sample_duration(:loop_amen)\n"
"sample :loop_amen, rate: 0.5\n"
"sleep sample_duration(:loop_amen, rate: 0.5)\n"
"sample :loop_amen\n"
"sleep sample_duration(:loop_amen)"
msgstr ""
"sample :loop_amen\n"
"sleep sample_duration(:loop_amen)\n"
"sample :loop_amen, rate: 0.5\n"
"sleep sample_duration(:loop_amen, rate: 0.5)\n"
"sample :loop_amen\n"
"sleep sample_duration(:loop_amen)"

#: 05.6-Variables.md:77
msgid ""
"We're doing a lot of things with `:loop_amen`! What if we wanted to hear what "
"it sounded like with another loop sample such as `:loop_garzul`? We'd have to "
"find and replace all `:loop_amen`s with `:loop_garzul`. That might be fine if "
"you have lots of time - but what if you're performing on stage? Sometimes you "
"don't have the luxury of time - especially if you want to keep people dancing."
msgstr ""
"上のコードは`:loop_amen`で沢山のことをしすぎています！ もし`:loop_garzul`のような他のサンプルのループによる音が聞きたい場合はどう"
"しましょう？ そうするにはすべての`:loop_amen`を探しだして`:loop_garzul`に変更する必要があります。そんな変更ができる沢山の時間があ"
"ればいいんですが…もし仮にあなたがステージの上で演奏している最中だったらどうでしょう？ 特にみんなのダンスを止めないために、変更するためのそんな優雅な時間は"
"ないかもしれません。"

#: 05.6-Variables.md:84
msgid "What if you'd written your code like this:"
msgstr "下記のようなコードを書いたとして、"

#: 05.6-Variables.md:86
#, no-wrap
msgid ""
"sample_name = :loop_amen\n"
"sample sample_name\n"
"sleep sample_duration(sample_name)\n"
"sample sample_name, rate: 0.5\n"
"sleep sample_duration(sample_name, rate: 0.5)\n"
"sample sample_name\n"
"sleep sample_duration(sample_name)"
msgstr ""
"sample_name = :loop_amen\n"
"sample sample_name\n"
"sleep sample_duration(sample_name)\n"
"sample sample_name, rate: 0.5\n"
"sleep sample_duration(sample_name, rate: 0.5)\n"
"sample sample_name\n"
"sleep sample_duration(sample_name)"

#: 05.6-Variables.md:96
msgid ""
"Now, that does exactly the same as above (try it). It also gives us the abilit"
"y to just change one line `sample_name = :loop_amen` to `sample_name = :loop_g"
"arzul` and we change it in many places through the magic of variables."
msgstr ""
"これは先程のコードと同じです（試してみてください）。しかし、`sample_name = :loop_amen`の一行を`sample_name = :lo"
"op_garzul`に変更するだけで多くの箇所を変更できました。そして、それは変数の力によるものです。"

#: 05.6-Variables.md:101
msgid "Capturing Results"
msgstr "結果の獲得"

#: 05.6-Variables.md:103
msgid ""
"Finally, a good motivation for using variables is to capture the results of th"
"ings. For example, you may wish to do things with the duration of a sample:"
msgstr "最後に、変数を使う優れた理由はそのコードの結果の獲得をするということです。例えば、サンプル音源の長さを使って何かを行いたい時など。"

#: 05.6-Variables.md:107
#, no-wrap
msgid "sd = sample_duration(:loop_amen)"
msgstr "sd = sample_duration(:loop_amen)"

#: 05.6-Variables.md:111
msgid "We can now use `sd` anywhere we need the duration of the `:loop_amen` sample."
msgstr "上記のように書くことで、今、`:loop_amen`というサンプルの長さが必要な時、どこにでも`sd`を使うことが出来るようになります。"

#: 05.6-Variables.md:114
msgid ""
"Perhaps more importantly, a variable allows us to capture the result of a call"
" to `play` or `sample`:"
msgstr "おそらくもっと重要なのは、変数は、playやsampleの結果をキャプチャすることができることです。"

#: 05.6-Variables.md:117
#, no-wrap
msgid "s = play 50, release: 8"
msgstr "s = play 50, release: 8"

#: 05.6-Variables.md:121
msgid ""
"Now we have caught and remembered `s` as a variable, which allows us to contro"
"l the synth as it is running:"
msgstr "またこのように書くことで `s` が変数として記憶され、シンセをコントロールできるようになります。"

#: 05.6-Variables.md:124
#, no-wrap
msgid ""
"s = play 50, release: 8\n"
"sleep 2\n"
"control s, note: 62"
msgstr ""
"s = play 50, release: 8\n"
"sleep 2\n"
"control s, note: 62"

#: 05.6-Variables.md:130
msgid "We'll look into controlling synths in more detail in a later section."
msgstr "また、後の章ではもっと詳しくシンセをコントロールすることも学びます。"

#: 05.6-Variables.md:133
msgid "Warning: Variables and Threads"
msgstr "注意：変数とスレッド"

#: 05.6-Variables.md:135
msgid ""
"Whilst variables are great for giving things names and capturing the results o"
"f things, it is important to know that they should typically only be used loca"
"lly within a thread. For example, *don't do this*:"
msgstr ""
"変数はモノに名前を与えたり、ある処理においてどういった結果が返ってくるのか推"
"測するのに役立ちます。ただし、通常、変数はスレッド内で完結するローカル変数と"
"して定義する必要があることを知っておく必要があります。したがって、以下のよう"
"なことをしてはいけません。"

#: 05.6-Variables.md:139
#, no-wrap
msgid ""
"a = (ring 6, 5, 4, 3, 2, 1)\n"
"live_loop :sorted do\n"
"  a = a.sort\n"
"  sleep 0.5\n"
"  puts \"sorted: \", a\n"
"end\n"
"live_loop :shuffled do\n"
"  a = a.shuffle\n"
"  sleep 0.5\n"
"end"
msgstr ""
"a = (ring 6, 5, 4, 3, 2, 1)\n"
"live_loop :sorted do\n"
"  a = a.sort\n"
"  sleep 0.5\n"
"  puts \"sorted: \", a\n"
"end\n"
"live_loop :shuffled do\n"
"  a = a.shuffle\n"
"  sleep 0.5\n"
"end"

#: 05.6-Variables.md:154
msgid ""
"In the above example we assign a ring of numbers to a variable `a` and then us"
"ed it within two separate `live_loop`s. In the first live loop every `0.5`s we"
" sort the ring (to `(ring 1, 2, 3, 4, 5, 6)`) and then print it out to the log"
". If you run the code, you'll find that the printed list *is not always sorted"
"!*. This may surprise you - especially that sometimes the list is printed as s"
"orted, and sometimes it is not. This is called non-deterministic behaviour and"
" is the result of a rather nasty problem called a race-condition. The problem "
"is due to the fact that the second live loop is also manipulating the list (in"
" this case shuffling it) and by the time the list is printed, sometimes it has"
" just been sorted and sometimes it has just been shuffled. Both live loops are"
" racing to do something different to the same variable and every time round a "
"different loop 'wins'."
msgstr ""
"上の例では変数`a`に数字のリングを割り当て、2つの別々の`live_loop`の中でそれを"
"利用しました。最初のライブループでは0.5秒ごとにリング `(ring 1, 2, 3, 4, 5, 6"
")`をソートしてログにプリント出力しています。コードを実行すれば、プリントされ"
"たリストが*いつもソートされているわけではない*ことがわかるでしょう。もしかす"
"ると、リストがソートされていたり、されていなかったりすることにびっくりするか"
"もしれません。これは非決定的挙動と呼ばれるもので、レースコンディションという"
"やっかいな問題の結果でもあります。その問題の原因は2つ目のライブループもまたリ"
"ストを操作(この例ではリストをシャッフル)していることにあり、リストはプリント"
"される時に、ちょうどソートされた状態であることもあれば、ちょうどシャッフルさ"
"れた状態であることもあるのです。2つのライブループが同じ変数に対して別々のこと"
"をしようと競い合っていて、毎回どちらか異なる方が勝っているということです。"

#: 05.6-Variables.md:168
msgid ""
"There are two solutions to this. Firstly, *don't use the same variable in mult"
"iple live loops or threads*. For example, the following code will always print"
" a sorted list as each live loop has its own separate variable:"
msgstr ""
"これに対して2つの解決策があります。　1つは、*複数のライブループやスレッドで同じ変数を使わない*ことです。例えば、以下のコードはそれぞれのライブループが"
"別々の変数を持っているので常にソートされたリストがプリントされます。"

#: 05.6-Variables.md:173
#, no-wrap
msgid ""
"live_loop :shuffled do\n"
"  a = (ring 6, 5, 4, 3, 2, 1)\n"
"  a = a.shuffle\n"
"  sleep 0.5\n"
"end\n"
"live_loop :sorted do\n"
"  a = (ring 6, 5, 4, 3, 2, 1)\n"
"  a = a.sort\n"
"  sleep 0.5\n"
"  puts \"sorted: \", a\n"
"end"
msgstr ""
"live_loop :shuffled do\n"
"  a = (ring 6, 5, 4, 3, 2, 1)\n"
"  a = a.shuffle\n"
"  sleep 0.5\n"
"end\n"
"live_loop :sorted do\n"
"  a = (ring 6, 5, 4, 3, 2, 1)\n"
"  a = a.sort\n"
"  sleep 0.5\n"
"  puts \"sorted: \", a\n"
"end"

#: 05.6-Variables.md:188
msgid ""
"However, sometimes we do want to share things across threads. For example, the"
" current key, BPM, synth etc. In these cases, the solution is to use Sonic Pi'"
"s special thread-safe state system via the fns `get` and `set`. This is discus"
"sed later on in section 10."
msgstr ""
"しかし、スレッド間で何かを共有したいこともあります。例えば、現在のキーやBPM、"
"シンセなどです。このような場合には、Sonic "
"Piの特別なスレッドセーフな状態管理システム、`get` と `set` という関数を使うこ"
"とで出来ます。これについては、後ほどセクション10で説明します。"

#: 05.7-Thread-Synchronisation.md:1
msgid "5.7 Thread Synchronisation"
msgstr "5.7 スレッドの同期"

#: 05.7-Thread-Synchronisation.md:3
msgid "Thread Synchronisation"
msgstr "スレッドの同期"

#: 05.7-Thread-Synchronisation.md:5
msgid ""
"Once you have become sufficiently advanced live coding with a number of functi"
"ons and threads simultaneously, you've probably noticed that it's pretty easy "
"to make a mistake in one of the threads which kills it. That's no big deal, be"
"cause you can easily restart the thread by hitting Run. However, when you rest"
"art the thread it is now *out of time* with the original threads."
msgstr ""
"一度、関数やスレッドを使用したとても高度なライブコーディングを行うと、あるス"
"レッドが止まってしまうような間違いがとても容易に発生することに気づいたかもし"
"れませんね。`Run`ボタンを押してスレッドを再スタートさせることは容易にできるの"
"で、それは大した問題ではありません。しかし、スレッドを再スタートさせるときに"
"は、元々のスレッドと*時間がずれる*ことになります。"

#: 05.7-Thread-Synchronisation.md:12
msgid "Inherited Time"
msgstr "時間の継承"

#: 05.7-Thread-Synchronisation.md:14
msgid ""
"As we discussed earlier, new threads created with `in_thread` inherit all of t"
"he settings from the parent thread. This includes the current time. This means"
" that threads are always in time with each other when started simultaneously."
msgstr ""
"以前話した時に、新しいスレッドが`in_thread`として作られると元のスレッドのすべての設定が継承されることを学びました。これは現在の時間を含んでいます"
"。つまり、スレッドが同時にスタートするときには常に他のスレッドと同期していることを意味しています。"

#: 05.7-Thread-Synchronisation.md:19
msgid ""
"However, when you start a thread on its own it starts with its own time which "
"is unlikely to be in sync with any of the other currently running threads."
msgstr "しかし、あるスレッドを独自のタイミングで起動したときは、現在実行中の他のスレッドと同期していることはほとんどないでしょう。"

#: 05.7-Thread-Synchronisation.md:23
msgid "Cue and Sync"
msgstr "CueとSync"

#: 05.7-Thread-Synchronisation.md:25
msgid ""
"Sonic Pi provides a solution to this problem with the functions `cue` and `syn"
"c`."
msgstr "Sonic Pi は`cue`と`sync`という関数を使ってこの問題の解決方法を提供します。"

#: 05.7-Thread-Synchronisation.md:28
msgid ""
"`cue` allows us to send out heartbeat messages to all other threads. By defaul"
"t the other threads aren't interested and ignore these heartbeat messages. How"
"ever, you can easily register interest with the `sync` function."
msgstr ""
"`cue`はすべての他のスレッドに向けてビートメッセージを送ることができます。初期状態の他のスレッドでは、これらのビートのメッセージは関係付けられず、無視さ"
"れます。しかし、`sync`関数を使えば、あなたは簡単にこの関連付けを登録することができるのです。"

#: 05.7-Thread-Synchronisation.md:33
msgid ""
"The important thing to be aware of is that `sync` is similar to `sleep` in tha"
"t it stops the current thread from doing anything for a period of time. Howeve"
"r, with `sleep` you specify how long you want to wait while with `sync` you do"
"n't know how long you will wait - as `sync` waits for the next `cue` from anot"
"her thread which may be soon or a long time away."
msgstr ""
"`sync`という機能は、一定の時間、実行中のスレッドを止める`sleep`という関数と非常に似ていることに気づくことが重要です。しかし、`sleep`では"
"どのくらい休止させるかを決めることができましたが、`sync`ではそれを決めることができず、`sync`は長さに関わらず、次の`cue` が出てくるまで待つ"
"のです。"

#: 05.7-Thread-Synchronisation.md:40
msgid "Let's explore this in a little more detail:"
msgstr "それでは、もうちょっと詳しく見ていきましょう。"

#: 05.7-Thread-Synchronisation.md:42
#, no-wrap
msgid ""
"in_thread do\n"
"  loop do\n"
"    cue :tick\n"
"    sleep 1\n"
"  end\n"
"end\n"
"in_thread do\n"
"  loop do\n"
"    sync :tick\n"
"    sample :drum_heavy_kick\n"
"  end\n"
"end"
msgstr ""
"in_thread do\n"
"  loop do\n"
"    cue :tick\n"
"    sleep 1\n"
"  end\n"
"end\n"
"in_thread do\n"
"  loop do\n"
"    sync :tick\n"
"    sample :drum_heavy_kick\n"
"  end\n"
"end"

#: 05.7-Thread-Synchronisation.md:58
msgid ""
"Here we have two threads - one acting like a metronome, not playing any sounds"
" but sending out `:tick` heartbeat messages every beat. The second thread is s"
"ynchronising on `tick` messages and when it receives one it inherits the time "
"of the `cue` thread and continues running."
msgstr ""
"ここでは2つのスレッドが使われています。1つは、音は鳴りませんがメトロノームのような機能として1秒ごとに`:tick`というビートメッセージを送っています。"
"2つ目のスレッドは、`tick`というビートメッセージと同期し、その際に`cue`のスレッドの時間の情報を継承して実行を続けます。"

#: 05.7-Thread-Synchronisation.md:63
msgid ""
"As a result, we will hear the `:drum_heavy_kick` sample exactly when the other"
" thread sends the `:tick` message, even if the two threads didn't start their "
"execution at the same time:"
msgstr ""
"この結果、`:drum_heavy_kick`のサンプルは、たとえ同時に実行されていない2つのスレッドであったとしても、他のスレッドが`:tick`のメッセ"
"ージを送信したタイミングで、ぴったりと聴くことができるでしょう。"

#: 05.7-Thread-Synchronisation.md:67
#, no-wrap
msgid ""
"in_thread do\n"
"  loop do\n"
"    cue :tick\n"
"    sleep 1\n"
"  end\n"
"end\n"
"sleep(0.3)\n"
"in_thread do\n"
"  loop do\n"
"    sync :tick\n"
"    sample :drum_heavy_kick\n"
"  end\n"
"end"
msgstr ""
"in_thread do\n"
"  loop do\n"
"    cue :tick\n"
"    sleep 1\n"
"  end\n"
"end\n"
"sleep(0.3)\n"
"in_thread do\n"
"  loop do\n"
"    sync :tick\n"
"    sample :drum_heavy_kick\n"
"  end\n"
"end"

#: 05.7-Thread-Synchronisation.md:85
msgid ""
"That naughty `sleep` call would typically make the second thread out of phase "
"with the first. However, as we're using `cue` and `sync`, we automatically syn"
"c the threads bypassing any accidental timing offsets."
msgstr ""
"このちょっとやっかいな`sleep(0.3)`は、1つめのスレッドとは時間がずれた2つめのスレッドを作り出してしまいます。しかしながら、`cue`や`syn"
"c`を使えば、タイミングがずれてしまうようなアクシデントを回避してくれます。"

#: 05.7-Thread-Synchronisation.md:90
msgid "Cue Names"
msgstr "Cueの名前"

#: 05.7-Thread-Synchronisation.md:92
msgid ""
"You are free to use whatever name you'd like for your `cue` messages - not jus"
"t `:tick`. You just need to ensure that any other threads are `sync`ing on the"
" correct name - otherwise they'll be waiting for ever (or at least until you p"
"ress the Stop button)."
msgstr ""
"`cue`には`:tick`以外のどんな好きな名前でも付けられます。その際には他のスレッドと同期させるために必ず正しい名前を使用する必要があります。もし違っ"
"た場合、永遠に（もしくはストップボタンを押すまで）それは`cue`のメッセージを待ち続けることになります。"

#: 05.7-Thread-Synchronisation.md:97
msgid "Let's play with a few `cue` names:"
msgstr "それでは`cue`の名前付けを見てみましょう。"

#: 05.7-Thread-Synchronisation.md:99
#, no-wrap
msgid ""
"in_thread do\n"
"  loop do \n"
"    cue [:foo, :bar, :baz].choose\n"
"    sleep 0.5\n"
"  end\n"
"end\n"
"in_thread do\n"
"  loop do \n"
"    sync :foo \n"
"    sample :elec_beep\n"
"  end\n"
"end\n"
"in_thread do\n"
"  loop do\n"
"    sync :bar\n"
"    sample :elec_flip\n"
"  end\n"
"end\n"
"in_thread do\n"
"  loop do\n"
"    sync :baz\n"
"    sample :elec_blup\n"
"  end\n"
"end"
msgstr ""
"in_thread do\n"
"  loop do \n"
"    cue [:foo, :bar, :baz].choose\n"
"    sleep 0.5\n"
"  end\n"
"end\n"
"in_thread do\n"
"  loop do \n"
"    sync :foo \n"
"    sample :elec_beep\n"
"  end\n"
"end\n"
"in_thread do\n"
"  loop do\n"
"    sync :bar\n"
"    sample :elec_flip\n"
"  end\n"
"end\n"
"in_thread do\n"
"  loop do\n"
"    sync :baz\n"
"    sample :elec_blup\n"
"  end\n"
"end"

#: 05.7-Thread-Synchronisation.md:129
msgid ""
"Here we have a main `cue` loop which is randomly sending one of the heartbeat "
"names `:foo`, `:bar` or `:baz`. We then also have three loop threads syncing o"
"n each of those names independently and then playing a different sample. The n"
"et effect is that we hear a sound every 0.5 beats as each of the `sync` thread"
"s is randomly synced with the `cue` thread and plays its sample."
msgstr ""
"ここではメインの`cue`ループでビートメッセージをランダムに`:foo`と`:bar`、`:baz`に送るようにしています。それから3つのスレッドがそれぞ"
"れ独自に同期して、それぞれ異なるサンプルの音を再生します。実際には、`sync`スレッドとして用意した3つのスレッドのいずれかが`cue`スレッドとランダム"
"に同期し、0.5秒毎にサンプル音の再生を聴くことができるでしょう。"

#: 05.7-Thread-Synchronisation.md:136
msgid ""
"This of course also works if you order the threads in reverse as the `sync` th"
"reads will simply sit and wait for the next `cue`."
msgstr "逆に`sync`スレッドを単に次の`cue`まで待たせるようにしても、もちろんそれは動作します。"

#: 06-FX.md:1
msgid "6 FX"
msgstr "6 エフェクト"

#: 06-FX.md:3
msgid "Studio FX"
msgstr "スタジオ・エフェクト"

#: 06-FX.md:5
msgid ""
"One of the most rewarding and fun aspects of Sonic Pi is the ability to easily"
" add studio effects to your sounds. For example, you may wish to add some reve"
"rb to parts of your piece, or some echo or perhaps even distort or wobble your"
" basslines."
msgstr ""
"Sonic Piには、あなたの作ったサウンドに簡単にスタジオ·エフェクトを追加できるという最もやりがいのある楽しい側面があります。たとえば、部分的にリバーブ"
"を追加したり、エコーやディストーション（歪み）、ワブルベース（ベース音にフィルタLFOを掛け、断続的な音にすること）を加えることができます。"

#: 06-FX.md:10
msgid ""
"Sonic Pi provides a very simple yet powerful way of adding FX. It even allows "
"you to chain them (so you can pass your sounds through distortion, then echo a"
"nd then reverb) and also control each individual FX unit with opts (in a simil"
"ar way to giving params to synths and samples). You can even modify the opts o"
"f the FX whilst it's still running. So, for example, you could increase the re"
"verb on your bass throughout the track..."
msgstr ""
"Sonic Piには、エフェクトを追加する非常にシンプルで強力な方法があります。さらに、それをチェイン（連結）させることができ（これにより、ディストーション"
"（歪み）を通し、その後エコー、さらにリバーブということができます）、またエフェクトユニットのオプションを（シンセやサンプルにオプションを与えるのと同じように"
"）個別に制御することもできます。さらに、エフェクトが実行されている間にも、オプションを変更することができます。これにより、例えば、トラック全体を通してベース"
"のリバーブを強くしていくといったことも可能です。"

#: 06-FX.md:18
msgid "Guitar Pedals"
msgstr "ギター・エフェクター"

#: 06-FX.md:20
msgid ""
"If all of this sounds a bit complicated, don't worry. Once you play around wit"
"h it a little, it will all become quite clear. Before you do though, a simple "
"analogy is that of guitar FX pedals. There are many kinds of FX pedals you can"
" buy. Some add reverb, others distort etc. A guitarist will plug his or her gu"
"itar into one FX pedal - i.e. distortion -, then take another cable and connec"
"t (chain) a reverb pedal. The output of the reverb pedal can then be plugged i"
"nto the amplifier:"
msgstr ""
"もし、この話が少し複雑に聞こえる場合でも、心配は無用です。一度、少し触れてみれば、すぐに理解することができることでしょう。いわば、ギターのエフェクターのよう"
"なものをイメージしてください。購入できるギターエフェクターには多くの種類がありますが、リバーブ、ディストーションなど幾つかを数珠繋ぎに追加することができます"
"。ギタリストは、自分のギターにエフェクターの1つ（ディストーションなど）を接続し、そして別のケーブルでリバーブエフェクターに繋ぎます。そしてリバーブエフェク"
"ターの出口はギターアンプに繋ぐことができるわけです。"

#: 06-FX.md:29
#, no-wrap
msgid "Guitar -> Distortion -> Reverb -> Amplifier"
msgstr "ギター -> ディストーション -> リバーブ -> アンプ"

#: 06-FX.md:33
msgid ""
"This is called FX chaining. Sonic Pi supports exactly this. Additionally, each"
" pedal often has dials and sliders to allow you to control how much distortion"
", reverb, echo etc. to apply. Sonic Pi also supports this kind of control. Fin"
"ally, you can imagine a guitarist playing whilst someone plays with the FX con"
"trols whilst they're playing. Sonic Pi also supports this - but instead of nee"
"ding someone else to control things for you, that's where the computer steps i"
"n."
msgstr ""
"これをエフェクトチェインと呼びます。Sonic Piは正にこれをサポートしています。さらに、ディストーション、リバーブ、エコーなどのエフェクターの多くは、ど"
"のくらいエフェクトを加えるのか、制御できるようなダイヤルやスライダを持っていて、Sonic Piもこの種の制御をサポートしているということです。最終的に、あ"
"なたはギタリストがエフェクターを使いながらギターを演奏する姿を想像することができていることでしょう。ただ、Sonic Piでは、それをコントロールするために"
"他の何かを必要としません。それはコンピュータが代役を務めているのです。"

#: 06-FX.md:42
msgid "Let's explore FX!"
msgstr "さあ、エフェクトを探究していきましょう！"

#: 06.1-Adding-FX.md:1
msgid "6.1 Adding FX"
msgstr "6.1 エフェクトの追加"

#: 06.1-Adding-FX.md:3 13.1-Sound-In.md:26
msgid "Adding FX"
msgstr "エフェクトの追加"

#: 06.1-Adding-FX.md:5
msgid ""
"In this section we'll look at a couple of FX: reverb and echo. We'll see how t"
"o use them, how to control their opts and how to chain them."
msgstr ""
"このセクションでは、エフェクト「リバーブとエコー」の組み合わせを見ていきます。それらをどのようにチェイン接続するか、どのように制御するのか、これらの使用方法"
"について説明します。"

#: 06.1-Adding-FX.md:9
msgid ""
"Sonic Pi's FX system uses blocks. So if you haven't read section 5.1 you might"
" want to take a quick look and then head back."
msgstr "Sonic Piのエフェクトシステムは、ブロックを使用します。セクション5.1を読んでいなければ、戻って目を通してください。"

#: 06.1-Adding-FX.md:12
msgid "Reverb"
msgstr "リバーブ"

#: 06.1-Adding-FX.md:14
msgid ""
"If we want to use reverb we write `with_fx :reverb` as the special code to our"
" block like this:"
msgstr "リバーブを使用する場合、次のように特殊なコード`with_fx :reverb`をブロックに書きます。"

#: 06.1-Adding-FX.md:17
#, no-wrap
msgid ""
"with_fx :reverb do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"
msgstr ""
"with_fx :reverb do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"

#: 06.1-Adding-FX.md:27
msgid ""
"Now play this code and you'll hear it played with reverb. It sounds good, does"
"n't it! Everything sounds pretty nice with reverb."
msgstr "早速コードを実行してリバーブを聞いてみましょう。いいでしょ！ 音全体が残響効果で素晴らしくなります。"

#: 06.1-Adding-FX.md:30
msgid "Now let's look what happens if we have code outside the do/end block:"
msgstr "さあ、次はブロックの外にコードを書いて何が起こるか見てみましょう。"

#: 06.1-Adding-FX.md:32
#, no-wrap
msgid ""
"with_fx :reverb do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end\n"
"sleep 1\n"
"play 55"
msgstr ""
"with_fx :reverb do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end\n"
"sleep 1\n"
"play 55"

#: 06.1-Adding-FX.md:45
msgid ""
"Notice how the final `play 55` isn't played with reverb. This is because it is"
" *outside* the do/end block, so it isn't captured by the reverb FX."
msgstr "どうして最後の`play 55`にリバーブが適用されないのでしょうか。それはブロックの*外部*に書かれているため、リバーブエフェクトは適応されないのです。"

#: 06.1-Adding-FX.md:48
msgid ""
"Similarly, if you make sounds before the do/end block, they also won't be capt"
"ured:"
msgstr "*do/end*ブロックの手前で音を生成する場合も同様にリバーブは適用されません。"

#: 06.1-Adding-FX.md:51
#, no-wrap
msgid ""
"play 55\n"
"sleep 1\n"
"with_fx :reverb do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end\n"
"sleep 1\n"
"play 55"
msgstr ""
"play 55\n"
"sleep 1\n"
"with_fx :reverb do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end\n"
"sleep 1\n"
"play 55"

#: 06.1-Adding-FX.md:67
msgid "Echo"
msgstr "Echo：エコー"

#: 06.1-Adding-FX.md:69
msgid "There are many FX to choose from. How about some echo?"
msgstr "選択できるエフェクトは他にもたくさんあります。エコーはどうでしょうか?"

#: 06.1-Adding-FX.md:71
#, no-wrap
msgid ""
"with_fx :echo do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"
msgstr ""
"with_fx :echo do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"

#: 06.1-Adding-FX.md:81
msgid ""
"One of the powerful aspects of Sonic Pi's FX blocks is that they may be passed"
" opts similar to opts we've already seen with `play` and `sample`. For example"
" a fun echo opt to play with is `phase:` which represents the duration of a gi"
"ven echo in beats. Let's make the echo slower:"
msgstr ""
"Sonic Piのエフェクトブロックの強力な側面の1つは、既に`play`と`sample`で見てきたオプションと同様のオプションが渡されることです。たとえ"
"ば、エコーの楽しいオプションは、拍単位で遅れの長さを示す`phase`があります。下記のコードで、エコーの遅れをゆっくりにしてみましょう。"

#: 06.1-Adding-FX.md:87
#, no-wrap
msgid ""
"with_fx :echo, phase: 0.5 do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"
msgstr ""
"with_fx :echo, phase: 0.5 do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"

#: 06.1-Adding-FX.md:97
msgid "Let's also make the echo faster:"
msgstr "エコーの遅れを早くしてみましょう。"

#: 06.1-Adding-FX.md:99
#, no-wrap
msgid ""
"with_fx :echo, phase: 0.125 do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"
msgstr ""
"with_fx :echo, phase: 0.125 do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"

#: 06.1-Adding-FX.md:109
msgid ""
"Let's make the echo take longer to fade away by setting the `decay:` time to 8"
" beats:"
msgstr "エコーが8拍の時間でフェードアウトする様に、`decay:`を設定してみましょう。"

#: 06.1-Adding-FX.md:112
#, no-wrap
msgid ""
"with_fx :echo, phase: 0.5, decay: 8 do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"
msgstr ""
"with_fx :echo, phase: 0.5, decay: 8 do\n"
"  play 50\n"
"  sleep 0.5\n"
"  sample :elec_plip\n"
"  sleep 0.5\n"
"  play 62\n"
"end"

#: 06.1-Adding-FX.md:122
msgid "Nesting FX"
msgstr "エフェクトの入れ子"

#: 06.1-Adding-FX.md:124
msgid ""
"One of the most powerful aspects of the FX blocks is that you can nest them. T"
"his allows you to very easily chain FX together. For example, what if you want"
"ed to play some code with echo and then with reverb? Easy, just put one inside"
" the other:"
msgstr ""
"エフェクトブロックで最も強力な側面の1つは、入れ子ができるということです。これはとても簡単にエフェクト同士を連結することができます。たとえば、あるコードにエ"
"コーとリバーブを掛けたい場合どうしますか？ その答えは単純です。1つのエフェクトの内側にもう一方を配置するだけです。"

#: 06.1-Adding-FX.md:129
#, no-wrap
msgid ""
"with_fx :reverb do\n"
"  with_fx :echo, phase: 0.5, decay: 8 do\n"
"    play 50\n"
"    sleep 0.5\n"
"    sample :elec_blup\n"
"    sleep 0.5\n"
"    play 62\n"
"  end\n"
"end"
msgstr ""
"with_fx :reverb do\n"
"  with_fx :echo, phase: 0.5, decay: 8 do\n"
"    play 50\n"
"    sleep 0.5\n"
"    sample :elec_blup\n"
"    sleep 0.5\n"
"    play 62\n"
"  end\n"
"end"

#: 06.1-Adding-FX.md:141
msgid ""
"Think about the audio flowing from the inside out. The sound of all the code w"
"ithin the inner do/end block such as `play 50` is first sent to the echo FX an"
"d the sound of the echo FX is in turn sent out to the reverb FX."
msgstr ""
"オーディオの流れについて内側から外側へ追ってみましょう。`play 50`を含む`block`の*do/end*ブロック内のコード全ては、最初にエコーエフェ"
"クトに送られ、その音がリバーブエフェクトへと順に送られていきます。"

#: 06.1-Adding-FX.md:146
msgid ""
"We may use very deep nestings for crazy results. However, be warned, the FX ca"
"n use a lot of resources and when you nest them you're effectively running mul"
"tiple FX simultaneously. So be sparing with your use of FX especially on low p"
"owered platforms such as the Raspberry Pi."
msgstr ""
"クレイジーなサウンドを得るために非常に深く入れ子を使用することができます。しかし、一度にたくさんのエフェクトを入れ子で実行すると多くのリソースを必要とするた"
"め、注意してください。そのため、特にRaspberry Piのような低電力供給のプラットフォームではエフェクトの使用を節約することも必要です。"

#: 06.1-Adding-FX.md:151
msgid "Discovering FX"
msgstr "エフェクターの発見"

#: 06.1-Adding-FX.md:153
msgid ""
"Sonic Pi ships with a large number of FX for you to play with. To find out whi"
"ch ones are available, click on FX in the far left of this help system and you"
"'ll see a list of available options. Here's a list of some of my favourites:"
msgstr ""
"Sonic Piは、あなたが演奏するためにたくさんのエフェクトを搭載しています。どういったエフェクトが使えるのかを見つけ出すためには、ヘルプシステム画面の下"
"にある`エフェクト`ボタンをクリックし、利用可能なリストを見てください。ここに私のお気に入りを記載しておきます。"

#: 06.1-Adding-FX.md:158
msgid "wobble,"
msgstr "wobble,"

#: 06.1-Adding-FX.md:159
msgid "reverb,"
msgstr "reverb,"

#: 06.1-Adding-FX.md:160
msgid "echo,"
msgstr "echo,"

#: 06.1-Adding-FX.md:161
msgid "distortion,"
msgstr "distortion,"

#: 06.1-Adding-FX.md:162
msgid "slicer"
msgstr "slicer"

#: 06.1-Adding-FX.md:164
msgid "Now go crazy and add FX everywhere for some amazing new sounds!"
msgstr "さあ、エフェクトを追加して驚きの新しいサウンドの虜となってください！"

#: 06.2-FX-in-Practice.md:1
msgid "6.2 FX in Practice"
msgstr "6.2 エフェクトの実践"

#: 06.2-FX-in-Practice.md:3
msgid "FX in Practice"
msgstr "エフェクトの実践"

#: 06.2-FX-in-Practice.md:5
msgid ""
"Although they look deceptively simple on the outside, FX are actually quite co"
"mplex beasts internally. Their simplicity often entices people to overuse them"
" in their pieces. This may be fine if you have a powerful machine, but if - li"
"ke me - you use a Raspberry Pi to jam with, you need to be careful about how m"
"uch work you ask it to do if you want to ensure the beats keep flowing."
msgstr ""
"エフェクトの外観は一見シンプルですが、実際には内部は異常に複雑なモンスターです。そのシンプルさは、しばしば、この機能を酷使させようと誘惑します。もしもあなた"
"が強力なマシンを持っている場合は問題は無いかもしれませんが、Raspberry Piで動作させる場合、確実にビートを刻み続けるようにしたいのであれば、どのく"
"らいの負荷をかけているのか注意する必要があります。"

#: 06.2-FX-in-Practice.md:12
msgid "Consider this code:"
msgstr "このコードを考えてみましょう。"

#: 06.2-FX-in-Practice.md:14
#, no-wrap
msgid ""
"loop do\n"
"  with_fx :reverb do\n"
"    play 60, release: 0.1\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"loop do\n"
"  with_fx :reverb do\n"
"    play 60, release: 0.1\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: 06.2-FX-in-Practice.md:23
msgid ""
"In this code we're playing note 60 with a very short release time, so it's a s"
"hort note. We also want reverb so we've wrapped it in a reverb block. All good"
" so far. Except..."
msgstr ""
"このコードは非常に短いリリース時間で音符`60`を演奏しています。そして、リバーブを加えたいために、コードをリバーブで囲んでいます。問題はなさそうには見えま"
"すが…。"

#: 06.2-FX-in-Practice.md:27
msgid ""
"Let's look at what the code does. First we have a `loop` which means everythin"
"g inside of it is repeated forever. Next we have a `with_fx` block. This means"
" we will create a new reverb FX *every time we loop*. This is like having a se"
"parate FX reverb pedal for every time you pluck a string on a guitar. It's coo"
"l that you can do this, but it's not always what you want. For example, this c"
"ode will struggle to run nicely on a Raspberry Pi. All the work of creating th"
"e reverb and then waiting until it needs to be stopped and removed is all hand"
"led by `with_fx` for you, but this takes CPU power which may be precious."
msgstr ""
"コードが何をするかを見ていきましょう。まず、`loop`は内側のすべてが永遠に繰り返すことを意味します。次に、`with_fx`ブロックがあります。これはル"
"ープが繰り返される度に、新しいリバーブエフェクトを作成することを意味します。ギターの弦を弾くたびに別々のリバーブエフェクターを用意して演奏しているようなもの"
"です。そんなことができたらかっこいいかもしれませんが、それはあなたが望むものとは限らないということです。たとえば、Raspberry Piでこのコードを実行"
"させるためにはとても労力を要します。リバーブは`with_fx`によって制御され、停止か消去されるまで、生成され続け、スム−ズな演奏に必要とする大切なCPU"
"パワーを奪うことになりかねません。"

#: 06.2-FX-in-Practice.md:37
msgid ""
"How do we make it more similar to a traditional setup where our guitarist has "
"just *one* reverb pedal which all sounds pass through? Simple:"
msgstr "ギタリストのように、すべての音が1つのリバーブエフェクターを通る従来の設定と同様の流れを作るには、どうしたら良いでしょうか？ とてもシンプルです。"

#: 06.2-FX-in-Practice.md:41
#, no-wrap
msgid ""
"with_fx :reverb do\n"
"  loop do\n"
"    play 60, release: 0.1\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"with_fx :reverb do\n"
"  loop do\n"
"    play 60, release: 0.1\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: 06.2-FX-in-Practice.md:50
msgid ""
"We put our loop *inside* the `with_fx` block. This way we only create a single"
" reverb for all notes played in our loop. This code is a lot more efficient an"
"d would work fine on a Raspberry Pi."
msgstr ""
"`with_fx` ブロックの*内部*に`loop`を配置します。この方法では、ループ内すべての音符の再生にリバーブを1つだけ作成します。このコードは効率的"
"で、Raspberry Piで正常に動作します。"

#: 06.2-FX-in-Practice.md:54
msgid "A compromise is to use `with_fx` over an iteration within a loop:"
msgstr "`loop`内の繰り返しの上位に`with_fx`を使うことで折り合いを付けます。"

#: 06.2-FX-in-Practice.md:56
#, no-wrap
msgid ""
"loop do\n"
"  with_fx :reverb do\n"
"    16.times do\n"
"      play 60, release: 0.1\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end"
msgstr ""
"loop do\n"
"  with_fx :reverb do\n"
"    16.times do\n"
"      play 60, release: 0.1\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end"

#: 06.2-FX-in-Practice.md:67
msgid ""
"This way we've lifted the `with_fx` out of the inner part of the `loop` and we"
"'re now creating a new reverb every 16 notes."
msgstr "`loop`の外部に`with_fx`を引き上げることで、16音符ごとに新しいリバーブを作成しています。"

#: 06.2-FX-in-Practice.md:70
msgid ""
"This is such a common pattern that `with_fx` supports an opt to do exactly thi"
"s but without having to write the `16.times` block:"
msgstr "このようなパターンは一般的なので、`16.times`のブロックを書かずに全く同じ動作をするオプションを`with_fx`はサポートしています。"

#: 06.2-FX-in-Practice.md:73
#, no-wrap
msgid ""
"loop do\n"
"  with_fx :reverb, reps: 16 do\n"
"    play 60, release: 0.1\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"loop do\n"
"  with_fx :reverb, reps: 16 do\n"
"    play 60, release: 0.1\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: 06.2-FX-in-Practice.md:82
msgid ""
"Both the `reps: 16` and `16.times do` examples will behave identically. The `r"
"eps: 16` essentially repeats the code in the `do/end` block 16 times so you ca"
"n use them both interchangeably and choose the one that feels best for you."
msgstr ""
"`reps: 16`の例も`16.times do`の例も同様に振る舞います。`reps: 16`は`do/end`のブロックを16回繰り返すので、どちらも"
"交換可能に使うことができ、どちらか好きな方を選ぶことができます。"

#: 06.2-FX-in-Practice.md:87
msgid ""
"Remember, there are no mistakes, just possibilities. However, some of these ap"
"proaches will have a different sound and also different performance characteri"
"stics. So play around and use the approach that sounds best to you whilst also"
" working within the performance constraints of your platform."
msgstr ""
"「間違いはない、あるのはただ可能性だけ」と言ったのを思い出してください。しかしながら、これらの異なるアプローチからは、異なるサウンド、また異なる性能をもたら"
"します。あなたのプラットフォームの性能の制約の中で、最も良いと思うアプローチを使いながら演奏するようにしましょう。"

#: 07-Control.md:1
msgid "7 Control"
msgstr "7 コントロール"

#: 07-Control.md:3
msgid "Controlling running sounds"
msgstr "演奏中のサウンド制御"

#: 07-Control.md:5
msgid ""
"So far we've looked at how you can trigger synths and samples, and also how to"
" change their default opts such as amplitude, pan, envelope settings and more."
" Each sound triggered is essentially its own sound with its own list of option"
"s set for the duration of the sound."
msgstr ""
"これまでの章では、どのようにシンセやサンプルを扱い、アンプ（増幅）、パン、エンベロープなどのオプションを変更するのかを見てきました。呼び出された個々の音には"
"、元来、音の継続時間を設定するデュレーションオプションが備わっています。"

#: 07-Control.md:11
msgid ""
"Wouldn't it also be cool if you could change a sound's opts whilst it's still "
"playing, just like you might bend a string of a guitar whilst it's still vibra"
"ting?"
msgstr "もしも演奏中にギターの弦を歪めビブラートさせるように、オプションを変更できたなら、それってクールではないでしょうか？"

#: 07-Control.md:15
msgid "You're in luck - this section will show you how to do exactly this."
msgstr "あなたは幸運です - このセクションでは、まさしくそれをどのように行うのかを紹介します。"

#: 07.1-Controlling-Running-Synths.md:1
msgid "7.1 Controlling Running Synths"
msgstr "7.1 演奏中のシンセ制御"

#: 07.1-Controlling-Running-Synths.md:3
msgid "Controlling Running Synths"
msgstr "演奏中のシンセ制御"

#: 07.1-Controlling-Running-Synths.md:5
msgid ""
"So far we've only concerned ourselves with triggering new sounds and FX. Howev"
"er, Sonic Pi gives us the ability to manipulate and control currently running "
"sounds. We do this by using a variable to capture a reference to a synth:"
msgstr ""
"これまでは、新しいサウンドとエフェクトを引き起こす方法についてだけ見てきましたが、Sonic Piは、演奏中の音を操り、処理する機能を備えています。次のコー"
"ドのように、シンセの参照を取得するために変数を使用してこれを実現します。"

#: 07.1-Controlling-Running-Synths.md:10
#, no-wrap
msgid "s = play 60, release: 5"
msgstr "s = play 60, release: 5"

#: 07.1-Controlling-Running-Synths.md:14
msgid ""
"Here, we have a run-local variable `s` which represents the synth playing note"
" 60. Note that this is *run-local* - you can't access it from other runs like "
"functions."
msgstr ""
"ここで、ローカル変数`s`が音符60を演奏するシンセを表しています。この変数は、*実行毎にローカル*である点に注意してください。ある実行のdefineで定義"
"された関数のように他の実行からアクセスすることはできません。"

#: 07.1-Controlling-Running-Synths.md:18
msgid "Once we have `s`, we can start controlling it via the `control` function:"
msgstr "一度`s`を用意すれば、`control`関数を介して制御することができます。"

#: 07.1-Controlling-Running-Synths.md:21 07.3-Sliding-Parameters.md:13
#, no-wrap
msgid ""
"s = play 60, release: 5\n"
"sleep 0.5\n"
"control s, note: 65\n"
"sleep 0.5\n"
"control s, note: 67\n"
"sleep 3\n"
"control s, note: 72"
msgstr ""
"s = play 60, release: 5\n"
"sleep 0.5\n"
"control s, note: 65\n"
"sleep 0.5\n"
"control s, note: 67\n"
"sleep 3\n"
"control s, note: 72"

#: 07.1-Controlling-Running-Synths.md:31
msgid ""
"The thing to notice is that we're not triggering 4 different synths here - we'"
"re just triggering one synth and then change the pitch 3 times afterwards, whi"
"le it's playing."
msgstr "演奏している間に、1つのシンセのみを呼び出し、3回ピッチを変更しています。ここで注目すべき点は、4つの異なるシンセを呼び出していないということです。"

#: 07.1-Controlling-Running-Synths.md:35
msgid ""
"We can pass any of the standard opts to `control`, so you can control things l"
"ike `amp:`, `cutoff:` or `pan:`."
msgstr "標準的なオプションは`control`へ渡すことができるので、`amp:`, `cutoff:`あるいは`pan:`などを制御することができます。"

#: 07.1-Controlling-Running-Synths.md:38
msgid "Non-controllable Options"
msgstr "制御不可能なオプション"

#: 07.1-Controlling-Running-Synths.md:40
msgid ""
"Some of the opts can't be controlled once the synth has started. This is the c"
"ase for all the ADSR envelope parameters. You can find out which opts are cont"
"rollable by looking at their documentation in the help system. If the document"
"ation says *Can not be changed once set*, you know it's not possible to contro"
"l the opt after the synth has started."
msgstr ""
"一度シンセが開始されると、一部のオプションは制御することができなくなります。ADSRエンベロープ·パラメータがこれに該当します。そのオプションが制御可能かは"
"、ヘルプシステムのドキュメントを参照してください。ドキュメントに「一度設定されると変更することは出来ません」と書かれている場合、シンセが開始された後にオプシ"
"ョンを制御することはできません。"

#: 07.2-Controlling-FX.md:1
msgid "7.2 Controlling FX"
msgstr "7.2 エフェクトの制御"

#: 07.2-Controlling-FX.md:3
msgid "Controlling FX"
msgstr "エフェクトの制御"

#: 07.2-Controlling-FX.md:5
msgid ""
"It is also possible to control FX, although this is achieved in a slightly dif"
"ferent way:"
msgstr "エフェクトも、少々異なる方法をとりますが、制御する事が出来ます。"

#: 07.2-Controlling-FX.md:8
#, no-wrap
msgid ""
"with_fx :reverb do |r|\n"
"  play 50\n"
"  sleep 0.5\n"
"  control r, mix: 0.7\n"
"  play 55\n"
"  sleep 1\n"
"  control r, mix: 0.9\n"
"  sleep 1\n"
"  play 62\n"
"end"
msgstr ""
"with_fx :reverb do |r|\n"
"  play 50\n"
"  sleep 0.5\n"
"  control r, mix: 0.7\n"
"  play 55\n"
"  sleep 1\n"
"  control r, mix: 0.9\n"
"  sleep 1\n"
"  play 62\n"
"end"

#: 07.2-Controlling-FX.md:21
msgid ""
"Instead of using a variable, we use the goalpost parameters of the do/end bloc"
"k. Inside the `|` bars, we need to specify a unique name for our running FX wh"
"ich we then reference from the containing do/end block. This behaviour is iden"
"tical to using parameterised functions."
msgstr ""
"変数を使用する代わりに、*do/end*プロックのブロックパラメータを使用します。これは、実行中のエフェクトとして*do/end*プロックの中から参照するパ"
"ラメータとして、`|`と`|`の間にユニークな名前を指定する必要があります。このパラメータの振る舞いは、引数の付いた関数を使用する場合と同じです。"

#: 07.2-Controlling-FX.md:26
msgid "Now go and control some synths and FX!"
msgstr "さあ、シンセやエフェクトをコントロールしてみよう！"

#: 07.3-Sliding-Parameters.md:1
msgid "7.3 Sliding Options"
msgstr "7.3 オプションのスライド"

#: 07.3-Sliding-Parameters.md:3
msgid "Sliding Opts"
msgstr "オプションのスライド"

#: 07.3-Sliding-Parameters.md:5
msgid ""
"Whilst exploring the synth and FX opts, you might have noticed that there are "
"a number of opts ending with `_slide`. You might have even tried calling them "
"and seeing no effect. This is because they're not normal parameters, they're s"
"pecial opts that only work when you control synths as introduced in the previo"
"us section."
msgstr ""
"シンセやエフェクトのオプションを見ていくと、`_slide`で終わるオプションがあることに気づいたかもしれません。それらを試しに呼び出しても、何の効果も示さ"
"なかったかもしれません。これは通常のオプションではなく、前回のセクションで紹介したように、シンセを制御するときのみ動作をする特別なオプションです。"

#: 07.3-Sliding-Parameters.md:11
msgid "Consider the following example:"
msgstr "次の例を考えてみましょう。"

#: 07.3-Sliding-Parameters.md:23
msgid ""
"Here, you can hear the synth pitch changing immediately on each `control` call"
". However, we might want the pitch to slide between changes. As we're controll"
"ing the `note:` parameter, to add slide, we need to set the `note_slide` param"
"eter of the synth:"
msgstr ""
"ここでは、各`control`の呼び出し後、すぐにシンセのピッチの変更を聞くことができますが、ピッチが変化する間にスライドさせたくなるかもしれません。ここで"
"は`note:`オプションを制御しているので、スライドを追加するためには、シンセの`note_slide`オプションを追加する必要があります。"

#: 07.3-Sliding-Parameters.md:28
#, no-wrap
msgid ""
"s = play 60, release: 5, note_slide: 1\n"
"sleep 0.5\n"
"control s, note: 65\n"
"sleep 0.5\n"
"control s, note: 67\n"
"sleep 3\n"
"control s, note: 72"
msgstr ""
"s = play 60, release: 5, note_slide: 1\n"
"sleep 0.5\n"
"control s, note: 65\n"
"sleep 0.5\n"
"control s, note: 67\n"
"sleep 3\n"
"control s, note: 72"

#: 07.3-Sliding-Parameters.md:38
msgid ""
"Now we hear the notes being bent between the `control` calls. It sounds nice, "
"doesn't it? You can speed up the slide by using a shorter time such as `note_s"
"lide: 0.2` or slow it down by using a longer slide time."
msgstr ""
"`control`の呼び出しの間の音程が滑らかに繋がっていることがわかるはずです。いい感じではないでしょうか。`note_slide: 0.2` よりも短い"
"スライド時間を使うことで、スライドをスピードアップすることができますし、もっと長い時間を使ってテンポを遅くすることができます。"

#: 07.3-Sliding-Parameters.md:43
msgid ""
"Every parameter that can be controlled has a corresponding `_slide` parameter "
"for you to play with."
msgstr "制御することのできるオプションは、対応する`_slide`オプションを持っています。"

#: 07.3-Sliding-Parameters.md:46
msgid "Sliding is sticky"
msgstr "スライドの設定は保持される"

#: 07.3-Sliding-Parameters.md:48
msgid ""
"Once you've set a `_slide` parameter on a running synth, it will be remembered"
" and used every time you slide the corresponding parameter. To stop sliding yo"
"u must set the `_slide` value to 0 before the next `control` call."
msgstr ""
"一度、実行しているシンセの`_slide`オプションを設定したら、それは記憶され、対応するオプションがスライドする度に使用されます。スライドを停止するために"
"は、次の`control`を呼び出す前に`0`に`_slide`値を設定する必要があります。"

#: 07.3-Sliding-Parameters.md:53
msgid "Sliding FX Opts"
msgstr "エフェクト・オプションのスライド"

#: 07.3-Sliding-Parameters.md:55
msgid "It is also possible to slide FX opts:"
msgstr "また、エフェクトオプションをスライドさせることも可能です。"

#: 07.3-Sliding-Parameters.md:57
#, no-wrap
msgid ""
"with_fx :wobble, phase: 1, phase_slide: 5 do |e|\n"
"  use_synth :dsaw\n"
"  play 50, release: 5\n"
"  control e, phase: 0.025\n"
"end"
msgstr ""
"with_fx :wobble, phase: 1, phase_slide: 5 do |e|\n"
"  use_synth :dsaw\n"
"  play 50, release: 5\n"
"  control e, phase: 0.025\n"
"end"

#: 07.3-Sliding-Parameters.md:65
msgid ""
"Now have fun sliding things around for smooth transitions and flowing control."
".."
msgstr "さあ、滑らかな変化と流れるような制御のために、色々スライドして楽しんでみましょう。"

#: 08-Data-Structures.md:1
msgid "8 Data Structures"
msgstr "8 データ構造"

#: 08-Data-Structures.md:3
msgid "Data Structures"
msgstr "データ構造"

#: 08-Data-Structures.md:5
msgid "A very useful tool in a programmer's toolkit is a data structure."
msgstr "プログラマのツールキットで非常に有用なツールはデータ構造です。"

#: 08-Data-Structures.md:7
msgid ""
"Sometimes you may wish to represent and use more than one thing. For example, "
"you may find it useful to have a series of notes to play one after another. Pr"
"ogramming languages have data structures to allow you do exactly this."
msgstr ""
"時には、複数の要素を表したものを使いたいかもしれません。例えば、次々に演奏される一連の音符を保持すると便利だと気づくことがあるかもしれません。プログラミング"
"言語は、正にこういったことを行うためにデータ構造を持っています。"

#: 08-Data-Structures.md:12
msgid ""
"There are many exciting and exotic data structures available to programmers - "
"and people are always inventing new ones. However, for now we only really need"
" to consider a very simple data structure - the list."
msgstr ""
"プログラマが利用できるエキサイティングで奇抜なデータ構造は沢山あり、また常に新しいものが発明されています。しかし、今の我々が本当に検討するべきものは、とても"
"シンプルなデータ構造 - リストです。"

#: 08-Data-Structures.md:16
msgid ""
"Let's look at it in more detail. We'll cover its basic form and then also how "
"lists can be used to represent scales and chords."
msgstr ""
"では、より詳細に見てみましょう。まずは、リストの基本的な形式を学習し、続いて、リストがスケール（音階）やコード（和音）を表現するためにどのように使用されるの"
"かを学習していきましょう。"

#: 08.1-Lists.md:1
msgid "8.1 Lists"
msgstr "8.1 リスト"

#: 08.1-Lists.md:3
msgid "Lists"
msgstr "リスト"

#: 08.1-Lists.md:5
msgid ""
"In this section we'll take a look at a data structure which is very useful - t"
"he list. We met it very briefly before in the section on randomisation when we"
" randomly chose from a list of notes to play:"
msgstr ""
"このセクションでは、非常に有用なデータ構造であるリストについて見ていきます。以前に我々はランダム化の章でリストについて簡単に触れました。音符のリストから無作"
"為に選んで再生する次のようなコードです。"

#: 08.1-Lists.md:9
#, no-wrap
msgid "play choose([50, 55, 62])"
msgstr "play choose([50, 55, 62])"

#: 08.1-Lists.md:13
msgid ""
"In this section we'll explore using lists to also represent chords and scales."
" First let's recap how we might play a chord. Remember that if we don't use `s"
"leep`, sounds all happen at the same time:"
msgstr ""
"ここでは、コードやスケールを表現するためのリストの使い方についても見ていきます。最初に、コードを演奏する方法をおさらいしてみましょう。`sleep`を使用し"
"ない場合、すべての音が同時に演奏されることを思い出してください。"

#: 08.1-Lists.md:17
#, no-wrap
msgid ""
"play 52\n"
"play 55\n"
"play 59"
msgstr ""
"play 52\n"
"play 55\n"
"play 59"

#: 08.1-Lists.md:23
msgid "Let's look at other ways to represent this code."
msgstr "このコードの別の表現方法を見てみましょう。"

#: 08.1-Lists.md:25
msgid "Playing a List"
msgstr "リストの演奏"

#: 08.1-Lists.md:27
msgid ""
"One option is to place all the notes in a list: `[52, 55, 59]`. Our friendly `"
"play` function is smart enough to know how to play a list of notes. Try it:"
msgstr ""
"1つの方法は、\\[52, 55, 59\\]のように、すべての音符をリストに配置することです。使いやすいplay関数は、リストになった音符をどのように演奏する"
"かをすぐに理解します。次のコードを試してみてください。"

#: 08.1-Lists.md:31
#, no-wrap
msgid "play [52, 55, 59]"
msgstr "play [52, 55, 59]"

#: 08.1-Lists.md:35
msgid ""
"Ooh, that's already nicer to read. Playing a list of notes doesn't stop you fr"
"om using any of the parameters as normal:"
msgstr "おー、これは読みやすいですね。音符リストの演奏は、通常のオプションのいずれも妨げになりません。"

#: 08.1-Lists.md:38
#, no-wrap
msgid "play [52, 55, 59], amp: 0.3"
msgstr "play [52, 55, 59], amp: 0.3"

#: 08.1-Lists.md:42
msgid ""
"Of course, you can also use the traditional note names instead of the MIDI num"
"bers:"
msgstr "もちろん、MIDIの代わりに伝統的な音符の名前を使うこともできます。"

#: 08.1-Lists.md:45
#, no-wrap
msgid "play [:E3, :G3, :B3]"
msgstr "play [:E3, :G3, :B3]"

#: 08.1-Lists.md:49
msgid ""
"Now those of you lucky enough to have studied some music theory might recognis"
"e that chord as *E Minor* played in the 3rd octave."
msgstr "多少の音楽理論の知識を持っている方なら、3オクターブで*Eマイナー*のコードが演奏されたことがわかるでしょう。"

#: 08.1-Lists.md:52
msgid "Accessing a List"
msgstr "リストへのアクセス"

#: 08.1-Lists.md:54
msgid ""
"Another very useful feature of a list is the ability to get information out of"
" it. This may sound a bit strange, but it's no more complicated than someone a"
"sking you to turn a book to page 23. With a list, you'd say, what's the elemen"
"t at index 23? The only strange thing is that in programming indexes usually s"
"tart at 0 not 1."
msgstr ""
"もう1つの非常に便利なリストの機能は、リストから情報を取得する機能です。これは少し奇妙に聞こえるかもしれなませんが、本の23ページを開いてくださいと誰かに頼"
"まれることよりも簡単なことです。リストの場合は、インデックス23の要素は何ですか？ と尋ねればいいのです。唯一、奇妙なことは、プログラミングのインデックスは"
"通常、1ではなく0から開始されることです。"

#: 08.1-Lists.md:60
msgid "With list indexes we don't count 1, 2, 3... Instead we count 0, 1, 2..."
msgstr "リストのインデックスは1,2,3と数える代わりに、0,1,2と数えていきます。"

#: 08.1-Lists.md:62
msgid "Let's look at this in a little more detail. Take a look at this list:"
msgstr "それではもう少し詳細にみてみましょう。次のリストを見てください。"

#: 08.1-Lists.md:64
#, no-wrap
msgid "[52, 55, 59]"
msgstr "[52, 55, 59]"

#: 08.1-Lists.md:68
msgid ""
"There's nothing especially scary about this. Now, what's the second element in"
" that list? Yes, of course, it's `55`. That was easy. Let's see if we can get "
"the computer to answer it for us too:"
msgstr ""
"これは特に難しいことは何もありません。リストの2番目の要素は何でしょうか？ そう、もちろん`55`です。簡単ですね。それでは、同様にコンピュータが答えること"
"ができるかどうかを見てみましょう。"

#: 08.1-Lists.md:72 08.4-Rings.md:12
#, no-wrap
msgid "puts [52, 55, 59][1]"
msgstr "puts [52, 55, 59][1]"

#: 08.1-Lists.md:76
msgid ""
"OK, that looks a bit weird if you've never seen anything like it before. Trust"
" me though, it's not too hard. There are three parts to the line above: the wo"
"rd `puts` , our list `52, 55, 59` and our index `[1]`. Firstly we're saying `p"
"uts` because we want Sonic Pi to print the answer out for us in the log. Next,"
" we're giving it our list, and finally our index is asking for the second elem"
"ent. We need to surround our index with square brackets and because counting s"
"tarts at `0`, the index for the second element is `1`. Look:"
msgstr ""
"以前にこのようなものを見たことがない場合、少し奇妙に見えるかもしれませんが、大丈夫。私を信頼してください。難しいことはありません。上記の行には、`puts`"
"という命令、リストの`52, 55, 59` 、インデックスが`[1]`の3つの部分があります。まずはじめに、Sonic Piへログの中から答えを出力させる"
"ためputsを命令します。次にリストを与えています。そして最後に第2の要素を問い合わせています。角括弧でインデックスを囲む必要があり、カウントは`0`で始ま"
"るので、2番目の要素のインデックスは`1`となります。下記、みてみましょう。"

#: 08.1-Lists.md:85
#, no-wrap
msgid ""
"# indexes:  0   1   2\n"
"           [52, 55, 59]"
msgstr ""
"# indexes:  0   1   2\n"
"           [52, 55, 59]"

#: 08.1-Lists.md:90
msgid ""
"Try running the code `puts [52, 55, 59][1]` and you'll see `55` pop up in the "
"log. Change the index `1` to other indexes, try longer lists and think about h"
"ow you might use a list in your next code jam. For example, what musical struc"
"tures might be represented as a series of numbers..."
msgstr ""
"コード`puts [52, 55, 59][1]`を実行してみてください。ログに`55`と表示されるでしょう。インデックス`1`を別のインデックスに変えてみ"
"てください。さらに長い`list`を与えて、どのように演奏で使えるのか考えてみてください。例えば、どのような音楽の構造が音符の連続として表現されるか？ など"
"です。"

#: 08.2-Chords.md:1
msgid "8.2 Chords"
msgstr "8.2 コード（和音）"

#: 08.2-Chords.md:5
msgid ""
"Sonic Pi has built-in support for chord names which will return lists. Try it "
"for yourself:"
msgstr "Sonic Piは和音名でリストを返す機能を内蔵しています。実際に試してみましょう。"

#: 08.2-Chords.md:8
#, no-wrap
msgid "play chord(:E3, :minor)"
msgstr "play chord(:E3, :minor)"

#: 08.2-Chords.md:12
msgid ""
"Now, we're really getting somewhere. That looks a lot more pretty than the raw"
" lists (and is easier to read for other people). So what other chords does Son"
"ic Pi support? Well, a *lot*. Try some of these:"
msgstr ""
"さあ、本当に動きましたね。そのままのリストよりも美しく見えるし、そして他の人にとっても読みやすいでしょう。では、どんな和音をSonic Pi はサポートをし"
"ているのでしょうか。沢山あります。次のように、いくつかのコードを試してみましょう。"

#: 08.2-Chords.md:16
msgid "`chord(:E3, :m7)`"
msgstr "`chord(:E3, :m7)`"

#: 08.2-Chords.md:17
msgid "`chord(:E3, :minor)`"
msgstr "`chord(:E3, :minor)`"

#: 08.2-Chords.md:18
msgid "`chord(:E3, :dim7)`"
msgstr "`chord(:E3, :dim7)`"

#: 08.2-Chords.md:19
msgid "`chord(:E3, :dom7)`"
msgstr "`chord(:E3, :dom7)`"

#: 08.2-Chords.md:21
msgid "Arpeggios"
msgstr "アルペジオ"

#: 08.2-Chords.md:23
msgid "We can easily turn chords into arpeggios with the function `play_pattern`:"
msgstr "`play_pattern`関数で簡単にコード（和音）からアルベジオ（和音を構成する音を一音ずつ順番に弾いていく奏法）に変更して演奏を行うことができます。"

#: 08.2-Chords.md:26
#, no-wrap
msgid "play_pattern chord(:E3, :m7)"
msgstr "play_pattern chord(:E3, :m7)"

#: 08.2-Chords.md:30
msgid ""
"Ok, that's not so fun - it played it really slowly. `play_pattern` will play e"
"ach note in the list separated with a call to `sleep 1` between each call to `"
"play`. We can use another function `play_pattern_timed` to specify our own tim"
"ings and speed things up:"
msgstr ""
"このコードでは、とてもゆっくりと演奏をしていて、あまり楽しくないかもしれません。`play_pattern`は、リスト内の各音符の`play`を呼び出す度に"
"`sleep 1` を呼び出して演奏します。`play_pattern_timed`関数を使用することで、独自のタイミングと速度を指定することがきます。"

#: 08.2-Chords.md:35
#, no-wrap
msgid "play_pattern_timed chord(:E3, :m7), 0.25"
msgstr "play_pattern_timed chord(:E3, :m7), 0.25"

#: 08.2-Chords.md:39
msgid "We can even pass a list of times which it will treat as a circle of times:"
msgstr "`play_pattern`には時間のリストを渡すこともでき、それは循環する時間として扱われます。"

#: 08.2-Chords.md:42
#, no-wrap
msgid "play_pattern_timed chord(:E3, :m13), [0.25, 0.5]"
msgstr "play_pattern_timed chord(:E3, :m13), [0.25, 0.5]"

#: 08.2-Chords.md:46
msgid "This is the equivalent to:"
msgstr "これは次のコードと同じです。"

#: 08.2-Chords.md:48
#, no-wrap
msgid ""
"play 52\n"
"sleep 0.25\n"
"play 55\n"
"sleep 0.5\n"
"play 59\n"
"sleep 0.25\n"
"play 62\n"
"sleep 0.5\n"
"play 66\n"
"sleep 0.25\n"
"play 69\n"
"sleep 0.5\n"
"play 73"
msgstr ""
"play 52\n"
"sleep 0.25\n"
"play 55\n"
"sleep 0.5\n"
"play 59\n"
"sleep 0.25\n"
"play 62\n"
"sleep 0.5\n"
"play 66\n"
"sleep 0.25\n"
"play 69\n"
"sleep 0.5\n"
"play 73"

#: 08.2-Chords.md:64
msgid "Which would you prefer to write?"
msgstr "どちらの書き方を好みますか？"

#: 08.3-Scales.md:1
msgid "8.3 Scales"
msgstr "8.3 スケール（音階）"

#: 08.3-Scales.md:3
msgid "Scales"
msgstr "スケール（音階）"

#: 08.3-Scales.md:5
msgid ""
"Sonic Pi has support for a wide range of scales. How about playing a C3 major "
"scale?"
msgstr "Sonic Piは広い範囲の音階を演奏できます。C3メジャースケールの再生はどのように行うのでしょうか？"

#: 08.3-Scales.md:8
#, no-wrap
msgid "play_pattern_timed scale(:c3, :major), 0.125, release: 0.1"
msgstr "play_pattern_timed scale(:c3, :major), 0.125, release: 0.1"

#: 08.3-Scales.md:12
msgid "We can even ask for more octaves:"
msgstr "さらに多くのオクターブを実行することができます。"

#: 08.3-Scales.md:14
#, no-wrap
msgid "play_pattern_timed scale(:c3, :major, num_octaves: 3), 0.125, release: 0.1"
msgstr "play_pattern_timed scale(:c3, :major, num_octaves: 3), 0.125, release: 0.1"

#: 08.3-Scales.md:18
msgid "How about all the notes in a pentatonic scale?"
msgstr "ペンタトニックスケール（オクターブに5つの音が含まれる音階のこと）のすべての音符はどうでしょう?"

#: 08.3-Scales.md:20
#, no-wrap
msgid ""
"play_pattern_timed scale(:c3, :major_pentatonic, num_octaves: 3), 0.125, relea"
"se: 0.1"
msgstr ""
"play_pattern_timed scale(:c3, :major_pentatonic, num_octaves: 3), 0.125, relea"
"se: 0.1"

#: 08.3-Scales.md:24
msgid "Random notes"
msgstr "ランダムな音符"

#: 08.3-Scales.md:26
msgid ""
"Chords and scales are great ways of constraining a random choice to something "
"meaningful. Have a play with this example which picks random notes from the ch"
"ord E3 minor:"
msgstr "コードとスケールは、ランダムな選択を強いるには素晴らしい制約です。コードE3マイナーからランダムに音符を取り出すには次の例を実行してください。"

#: 08.3-Scales.md:30
#, no-wrap
msgid ""
"use_synth :tb303\n"
"loop do\n"
"  play choose(chord(:E3, :minor)), release: 0.3, cutoff: rrand(60, 120)\n"
"  sleep 0.25\n"
"end"
msgstr ""
"use_synth :tb303\n"
"loop do\n"
"  play choose(chord(:E3, :minor)), release: 0.3, cutoff: rrand(60, 120)\n"
"  sleep 0.25\n"
"end"

#: 08.3-Scales.md:38
msgid "Try switching in different chord names and cutoff ranges."
msgstr "異なる和音名やカットオフする範囲を試してみましょう。"

#: 08.3-Scales.md:40
msgid "Discovering Chords and Scales"
msgstr "コードとスケールの検索"

#: 08.3-Scales.md:42
msgid ""
"To find out which scales and chords are supported by Sonic Pi simply click the"
" Lang button on the far left of this tutorial and then choose either chord or "
"scale in the API list. In the information in the main panel, scroll down until"
" you see a long list of chords or scales (depending on which you're looking at"
")."
msgstr ""
"Sonic Piによってサポートされているスケールやコードを検索するには、このチュートリアルの左にある`命令`ボタンをクリックし、APIリストから`chor"
"d`か`scale`を選びます。メインパネルの情報に、コードやスケールの長いリストが現れるまで下にスクロールしてください。"

#: 08.3-Scales.md:48
msgid "Have fun and remember: there are no mistakes, only opportunities."
msgstr "「間違いはない、あるのはただ可能性だけ」ということを思い出して、楽しんでください。"

#: 08.4-Rings.md:1
msgid "8.4 Rings"
msgstr "8.4 リング"

#: 08.4-Rings.md:3 A.11-beat-tracking.md:62
msgid "Rings"
msgstr "リング"

#: 08.4-Rings.md:5
msgid ""
"An interesting spin on standard lists are rings. If you know some programming,"
" you might have come across ring buffers or ring arrays. Here, we'll just go f"
"or ring - it's short and simple."
msgstr ""
"標準のリストを一捻りした面白いものにリングがあります。いくつかのプログラミングを理解していれば、リングバッファやリングアレイなどを見たことがあるかもしれませ"
"ん。ここでは、まさに`ring`（環状リスト）について見ていきます - それは短く、簡単です。"

#: 08.4-Rings.md:9
msgid ""
"In the previous section on lists we saw how we could fetch elements out of the"
"m by using the indexing mechanism:"
msgstr "リストに関する前のセクションでは、インデックスの機構を使用してリストから要素を取り出す方法を説明しました。"

#: 08.4-Rings.md:16
msgid ""
"Now, what happens if you want index `100`? Well, there's clearly no element at"
" index 100 as the list has only three elements in it. So Sonic Pi will return "
"you `nil` which means nothing."
msgstr ""
"もしインデックス100を取り出そうとしら、何が起こるでしょう？ まあ、3つの要素しか持たないリストの中でインデックス100の要素は、明らかにありません。だか"
"らSonic Piは空を意味する`nil`を返すでしょう。"

#: 08.4-Rings.md:20
msgid ""
"However, consider you have a counter such as the current beat which continuall"
"y increases. Let's create our counter and our list:"
msgstr "ここでは、現在のビート（拍子）が継続的に増加する`counter`を考えてみましょう。まずはカウンタとリストを作成します。"

#: 08.4-Rings.md:23
#, no-wrap
msgid ""
"counter = 0\n"
"notes = [52, 55, 59]"
msgstr ""
"counter = 0\n"
"notes = [52, 55, 59]"

#: 08.4-Rings.md:28
msgid "We can now use our counter to access a note in our list:"
msgstr "これで、リストの音符にアクセスするためのカウンタを使用することができます。"

#: 08.4-Rings.md:30
#, no-wrap
msgid "puts notes[counter]"
msgstr "puts notes[counter]"

#: 08.4-Rings.md:34
msgid "Great, we got `52`. Now, let's increment our counter and get another note:"
msgstr "素晴らしい、`52`を取得しました。カウンタを増やして別の音符を取得してみましょう。"

#: 08.4-Rings.md:37
#, no-wrap
msgid ""
"counter = (inc counter)\n"
"puts notes[counter]"
msgstr ""
"counter = (inc counter)\n"
"puts notes[counter]"

#: 08.4-Rings.md:42
msgid ""
"Super, we now get `55` and if we do it again we get `59`. However, if we do it"
" again, we'll run out of numbers in our list and get `nil`. What if we wanted "
"to just loop back round and start at the beginning of the list again? This is "
"what rings are for."
msgstr ""
"すごいでしょう、`55`を取得し、それを再び繰り返すならば`59`を得ます。さらに繰り返す場合は、リスト内の数が不足し`nil`になるでしょう。では、ちょう"
"どループのはじめに戻り、再びリストの先頭から開始したい場合はどうしたらようでしょうか？ そのためにリングを使います。"

#: 08.4-Rings.md:47
msgid "Creating Rings"
msgstr "リングの作成"

#: 08.4-Rings.md:49
msgid ""
"We can create rings one of two ways. Either we use the `ring` function with th"
"e elements of the ring as parameters:"
msgstr "リングは、2つの方法のどちらか1つで作成することができます。どちらの方法もリングの要素を引数とする`ring`関数を利用します。"

#: 08.4-Rings.md:52
#, no-wrap
msgid "(ring 52, 55, 59)"
msgstr "(ring 52, 55, 59)"

#: 08.4-Rings.md:56
msgid ""
"Or we can take a normal list and convert it to a ring by sending it the `.ring"
"` message:"
msgstr "また、通常のリストを取得し、それに`.ring`メッセージを送ることで、リングに変換することができます。"

#: 08.4-Rings.md:59
#, no-wrap
msgid "[52, 55, 59].ring"
msgstr "[52, 55, 59].ring"

#: 08.4-Rings.md:63
msgid "Indexing Rings"
msgstr "リングのインデックス化"

#: 08.4-Rings.md:65
msgid ""
"Once we have a ring, you can use it in exactly the same way you would use a no"
"rmal list with the exception that you can use indexes that are negative or lar"
"ger than the size of the ring and they'll wrap round to always point at one of"
" the ring's elements:"
msgstr ""
"いったんリングを取得したら、通常のリストを使用する場合とまったく同じ方法で使用することができます。ただし、インデックスがマイナスもしくはリングの数値より大き"
"い場合は、通常のリストと動作が異なり、先頭あるいは末尾に巻き戻ってリングの要素のどれか1つを必ず指します。"

#: 08.4-Rings.md:70
#, no-wrap
msgid ""
"(ring 52, 55, 59)[0] #=> 52\n"
"(ring 52, 55, 59)[1] #=> 55\n"
"(ring 52, 55, 59)[2] #=> 59\n"
"(ring 52, 55, 59)[3] #=> 52\n"
"(ring 52, 55, 59)[-1] #=> 59"
msgstr ""
"(ring 52, 55, 59)[0] #=> 52\n"
"(ring 52, 55, 59)[1] #=> 55\n"
"(ring 52, 55, 59)[2] #=> 59\n"
"(ring 52, 55, 59)[3] #=> 52\n"
"(ring 52, 55, 59)[-1] #=> 59"

#: 08.4-Rings.md:78
msgid "Using Rings"
msgstr "リングを使用する"

#: 08.4-Rings.md:80
msgid ""
"Let's say we're using a variable to represent the current beat number. We can "
"use this as an index into our ring to fetch notes to play, or release times or"
" anything useful we've stored in our ring regardless of the beat number we're "
"currently on."
msgstr ""
"ここで、現在のビート（拍子）の値を表すために変数を使用しているとしましょう。その変数は、現在表しているビート値に関わらず、演奏に使用する音符やリリース・タイ"
"ム、その他リングに格納された何か有用な値を取得するのに、インデックスとして使用できます。"

#: 08.4-Rings.md:85
msgid "Scales and Chords are Rings"
msgstr "スケールとコードはリング"

#: 08.4-Rings.md:87
msgid ""
"A useful thing to know is that the lists returned by `scale` and `chord` are a"
"lso rings and allow you to access them with arbitrary indexes."
msgstr ""
"知っておくと役立つこととして、`scale`（音階）と`chord`（和音）によって返されたリストもリングであり、任意のインデックスでそれらにアクセスするこ"
"とを可能にします。"

#: 08.4-Rings.md:90
msgid "Ring Constructors"
msgstr "リングのコンストラクタ（作成関数）"

#: 08.4-Rings.md:92
msgid ""
"In addition to `ring` there are a number of other functions which will constru"
"ct a ring for us."
msgstr "`ring`関数の他にも、リングを作成する沢山の関数があります。"

#: 08.4-Rings.md:95
msgid "`range` invites you specify a starting point, end point and step size."
msgstr "`range`は始点、終点とステップサイズを指定します。"

#: 08.4-Rings.md:96
msgid "`bools` allows you to use `1`s and `0`s to succinctly represent booleans."
msgstr "`bools`は、`1`と`0`を使用して簡単にブール値を表すリングを作成できます。"

#: 08.4-Rings.md:97
msgid "`knit` allows you to knit a sequence of repeated values."
msgstr "`knit`は一連の繰り返される値のリングを作成できます。"

#: 08.4-Rings.md:98
msgid "`spread` creates a ring of bools with a Euclidean distribution."
msgstr "`spread`はユークリッド分布に従ったブール値のリングを作成します。"

#: 08.4-Rings.md:100
msgid "Take a look at their respective documentation for more information."
msgstr "詳細については、個々のドキュメントを見てください。"

#: 08.5-Ring-Chains.md:1
msgid "8.5 Ring Chains"
msgstr "8.5 リングのチェイン"

#: 08.5-Ring-Chains.md:3
msgid "Ring Chains"
msgstr "リングのチェイン"

#: 08.5-Ring-Chains.md:5
msgid ""
"In addition to the constructors such as `range` and `spread` another way of cr"
"eating new rings is to manipulate existing rings."
msgstr "`range`や`spread`のようなコンストラクタ（作成関数）に加えて、別なリングの作成方法としては、作成したリングを操作する方法があります。"

#: 08.5-Ring-Chains.md:9
msgid "Chain Commands"
msgstr "チェインコマンド"

#: 08.5-Ring-Chains.md:11
msgid "To explore this, take a simple ring:"
msgstr "次のような単純なリングを作成します。"

#: 08.5-Ring-Chains.md:13
#, no-wrap
msgid "(ring 10, 20, 30, 40, 50)"
msgstr "(ring 10, 20, 30, 40, 50)"

#: 08.5-Ring-Chains.md:17
msgid ""
"What if we wanted it backwards? Well we'd use the chain command `.reverse` to "
"take the ring and turn it around:"
msgstr "リングを逆にしたいときにはどうしたらよいでしょう？ リングを反転させるには、チェインコマンドの`.reverse`を使います。"

#: 08.5-Ring-Chains.md:20
#, no-wrap
msgid "(ring 10, 20, 30, 40, 50).reverse  #=> (ring 50, 40, 30, 20, 10)"
msgstr "(ring 10, 20, 30, 40, 50).reverse  #=> (ring 50, 40, 30, 20, 10)"

#: 08.5-Ring-Chains.md:24
msgid "Now, what if we wanted the first three values from the ring?"
msgstr "では次に、リングから最初の3つの値を取得するにはどうしたらよいでしょう？"

#: 08.5-Ring-Chains.md:26
#, no-wrap
msgid "(ring 10, 20, 30, 40, 50).take(3)  #=> (ring 10, 20, 30)"
msgstr "(ring 10, 20, 30, 40, 50).take(3)  #=> (ring 10, 20, 30)"

#: 08.5-Ring-Chains.md:30
msgid "Finally, what if we wanted to shuffle the ring?"
msgstr "最後に、リングをシャッフルするにはどうしたらよいでしょう？"

#: 08.5-Ring-Chains.md:32
#, no-wrap
msgid "(ring 10, 20, 30, 40, 50).shuffle  #=> (ring 40, 30, 10, 50, 20)"
msgstr "(ring 10, 20, 30, 40, 50).shuffle  #=> (ring 40, 30, 10, 50, 20)"

#: 08.5-Ring-Chains.md:36
msgid "Multiple Chains"
msgstr "多重チェイン"

#: 08.5-Ring-Chains.md:38
msgid ""
"This is already a powerful way of creating new rings. However, the *real* powe"
"r comes when you chain a few of these commands together."
msgstr "ここまでで既にリングを作成する強力な方法を見てきましたが、これらのチェインコマンドを一緒に用いることで*本当の*力を発揮します。"

#: 08.5-Ring-Chains.md:41
msgid "How about shuffling the ring, dropping 1 element and then taking the next 3?"
msgstr "リングをシャッフルし、最初の要素を削除し、それに続く3つの要素を得る場合にはどうすればよいでしょう？"

#: 08.5-Ring-Chains.md:43
msgid "Let's take this in stages:"
msgstr "段階的に見ていきましょう。"

#: 08.5-Ring-Chains.md:45
msgid "`(ring 10, 20, 30, 40, 50)` - our initial ring"
msgstr "`(ring 10, 20, 30, 40, 50)` - リングの最初の状態"

#: 08.5-Ring-Chains.md:46
msgid "`(ring 10, 20, 30, 40, 50).shuffle` - shuffles - `(ring 40, 30, 10, 50, 20)`"
msgstr "`(ring 10, 20, 30, 40, 50).shuffle` - シャッフルし - `(ring 40, 30, 10, 50, 20)`"

#: 08.5-Ring-Chains.md:47
msgid "`(ring 10, 20, 30, 40, 50).shuffle.drop(1)` - drop 1 - `(ring 30, 10, 50, 20)`"
msgstr ""
"`(ring 10, 20, 30, 40, 50).shuffle.drop(1)` - 最初の要素を削除し - `(ring 30, 10, 50, 2"
"0)`"

#: 08.5-Ring-Chains.md:48
msgid ""
"`(ring 10, 20, 30, 40, 50).shuffle.drop(1).take(3)` - take 3 - `(ring 30, 10, "
"50)`"
msgstr ""
"`(ring 10, 20, 30, 40, 50).shuffle.drop(1).take(3)` - 3つの要素を得る - `(ring 30, 10"
", 50)`"

#: 08.5-Ring-Chains.md:50
msgid ""
"Can you see how we can just create a long chain of these methods by just *stic"
"king them together*. We can combine these in any order we want creating an ext"
"remely rich and powerful way of generating new rings from existing ones."
msgstr ""
"*コマンドを一緒にくっつける*だけで、これらのコマンドの長いチェインを作れることが分かったと思います。チェインコマンドは好きな順序で組み合わせることができま"
"す。またそれにより、既に存在するリングから新しいリングを生成する、とても豊かで強力な方法を作り出すことができます。"

#: 08.5-Ring-Chains.md:55
msgid "Immutability"
msgstr "不変性"

#: 08.5-Ring-Chains.md:57
msgid ""
"These rings have a powerful and important property. They are immutable which m"
"eans that they can not change. This means that the chaining methods described "
"in this section *do not change rings* rather they *create new rings*. This mea"
"ns you're free to share rings across threads and start chaining them within a "
"thread knowing you won't be affecting any other thread using the same ring."
msgstr ""
"リングは強力で重要な特徴を持っています。それは不変性と言って、リングを変更できないということを意味しています。このセクションで紹介しているチェインコマンドが"
"、*リングを変更するのではなく*、*新しいリングを作成*していることを意味しています。これにより、スレッドを跨いでリングを共有して、同じリングを使っている他"
"のスレッドに影響を与えないで、チェインを開始できることを意味しています。"

#: 08.5-Ring-Chains.md:64
msgid "Available Chain Methods"
msgstr "利用可能なチェインコマンド"

#: 08.5-Ring-Chains.md:66
msgid "Here's a list of the available chain methods for you to play with:"
msgstr "ここに利用可能なチェインコマンドを記載しておきます。"

#: 08.5-Ring-Chains.md:68
msgid "`.reverse` - returns a reversed version of the ring"
msgstr "`.reverse` - 逆順のリングを返却します"

#: 08.5-Ring-Chains.md:69
msgid "`.sort` - creates a sorted version of the ring"
msgstr "`.sort` - ソートされたリングを作成します"

#: 08.5-Ring-Chains.md:70
msgid "`.shuffle` - creates a shuffled version of the ring"
msgstr "`.shuffle` - シャッフルされたリングを作成します"

#: 08.5-Ring-Chains.md:71
#, fuzzy
msgid "`.pick` - returns a ring with the results of calling `.choose` once"
msgstr "`.pick(3)` - `.choose`を3回呼び出した結果のリングを返却します"

#: 08.5-Ring-Chains.md:72
msgid "`.pick(3)` - returns a ring with the results of calling `.choose` 3 times"
msgstr "`.pick(3)` - `.choose`を3回呼び出した結果のリングを返却します"

#: 08.5-Ring-Chains.md:73
msgid "`.take(5)` - returns a new ring containing only the first 5 elements"
msgstr "`.take(5)` - 最初の5つの要素をのみからなる新しいリングを返却します"

#: 08.5-Ring-Chains.md:74
msgid "`.drop(3)` - returns a new ring with everything but the first 3 elements"
msgstr "`.drop(3)` - 最初の3つの要素以外の要素からなる新しいリングを返却します"

#: 08.5-Ring-Chains.md:75
msgid "`.butlast` - returns a new ring with the last element missing"
msgstr "`.butlast` - 最後の要素が欠けた新しいリングを返却します"

#: 08.5-Ring-Chains.md:76
msgid "`.drop_last(3)` - returns a new ring with the last 3 elements missing"
msgstr "`.drop_last(3)` - 最後の3つの要素が欠けた新しいリングを返却します"

#: 08.5-Ring-Chains.md:77
msgid "`.take_last(6)`- returns a new ring with only the last 6 elements"
msgstr "`.take_last(6)`- 最後の6つの要素をのみからなる新しいリングを返却します"

#: 08.5-Ring-Chains.md:78
msgid "`.stretch(2)` - repeats each element in the ring twice"
msgstr "`.stretch(2)` - リングの個々の要素を2回ずつ繰り返します"

#: 08.5-Ring-Chains.md:79
msgid "`.repeat(3)` - repeats the entire ring 3 times"
msgstr "`.repeat(3)` - リング全体を3回繰り返します"

#: 08.5-Ring-Chains.md:80
msgid "`.mirror` - adds the ring to a reversed version of itself"
msgstr "`.mirror` - 逆順のリングを自分自身に追加します"

#: 08.5-Ring-Chains.md:81
msgid "`.reflect` - same as mirror but doesn't duplicate middle value"
msgstr "`.reflect` - mirrorと同様ですが、真ん中の要素を重複させないようにします"

#: 08.5-Ring-Chains.md:82
msgid ""
"`.scale(2)` - returns a new ring with all elements multiplied by 2 (assumes ri"
"ng contains numbers only)"
msgstr ""

#: 08.5-Ring-Chains.md:84
msgid ""
"Of course, those chain methods that take numbers can take other numbers too! S"
"o feel free to call `.drop(5)` instead of `.drop(3)` if you want to drop the f"
"irst 5 elements."
msgstr ""
"数字を引数に取っているチェインコマンドは、他の数字を取ることももちろん可能です。最初の5個の要素を削除したい場合には、`.drop(3)`の代わりに、気軽に"
"`.drop(5)`を呼んでください。"

#: 09-Live-Coding.md:1
msgid "9 Live Coding"
msgstr "9 ライブコーディング"

#: 09-Live-Coding.md:5
msgid ""
"One of the most exciting aspects of Sonic Pi is that it enables you to write a"
"nd modify code live to make music, just like you might perform live with a gui"
"tar. One advantage of this approach is to give you more feedback whilst compos"
"ing (get a simple loop running and keep tweaking it till it sounds just perfec"
"t). However, the main advantage is that you can take Sonic Pi on stage and gig"
" with it."
msgstr ""
"Sonic Piの中で最もエキサイティングな特徴の1つは、ライブでギターをかき鳴らすのと同じように、ライブで音楽を演奏しながら、その場でコードを書き換え、音"
"を変化させていくことができることです。この方法で優れているのは、（シンプルなループを走らせ、そのサウンドが完璧になるまで調整するように）作品を作っている間に"
"どのような音が出来ているかその場でフィードバックを得られることです。ですが、一番の利点は、Sonic Piでステージ上でライブができることです。"

#: 09-Live-Coding.md:12
msgid ""
"In this section we'll cover the fundamentals of turning your static code compo"
"sitions into dynamic performances."
msgstr "このセクションでは、静的なコードのチューニングの基本から動的なパフォーマンスまで扱います。"

#: 09-Live-Coding.md:15
msgid "Hold on to your seats..."
msgstr "しっかりついてきてくださいね。"

#: 09.1-Live-Coding-Fundamentals.md:1
msgid "9.1 Live Coding Fundamentals"
msgstr "9.1 ライブコーディングの基本"

#: 09.1-Live-Coding-Fundamentals.md:5
msgid ""
"Now we've learned enough to really start having some fun. In this section we'l"
"l draw from all the previous sections and show you how you can start making yo"
"ur music compositions live and turning them into a performance. For that we'll"
" need 3 main ingredients:"
msgstr ""
"ここまでの章で、我々は実際に楽みながら演奏をする方法を十分に学んできました。この章では、これまでのすべての章から、どの様に作曲を開始し、ライブパフォーマンス"
"に繋げるかを紹介していきます。そのために3つの主な要素が必要になります。"

#: 09.1-Live-Coding-Fundamentals.md:10
msgid "An ability to write code that makes sounds - CHECK!"
msgstr "チェック要素：音を作るコードを書く能力"

#: 09.1-Live-Coding-Fundamentals.md:11
msgid "An ability to write functions - CHECK!"
msgstr "チェック要素：ファンクション（関数）を作成する能力"

#: 09.1-Live-Coding-Fundamentals.md:12
msgid "An ability to use (named) threads - CHECK!"
msgstr "チェック要素：（名前付き）スレッドを使う能力"

#: 09.1-Live-Coding-Fundamentals.md:14
msgid ""
"Alrighty, let's get started. Let's live code our first sounds. We first need a"
" function containing the code we want to play. Let's start simple. We also wan"
"t to loop calls to that function in a thread:"
msgstr ""
"よーし、始めましょう。最初の音をライブコーディングしましょう。まず演奏したいコード含む関数が必要です。簡単なところから始めましょう。スレッドでその関数を呼び"
"出すループもほしいところです。"

#: 09.1-Live-Coding-Fundamentals.md:18
#, no-wrap
#, fuzzy
msgid ""
"define :my_sound do\n"
"  play 50\n"
"  sleep 1\n"
"end\n"
"in_thread(name: :looper) do\n"
"  loop do\n"
"    my_sound\n"
"  end\n"
"end"
msgstr ""
"define :my_loop do\n"
"  play 50\n"
"  sleep 1\n"
"end\n"
"in_thread(name: :looper) do\n"
"  loop do\n"
"    my_loop\n"
"  end\n"
"end"

#: 09.1-Live-Coding-Fundamentals.md:31
msgid ""
"If that looks a little too complicated to you, go back and re-read the section"
"s on functions and threads. It's not too complicated if you've already wrapped"
" your head around these things."
msgstr ""
"もし上のコードが少し複雑に見える場合は、ファンクション（関数）とスレッドのセクションに戻って復習してください。既にこれらを頭に焼き付けているならば、それほど"
"複雑ではないでしょう。"

#: 09.1-Live-Coding-Fundamentals.md:35
#, fuzzy
msgid ""
"What we have here is a function definition which just plays note 50 and sleeps"
" for a beat. We then define a named thread called `:looper` which just loops a"
"round calling `my_sound` repeatedly."
msgstr ""
"ここにあるものは、単に`play 50`を演奏し、ビートのために`sleep 1`を実行するファンクション（関数）です。そして、単に繰り返して定期的に`my"
"_loop`を呼び出す`:looper`という名前付きスレッドを定義しています。"

#: 09.1-Live-Coding-Fundamentals.md:39
msgid "If you run this code, you'll hear note 50 repeating again and again..."
msgstr "このコードを実行すると、音符50を何度も何度も繰り返します。"

#: 09.1-Live-Coding-Fundamentals.md:41
#, fuzzy
msgid "Changing it up"
msgstr "変えてみる"

#: 09.1-Live-Coding-Fundamentals.md:43
msgid ""
"Now, this is where the fun starts. Whilst the code is *still running* change 5"
"0 to another number, say 55, then press the Run button again. Woah! It changed"
"! Live!"
msgstr ""
"ここからが面白くなるところです。コードを*実行したままで*、50を別の数値55に変更し、もう一度`Run`ボタンを押してみましょう。わお！ 音が変化しました"
"ね！ ライブ！"

#: 09.1-Live-Coding-Fundamentals.md:47
#, fuzzy
msgid ""
"It didn't add a new layer because we're using named threads which only allow o"
"ne thread for each name. Also, the sound changed because we *redefined* the fu"
"nction. We gave `:my_sound` a new definition. When the `:looper` thread looped"
" around it simply called the new definition."
msgstr ""
"1つの名前に1つのスレッドしか実行されないので、新しいレイヤは追加されませんでした。また、ファンクション（関数）が*再定義*されることより、音が変化しました"
"。`:my_loop`は新しく定義され、`:looper`スレッドが新しい定義を繰り返し呼び出します。"

#: 09.1-Live-Coding-Fundamentals.md:52
msgid ""
"Try changing it again, change the note, change the sleep time. How about addin"
"g a `use_synth` statement? For example, change it to:"
msgstr "スリープ時間をや音符を変更し、再び試してみてください。`use_synth`を追加してみるのはどうでしょう？ たとえば、次のように変更してみてください。"

#: 09.1-Live-Coding-Fundamentals.md:55
#, no-wrap
#, fuzzy
msgid ""
"define :my_sound do\n"
"  use_synth :tb303\n"
"  play 50, release: 0.3\n"
"  sleep 0.25\n"
"end"
msgstr ""
"define :my_loop do\n"
"  use_synth :tb303\n"
"  play 50, release: 0.3\n"
"  sleep 0.25\n"
"end"

#: 09.1-Live-Coding-Fundamentals.md:63
msgid ""
"Now it sounds pretty interesting, but we can spice it up further. Instead of p"
"laying the same note again and again, try playing a chord:"
msgstr "かなり面白くなってきましたが、それをさらに盛り上げることができます。何度も何度も同じ音符を演奏する代わりに、和音を弾いてみましょう。"

#: 09.1-Live-Coding-Fundamentals.md:67
#, no-wrap
#, fuzzy
msgid ""
"define :my_sound do\n"
"  use_synth :tb303\n"
"  play chord(:e3, :minor), release: 0.3\n"
"  sleep 0.5\n"
"end"
msgstr ""
"define :my_loop do\n"
"  use_synth :tb303\n"
"  play chord(:e3, :minor), release: 0.3\n"
"  sleep 0.5\n"
"end"

#: 09.1-Live-Coding-Fundamentals.md:75
msgid "How about playing random notes from the chord:"
msgstr "和音からランダムな音符を演奏するのはどうでしょう。"

#: 09.1-Live-Coding-Fundamentals.md:77
#, no-wrap
#, fuzzy
msgid ""
"define :my_sound do\n"
"  use_synth :tb303\n"
"  play choose(chord(:e3, :minor)), release: 0.3\n"
"  sleep 0.25\n"
"end"
msgstr ""
"define :my_loop do\n"
"  use_synth :tb303\n"
"  play choose(chord(:e3, :minor)), release: 0.3\n"
"  sleep 0.25\n"
"end"

#: 09.1-Live-Coding-Fundamentals.md:85
msgid "Or using a random cutoff value:"
msgstr "またはランダムなカットオフ値を使用してみましょう。"

#: 09.1-Live-Coding-Fundamentals.md:87
#, no-wrap
#, fuzzy
msgid ""
"define :my_sound do\n"
"  use_synth :tb303\n"
"  play choose(chord(:e3, :minor)), release: 0.2, cutoff: rrand(60, 130)\n"
"  sleep 0.25\n"
"end"
msgstr ""
"define :my_loop do\n"
"  use_synth :tb303\n"
"  play choose(chord(:e3, :minor)), release: 0.2, cutoff: rrand(60, 130)\n"
"  sleep 0.25\n"
"end"

#: 09.1-Live-Coding-Fundamentals.md:95
msgid "Finally, add some drums:"
msgstr "最後に、ドラムを追加しましょう。"

#: 09.1-Live-Coding-Fundamentals.md:97
#, no-wrap
#, fuzzy
msgid ""
"define :my_sound do\n"
"  use_synth :tb303\n"
"  sample :drum_bass_hard, rate: rrand(0.5, 2)\n"
"  play choose(chord(:e3, :minor)), release: 0.2, cutoff: rrand(60, 130)\n"
"  sleep 0.25\n"
"end"
msgstr ""
"define :my_loop do\n"
"  use_synth :tb303\n"
"  sample :drum_bass_hard, rate: rrand(0.5, 2)\n"
"  play choose(chord(:e3, :minor)), release: 0.2, cutoff: rrand(60, 130)\n"
"  sleep 0.25\n"
"end"

#: 09.1-Live-Coding-Fundamentals.md:106
msgid "Now things are getting exciting!"
msgstr "どんどんおもしろくなってきましたね！"

#: 09.1-Live-Coding-Fundamentals.md:108
msgid ""
"However, before you jump up and start live coding with functions and threads, "
"stop what you're doing and read the next section on `live_loop` which will cha"
"nge the way you code in Sonic Pi forever..."
msgstr ""
"しかしながら、ファンクション（関数）とスレッドを使ったライブコーディングにステップアップする前に、一息ついて、Sonic Piでのコーディングを劇的に変えて"
"しまうかもしれない`live_loop`について次の章を読んでいきましょう。"

#: 09.2-Live-Loops.md:1
msgid "9.2 Live Loops"
msgstr "9.2 ライブループ"

#: 09.2-Live-Loops.md:3
msgid "Live Loops"
msgstr "ライブループ"

#: 09.2-Live-Loops.md:5
msgid ""
"Ok, so this section of the tutorial is the real gem. If you only read one sect"
"ion, it should be this one. If you read the previous section on Live Coding Fu"
"ndamentals, `live_loop` is a simple way of doing exactly that but without havi"
"ng to write so much."
msgstr ""
"このチュートリアルの中でもこの章は、最も重要です。もし1つの章だけを読むのであれば、この章でしょう。もし前の章でライブコーディングの基礎を読んでいるのであれ"
"ば、`live_loop`は、それと同じことを少ないコード量で簡単に実現できる方法と言えます。"

#: 09.2-Live-Loops.md:10
msgid ""
"If you didn't read the previous section, `live_loop` is the best way to jam wi"
"th Sonic Pi."
msgstr "前の章を読んでいない場合、`live_loop`はSonic Piでジャム（即興演奏）するための最良の方法でしょう。"

#: 09.2-Live-Loops.md:13
msgid "Let's play. Write the following in a new buffer:"
msgstr "演奏してみましょう。新しいBufferに次のように書いてください。"

#: 09.2-Live-Loops.md:15
#, no-wrap
msgid ""
"live_loop :foo do\n"
"  play 60\n"
"  sleep 1\n"
"end"
msgstr ""
"live_loop :foo do\n"
"  play 60\n"
"  sleep 1\n"
"end"

#: 09.2-Live-Loops.md:22
msgid ""
"Now press the Run button. You hear a basic beep every beat. Nothing fun there."
" However, don't press Stop just yet. Change the `60` to `65` and press Run aga"
"in."
msgstr ""
"`Run`ボタンを押してください。1拍毎に基本的なビープ音が鳴ります。これでは楽しくないのですが、まだ`Stop`を押さないでください。`60`を`65`へ"
"変更して、`Run`ボタンを押してください。"

#: 09.2-Live-Loops.md:26
msgid "Woah! It changed *automatically* without missing a beat. This is live coding."
msgstr "わお！ リズムを崩さずに*自動的に*変化しました。これがライブコーディングです。"

#: 09.2-Live-Loops.md:28
msgid ""
"Why not change it to be more bass like? Just update your code whilst it's play"
"ing:"
msgstr "もっとベースのように変えてみてはどうでしょう？ 演奏したままコードを更新しましょう。"

#: 09.2-Live-Loops.md:30
#, no-wrap
msgid ""
"live_loop :foo do\n"
"  use_synth :prophet\n"
"  play :e1, release: 8\n"
"  sleep 8\n"
"end"
msgstr ""
"live_loop :foo do\n"
"  use_synth :prophet\n"
"  play :e1, release: 8\n"
"  sleep 8\n"
"end"

#: 09.2-Live-Loops.md:38
msgid "Then hit Run."
msgstr "ここで*Run*ボタンを押してください。"

#: 09.2-Live-Loops.md:40
msgid "Let's make the cutoff move around:"
msgstr "カットオフを動かしてみましょう。"

#: 09.2-Live-Loops.md:42
#, no-wrap
msgid ""
"live_loop :foo do\n"
"  use_synth :prophet\n"
"  play :e1, release: 8, cutoff: rrand(70, 130)\n"
"  sleep 8\n"
"end"
msgstr ""
"live_loop :foo do\n"
"  use_synth :prophet\n"
"  play :e1, release: 8, cutoff: rrand(70, 130)\n"
"  sleep 8\n"
"end"

#: 09.2-Live-Loops.md:50
msgid "Hit Run again."
msgstr "`Run`ボタンをもう一度押しましょう。"

#: 09.2-Live-Loops.md:52
msgid "Add some drums:"
msgstr "ドラムを追加してみましょう。"

#: 09.2-Live-Loops.md:54
#, no-wrap
msgid ""
"live_loop :foo do\n"
"  sample :loop_garzul\n"
"  use_synth :prophet\n"
"  play :e1, release: 8, cutoff: rrand(70, 130)\n"
"  sleep 8\n"
"end"
msgstr ""
"live_loop :foo do\n"
"  sample :loop_garzul\n"
"  use_synth :prophet\n"
"  play :e1, release: 8, cutoff: rrand(70, 130)\n"
"  sleep 8\n"
"end"

#: 09.2-Live-Loops.md:63
msgid "Change the note from `e1` to `c1`:"
msgstr "`e1`から`c1`に音符を変更してみましょう。"

#: 09.2-Live-Loops.md:65
#, no-wrap
msgid ""
"live_loop :foo do\n"
"  sample :loop_garzul\n"
"  use_synth :prophet\n"
"  play :c1, release: 8, cutoff: rrand(70, 130)\n"
"  sleep 8\n"
"end"
msgstr ""
"live_loop :foo do\n"
"  sample :loop_garzul\n"
"  use_synth :prophet\n"
"  play :c1, release: 8, cutoff: rrand(70, 130)\n"
"  sleep 8\n"
"end"

#: 09.2-Live-Loops.md:74
msgid "Now stop listening to me and play around yourself! Have fun!"
msgstr "このあとは私の言うことを聞くのを止めて、自由に演奏してみましょう！ 楽しんでください！"

#: 09.3-Multiple-Live-Loops.md:1
msgid "9.3 Multiple Live Loops"
msgstr "9.3 マルチ・ライブループ"

#: 09.3-Multiple-Live-Loops.md:3
msgid "Multiple Live Loops"
msgstr "マルチ・ライブループ"

#: 09.3-Multiple-Live-Loops.md:5
msgid "Consider the following live loop:"
msgstr "次のライブループを考えていきましょう。"

#: 09.3-Multiple-Live-Loops.md:7
#, no-wrap
msgid ""
"live_loop :foo do\n"
"  play 50\n"
"  sleep 1\n"
"end"
msgstr ""
"live_loop :foo do\n"
"  play 50\n"
"  sleep 1\n"
"end"

#: 09.3-Multiple-Live-Loops.md:14
msgid ""
"You may have wondered why it needs the name `:foo`. This name is important bec"
"ause it signifies that this live loop is different from all other live loops."
msgstr ""
"なぜ`:foo`という名前をつける必要があるか疑問を持つかもしれません。この名前は、このライブループが他のすべてのライブループと異なっていることを示すために"
"重要です。"

#: 09.3-Multiple-Live-Loops.md:18
msgid "*There can never be two live loops running with the same name*."
msgstr "*同じ名前で実行中の2つのライブループが存在することはできません*。"

#: 09.3-Multiple-Live-Loops.md:20
msgid ""
"This means that if we want multiple concurrently running live loops, we just n"
"eed to give them different names:"
msgstr "これは、複数同時にライブループを実行したい場合、それぞれに異なる名前を付ける必要があることを意味します。"

#: 09.3-Multiple-Live-Loops.md:23
#, no-wrap
msgid ""
"live_loop :foo do\n"
"  use_synth :prophet\n"
"  play :c1, release: 8, cutoff: rrand(70, 130)\n"
"  sleep 8\n"
"end\n"
"live_loop :bar do\n"
"  sample :bd_haus\n"
"  sleep 0.5\n"
"end"
msgstr ""
"live_loop :foo do\n"
"  use_synth :prophet\n"
"  play :c1, release: 8, cutoff: rrand(70, 130)\n"
"  sleep 8\n"
"end\n"
"live_loop :bar do\n"
"  sample :bd_haus\n"
"  sleep 0.5\n"
"end"

#: 09.3-Multiple-Live-Loops.md:36
msgid ""
"You can now update and change each live loop independently and it all just wor"
"ks."
msgstr "各ライブループを個別に変更し更新できます。そしてすべてちゃんと動作します。"

#: 09.3-Multiple-Live-Loops.md:39
msgid "Syncing Live Loops"
msgstr "ライブループの同期"

#: 09.3-Multiple-Live-Loops.md:41
msgid ""
"One thing you might have already noticed is that live loops work automatically"
" with the thread cue mechanism we explored previously. Every time the live loo"
"p loops, it generates a new `cue` event with the name of the live loop. We can"
" therefore `sync` on these cues to ensure our loops are in sync without having"
" to stop anything."
msgstr ""
"既に気づいているかもしれませんが、ライブループは、以前に見てきたスレッドのcueのメカニズムを使用して自動的に動作します。ライブループがループするたびに、そ"
"れが新しい名前を持つライブループの`cue`を生成します。これにより、`cue`をきっかけに何も停止せずにサウンドのループを同期させることができます。"

#: 09.3-Multiple-Live-Loops.md:47
msgid "Consider this badly synced code:"
msgstr "次のような同期されていないコードを考えてみましょう。"

#: 09.3-Multiple-Live-Loops.md:49
#, no-wrap
msgid ""
"live_loop :foo do\n"
"  play :e4, release: 0.5\n"
"  sleep 0.4\n"
"end\n"
"live_loop :bar do\n"
"  sample :bd_haus\n"
"  sleep 1\n"
"end"
msgstr ""
"live_loop :foo do\n"
"  play :e4, release: 0.5\n"
"  sleep 0.4\n"
"end\n"
"live_loop :bar do\n"
"  sample :bd_haus\n"
"  sleep 1\n"
"end"

#: 09.3-Multiple-Live-Loops.md:61
msgid ""
"Let's see if we can fix the timing and sync without stopping it. First, let's "
"fix the `:foo` loop to make the sleep a factor of 1 - something like `0.5` wil"
"l do:"
msgstr "それを停止することなくタイミングと同期を修正することができるかを見てみましょう。まずは、`foo`ループ内の`sleep`の引数を0.5に変えてみましょう。"

#: 09.3-Multiple-Live-Loops.md:65
#, no-wrap
msgid ""
"live_loop :foo do\n"
"  play :e4, release: 0.5\n"
"  sleep 0.5\n"
"end\n"
"live_loop :bar do\n"
"  sample :bd_haus\n"
"  sleep 1\n"
"end"
msgstr ""
"live_loop :foo do\n"
"  play :e4, release: 0.5\n"
"  sleep 0.5\n"
"end\n"
"live_loop :bar do\n"
"  sample :bd_haus\n"
"  sleep 1\n"
"end"

#: 09.3-Multiple-Live-Loops.md:77
msgid ""
"We're not quite finished yet though - you'll notice that the beats don't quite"
" line up correctly. This is because the loops are *out of phase*. Let's fix th"
"at by syncing one to the other:"
msgstr ""
"まだ終わりではないですね。あなたはビートがまったく合っていないことに気付くでしょう。これはループが*ずれて*いるからです。他と同期するように、それを修正して"
"いきましょう。"

#: 09.3-Multiple-Live-Loops.md:81
#, no-wrap
msgid ""
"live_loop :foo do\n"
"  play :e4, release: 0.5\n"
"  sleep 0.5\n"
"end\n"
"live_loop :bar do\n"
"  sync :foo\n"
"  sample :bd_haus\n"
"  sleep 1\n"
"end"
msgstr ""
"live_loop :foo do\n"
"  play :e4, release: 0.5\n"
"  sleep 0.5\n"
"end\n"
"live_loop :bar do\n"
"  sync :foo\n"
"  sample :bd_haus\n"
"  sleep 1\n"
"end"

#: 09.3-Multiple-Live-Loops.md:94
msgid "Wow, everything is now perfectly in time - all without stopping."
msgstr "おおー、すべてを停止することなく完璧に同期しましたね。"

#: 09.3-Multiple-Live-Loops.md:96
msgid "Now, go forth and live code with live loops!"
msgstr "さあ、ライブループを使ってライブコーディングを始めましょう！"

#: 09.4-Ticking.md:1
msgid "9.4 Ticking"
msgstr "9.4 チック"

#: 09.4-Ticking.md:3
msgid "Ticking"
msgstr "チック"

#: 09.4-Ticking.md:5
msgid ""
"Something you'll likely find yourself doing a lot when live coding is looping "
"through rings. You'll be putting notes into rings for melodies, sleeps for rhy"
"thms, chord progressions, timbral variations, etc. etc."
msgstr ""
"ライブコーディングでリングをループしていて、気が付くとたくさんのことをしていたことはないでしょうか。例えば、メロディーの音符、リズムのためのスリープ時間、コ"
"ード進行や音色のバリエーションなどをリングに入れたり。"

#: 09.4-Ticking.md:9
msgid "Ticking Rings"
msgstr "リングのチック"

#: 09.4-Ticking.md:11
msgid ""
"Sonic Pi provides a *very* handy tool for working with rings within `live_loop"
"`s. It's called the tick system. In the section about the rings we were talkin"
"g about the counter that is constantly increasing, like a current beat number."
" Tick just implements this idea. It provides you with the ability to *tick thr"
"ough rings*. Let's look at an example:"
msgstr ""
"Sonic Piは`live_loop`の中でリングと一緒に使える*とても*手軽なツールを提供しています。それはチックシステムと呼ばれ、*tick thro"
"ugh rings（リングをチックタックと進める）* 機能を提供しています。次の例を見てください。"

#: 09.4-Ticking.md:17
#, no-wrap
msgid ""
"counter = 0\n"
"live_loop :arp do\n"
"  play (scale :e3, :minor_pentatonic)[counter], release: 0.1\n"
"  counter += 1\n"
"  sleep 0.125\n"
"end"
msgstr ""
"counter = 0\n"
"live_loop :arp do\n"
"  play (scale :e3, :minor_pentatonic)[counter], release: 0.1\n"
"  counter += 1\n"
"  sleep 0.125\n"
"end"

#: 09.4-Ticking.md:26
msgid "This is equivalent to:"
msgstr "上のコードは次のコードと同じです。"

#: 09.4-Ticking.md:28
#, no-wrap
msgid ""
"live_loop :arp do\n"
"  play (scale :e3, :minor_pentatonic).tick, release: 0.1\n"
"  sleep 0.125\n"
"end"
msgstr ""
"live_loop :arp do\n"
"  play (scale :e3, :minor_pentatonic).tick, release: 0.1\n"
"  sleep 0.125\n"
"end"

#: 09.4-Ticking.md:35
msgid ""
"Here, we're just grabbing the scale E3 minor pentatonic and ticking through ea"
"ch element. This is done by adding `.tick` to the end of the scale declaration"
". This tick is local to the live loop, so each live loop can have its own inde"
"pendent tick:"
msgstr ""
"ここでは、E3マイナーペンタトニックのスケールを作成し、各要素をチックしています。これは、`.tick`を`scale`の呼び出しの末尾に追加することによっ"
"て実現されています。チックはライブループの中でローカルであるため、個々のライブループは別々のチックを持つことができます。"

#: 09.4-Ticking.md:40
#, no-wrap
msgid ""
"live_loop :arp do\n"
"  play (scale :e3, :minor_pentatonic).tick, release: 0.1\n"
"  sleep 0.125\n"
"end\n"
"live_loop :arp2 do\n"
"  use_synth :dsaw\n"
"  play (scale :e2, :minor_pentatonic, num_octaves: 3).tick, release: 0.25\n"
"  sleep 0.25\n"
"end"
msgstr ""
"live_loop :arp do\n"
"  play (scale :e3, :minor_pentatonic).tick, release: 0.1\n"
"  sleep 0.125\n"
"end\n"
"live_loop :arp2 do\n"
"  use_synth :dsaw\n"
"  play (scale :e2, :minor_pentatonic, num_octaves: 3).tick, release: 0.25\n"
"  sleep 0.25\n"
"end"

#: 09.4-Ticking.md:53
msgid "Tick"
msgstr "標準関数としてのチック"

#: 09.4-Ticking.md:55
msgid "You can also call `tick` as a standard fn and use the value as an index:"
msgstr "`tick`はまた標準関数としても呼ぶことができ、その値はインデックスとして使うことができます。"

#: 09.4-Ticking.md:57
#, no-wrap
msgid ""
"live_loop :arp do\n"
"  idx = tick\n"
"  play (scale :e3, :minor_pentatonic)[idx], release: 0.1\n"
"  sleep 0.125\n"
"end"
msgstr ""
"live_loop :arp do\n"
"  idx = tick\n"
"  play (scale :e3, :minor_pentatonic)[idx], release: 0.1\n"
"  sleep 0.125\n"
"end"

#: 09.4-Ticking.md:65
msgid ""
"However, it is much nicer to call `.tick` at the end. The `tick` fn is for whe"
"n you want to do fancy things with the tick value and for when you want to use"
" ticks for other things than indexing into rings."
msgstr ""
"しかし、この場合は`.tick`を呼ぶほうが良いでしょう。`tick`関数の用途は、チックの値で手の込んだことをしたかったり、リングのインデックス以外にチッ"
"クの値を使いたかったりする場合ではないでしょうか。"

#: 09.4-Ticking.md:70
msgid "Look"
msgstr "ルック"

#: 09.4-Ticking.md:72
msgid ""
"The magical thing about tick is that not only does it return a new index (or t"
"he value of the ring at that index) it also makes sure that next time you call"
" tick, it's the next value. Take a look at the examples in the docs for `tick`"
" for many ways of working with this. However, for now, it's important to point"
" out that sometimes you'll want to just look at the current tick value and *no"
"t increase* it. This is available via the `look` fn. You can call `look` as a "
"standard fn or by adding `.look` to the end of a ring."
msgstr ""
"チックの魅力的なところは、それが新しいインデックス（もしくはそのインデックスにあるリングの値）を返すだけでなく、次にチックを呼んだときに必ず次の値を返すこと"
"を保証していることでしょう。このようなチックの動作は、様々な形で`tick`のドキュメントの例で見ることができるでしょう。しかし、ここで、チックの現在の値を"
"見たいだけで、値を*増加させたくない*の場合もあることを指摘することは重要でしょう。これは`look`関数により実現可能です。`look`は、標準関数として"
"呼んだり、リングの後ろに`.look`を付けたりできます。"

#: 09.4-Ticking.md:81
msgid "Naming Ticks"
msgstr "チックの名前付け"

#: 09.4-Ticking.md:83
msgid ""
"Finally, sometimes you'll need more than one tick per live loop. This is achie"
"ved by giving your tick a name:"
msgstr "最後に、1つのライブループに複数のチックが必要になることがあるかもしれません。これはチックに名前を付けることで実現できます。"

#: 09.4-Ticking.md:86
#, no-wrap
msgid ""
"live_loop :arp do\n"
"  play (scale :e3, :minor_pentatonic).tick(:foo), release: 0.1\n"
"  sleep (ring 0.125, 0.25).tick(:bar)\n"
"end"
msgstr ""
"live_loop :arp do\n"
"  play (scale :e3, :minor_pentatonic).tick(:foo), release: 0.1\n"
"  sleep (ring 0.125, 0.25).tick(:bar)\n"
"end"

#: 09.4-Ticking.md:93
msgid ""
"Here we're using two ticks one for the note to play and another for the sleep "
"time. As they're both in the same live loop, to keep them separate we need to "
"give them unique names. This is exactly the same kind of thing as naming `live"
"_loop`s - we just pass a symbol prefixed with a `:`. In the example above we c"
"alled one tick `:foo` and the other `:bar`. If we want to `look` at these we a"
"lso need to pass the name of the tick to `look`."
msgstr ""
"ここでは2つのチックを使っていて、1つは音符用に、もう1つはスリープ時間用にしています。これらのチックは同じライブループにあるので、別々にしておくためにユニ"
"ークな名前を与えています。これはちょうど`live_loop`に名前を付ける（`:`から始まるシンボル名を渡すだけ）のと同じことです。上の例では1つは`:f"
"oo`でチックを呼び出し、もう1つは`:bar`で呼び出しています。また、これらの値を`look`したい場合には、チックの名前を`look`に渡す必要があり"
"ます。"

#: 09.4-Ticking.md:101
msgid "Don't make it too complicated"
msgstr "複雑にしすぎないように"

#: 09.4-Ticking.md:103
msgid ""
"Most of the power in the tick system isn't useful when you get started. Don't "
"try and learn everything in this section. Just focus on ticking through a sing"
"le ring. That'll give you most of the joy and simplicity of ticking through ri"
"ngs in your `live_loop`s."
msgstr ""
"チックシステムの能力のほどんどは、最初のうちは役に立たないでしょう。このセクションの全ての内容を学習しようとしないでください。1つのリングでチックすることだ"
"けに集中するとよいでしょう。そうすることで、`live_loop`でリングをチックする簡単さや楽しみを得ることができるでしょう。"

#: 09.4-Ticking.md:108
msgid ""
"Take a look at the documentation for `tick` where there are many useful exampl"
"es and happy ticking!"
msgstr "`tick`のドキュメントには役に立つ例がたくさんあるので、それを見て楽しくチックを使ってみましょう！"

#: 10-State.md:1
msgid "10 Time State"
msgstr ""

#: 10-State.md:3
msgid "Time State"
msgstr ""

#: 10-State.md:5
msgid ""
"Often it is useful to have information that is *shared across multiple threads"
" or live loops*. For example, you might want to share a notion of the current "
"key, BPM or even more abstract concepts such as the current 'complexity' (whic"
"h you'd potentially interpret in different ways across different threads). We "
"also don't want to lose any of our existing determinism guarantees when doing "
"this. In other words, we'd still like to be able to share code with others and"
" know exactly what they'll hear when they run it. At the end of Section 5.6 of"
" this tutorial we briefly discussed why we *should not use variables to share "
"information across threads* due to a loss of determinism (in turn due to race "
"conditions)."
msgstr ""

#: 10-State.md:16
msgid ""
"Sonic Pi's solution to the problem of easily working with global variables in "
"a deterministic way is through a novel system it calls Time State. This might "
"sound complex and difficult (in fact, in the UK, programming with multiple thr"
"eads and shared memory is typically a university level subject). However, as y"
"ou'll see, just like playing your first note, *Sonic Pi makes it incredibly si"
"mple to share state across threads* whilst still keeping your programs *thread"
"-safe and deterministic.*."
msgstr ""

#: 10-State.md:24
msgid "Meet `get` and `set`..."
msgstr ""

#: 10.1-Set-and-Get.md:1
msgid "10.1 Set and Get"
msgstr ""

#: 10.1-Set-and-Get.md:3
msgid "Set and Get"
msgstr ""

#: 10.1-Set-and-Get.md:5
msgid ""
"Sonic Pi has a global memory store called Time State. The two main things you "
"do with it are to `set` information and `get` information. Let's dive deeper.."
"."
msgstr ""
"Sonic PiにはTime Stateというグローバルなメモリ領域があります。主に、情報を`se"
"t`したり、情報を`get`したりするためのものです。詳しく見てみましょう。"

#: 10.1-Set-and-Get.md:9
msgid "Set"
msgstr ""

#: 10.1-Set-and-Get.md:11
msgid "To store information into the Time State we need two things:"
msgstr "Time Stateに情報を保存するためには2つのことが必要です。"

#: 10.1-Set-and-Get.md:13
msgid "the information we want to store,"
msgstr "保存したい情報と、"

#: 10.1-Set-and-Get.md:14
msgid "a unique name (key) for the information."
msgstr "その情報のための独自の名前(キー)です。"

#: 10.1-Set-and-Get.md:16
msgid ""
"For example, we might want to store the number `3000` with the key `:intensity"
"`. This is possible using the `set` function:"
msgstr ""
"例えば、`3000`という数字を`:intensity`というキーで保存したいことがあるかもし"
"れません。 これは`set`関数を使うことで可能になります。"

#: 10.1-Set-and-Get.md:19
#, no-wrap
msgid "set :intensity, 3000"
msgstr ""

#: 10.1-Set-and-Get.md:23
msgid ""
"We can use any name for our key. If information has already been stored with t"
"hat key, our new `set` will override it:"
msgstr "キーにはどんな名前でも使うことができます。そのキーですでに情報が保存されてい"
"る場合は新しい`set`関数によって上書きすることができます。"

#: 10.1-Set-and-Get.md:26
#, no-wrap
msgid ""
"set :intensity, 1000\n"
"set :intensity, 3000"
msgstr ""

#: 10.1-Set-and-Get.md:31
msgid ""
"In the above example, as we stored both numbers under the same key, the last c"
"all to `set` 'wins', so the number associated with `:intensity` will be `3000`"
" as the first call to `set` is effectively overridden."
msgstr ""

#: 10.1-Set-and-Get.md:35
msgid "Get"
msgstr ""

#: 10.1-Set-and-Get.md:37
msgid ""
"To fetch information from the Time State we just need the key we used to `set`"
" it, which in our case is `:intensity`. We then just need to call `get[:intens"
"ity]` which we can see by printing out the result to the log:"
msgstr ""

#: 10.1-Set-and-Get.md:42
#, no-wrap
msgid "print get[:intensity] #=> prints 3000"
msgstr ""

#: 10.1-Set-and-Get.md:46
msgid ""
"Notice that calls to `get` can return information that was `set` in a previous"
" run. Once a piece of information has been `set` it is available until either "
"the information is overridden (just like we clobbered the `:intensity` value o"
"f `1000` to `3000` above) or Sonic Pi is closed."
msgstr ""

#: 10.1-Set-and-Get.md:52
#, fuzzy
msgid "Multiple Threads"
msgstr "スレッド"

#: 10.1-Set-and-Get.md:54
msgid ""
"The main benefit of the Time State system is that it can be safely used across"
" threads or live loops. For example, you could have one live loop setting info"
"rmation and another one getting it:"
msgstr ""

#: 10.1-Set-and-Get.md:58
#, no-wrap
#, fuzzy
msgid ""
"live_loop :setter do\n"
"  set :foo, rrand(70, 130)\n"
"  sleep 1\n"
"end\n"
"live_loop :getter do\n"
"  puts get[:foo]\n"
"  sleep 0.5\n"
"end"
msgstr "rrand"

#: 10.1-Set-and-Get.md:70
msgid ""
"The nice thing about using `get` and `set` across threads like this is that it"
" will always produce the same result every time you hit run. Go on, try it. Se"
"e if you get the following in your log:"
msgstr ""

#: 10.1-Set-and-Get.md:74
#, no-wrap
msgid ""
"{run: 0, time: 0.0}\n"
" └─ 125.72265625\n"
"{run: 0, time: 0.5}\n"
" └─ 125.72265625\n"
"{run: 0, time: 1.0}\n"
" └─ 76.26220703125\n"
"{run: 0, time: 1.5}\n"
" └─ 76.26220703125\n"
"{run: 0, time: 2.0}\n"
" └─ 114.93408203125\n"
"{run: 0, time: 2.5}\n"
" └─ 114.93408203125\n"
"{run: 0, time: 3.0}\n"
" └─ 75.6048583984375\n"
"{run: 0, time: 3.5}\n"
" └─ 75.6048583984375"
msgstr ""

#: 10.1-Set-and-Get.md:100
msgid ""
"Try running it a few times - see, it's the same every time. This is what we ca"
"ll deterministic behaviour and it's really very important when we want to shar"
"e our music as code and know that the person playing the code is hearing exact"
"ly what we wanted them to hear (just like playing an MP3 or internet stream so"
"unds the same for all listeners)."
msgstr ""

#: 10.1-Set-and-Get.md:107
msgid "A Simple Deterministic State System"
msgstr ""

#: 10.1-Set-and-Get.md:109
#, fuzzy
msgid ""
"Back in Section 5.6 we discussed why using variables across threads can lead t"
"o random behaviour. This stops us from being able to reliably reproduce code s"
"uch as this:"
msgstr "rand"

#: 10.1-Set-and-Get.md:113
#, no-wrap
msgid ""
"## An Example of Non-Deterministic Behaviour\n"
"## (due to race conditions caused by multiple\n"
"## live loops manipulating the same variable\n"
"## at the same time).\n"
"##  \n"
"## If you run this code you'll notice\n"
"## that the list that's printed is\n"
"## not always sorted!\n"
"a = (ring 6, 5, 4, 3, 2, 1)\n"
"live_loop :shuffled do\n"
"  a = a.shuffle\n"
"  sleep 0.5\n"
"end\n"
"live_loop :sorted do\n"
"  a = a.sort\n"
"  sleep 0.5\n"
"  puts \"sorted: \", a\n"
"end"
msgstr ""

#: 10.1-Set-and-Get.md:136
msgid "Let's take a look at how this might look using `get` and `set`:"
msgstr ""

#: 10.1-Set-and-Get.md:138
#, no-wrap
msgid ""
"## An Example of Deterministic Behaviour\n"
"## (despite concurrent access of shared state)\n"
"## using Sonic Pi's new Time State system.\n"
"##\n"
"## When this code is executed, the list that's\n"
"## printed is always sorted!\n"
"set :a, (ring 6, 5, 4, 3, 2, 1)\n"
"live_loop :shuffled do\n"
"  set :a, get[:a].shuffle\n"
"  sleep 0.5\n"
"end\n"
"live_loop :sorted do\n"
"  set :a, get[:a].sort\n"
"  sleep 0.5\n"
"  puts \"sorted: \", get[:a]\n"
"end"
msgstr ""

#: 10.1-Set-and-Get.md:159
msgid ""
"Notice how this code is pretty much identical to the version using a variable "
"before it. However when you run the code, it behaves as you would expect with "
"any typical Sonic Pi code - *it does the same thing every time* in this case t"
"hanks to the Time State system."
msgstr ""

#: 10.1-Set-and-Get.md:164
msgid ""
"Therefore, when sharing information across live loops and threads, use `get` a"
"nd `set` instead of variables for deterministic, reproducible behaviour."
msgstr ""

#: 10.2-Sync.md:1
msgid "10.2 Sync"
msgstr ""

#: 10.2-Sync.md:3
msgid "Sync"
msgstr ""

#: 10.2-Sync.md:5
msgid ""
"Section 5.7 introduced the functions `cue` and `sync` when dealing with the is"
"sue of synchronising threads. What it didn't explain was that it is the Time S"
"tate system which provides this functionality. It just so happens that `set` i"
"s actually a variation of `cue` and is built on top of the same core functiona"
"lity which is to insert information into the Time State system. Additionally, "
"`sync` is also designed in such a way that it works seamlessly with Time State"
" - any information that we plan to store in Time State we can sync on. In othe"
"r words - *we `sync` on events yet to be inserted into Time State*."
msgstr ""

#: 10.2-Sync.md:15
msgid "Waiting for Events"
msgstr ""

#: 10.2-Sync.md:17
msgid ""
"Let's take a quick look at how to use `sync` to wait for new events to be adde"
"d to Time State:"
msgstr ""

#: 10.2-Sync.md:20
#, no-wrap
#, fuzzy
msgid ""
"in_thread do\n"
"  sync :foo\n"
"  sample :ambi_lunar_land\n"
"end\n"
"sleep 2\n"
"set :foo, 1"
msgstr "sample :ambi_lunar_land"

#: 10.2-Sync.md:31
#, fuzzy
msgid ""
"In this example first we create a thread which waits for a `:foo` event to be "
"added to the Time State. After this thread declaration we sleep for 2 beats an"
"d then `set` `:foo` to be `1`. This then releases the `sync` which then moves "
"to the next line which is to trigger the `:ambi_lunar_land` sample."
msgstr "foo"

#: 10.2-Sync.md:37
msgid ""
"Note that `sync` always waits for *future events* and that it will block the c"
"urrent thread waiting for a new event. Also, it will inherit the logical time "
"of the thread which triggered it via `set` or `cue` so it may also be used to "
"sync time."
msgstr ""

#: 10.2-Sync.md:42
msgid "Passing values into the Future"
msgstr ""

#: 10.2-Sync.md:44
#, fuzzy
msgid ""
"In the example above we set `:foo` to `1` which we did nothing with. We can ac"
"tually get this value from the thread calling `sync`:"
msgstr "foo"

#: 10.2-Sync.md:47
#, no-wrap
#, fuzzy
msgid ""
"in_thread do\n"
"  amp = sync :foo\n"
"  sample :ambi_lunar_land, amp: amp\n"
"end\n"
"sleep 2\n"
"set :foo, 0.5"
msgstr "sample :ambi_lunar_land"

#: 10.2-Sync.md:58
msgid ""
"Note that values that are passed through `set` and `cue` must be thread safe -"
" i.e. immutable rings, numbers, symbols or frozen strings. Sonic Pi will throw"
" an error if the value you are attempting to store in the Time State is not va"
"lid."
msgstr ""

#: 10.3-Pattern-Matching.md:1
msgid "10.3 Pattern Matching"
msgstr ""

#: 10.3-Pattern-Matching.md:3
msgid "Pattern Matching"
msgstr "パターン マッチング"

#: 10.3-Pattern-Matching.md:5
#, fuzzy
msgid ""
"When getting and setting information into the Time State, it's possible to use"
" more complex keys than basic symbols such as `:foo` and `:bar`. You can also "
"use URL style strings called paths such as `\"/foo/bar/baz\"`. Once we start wor"
"king with paths, we can then start taking advantage of Sonic Pi's sophisticate"
"d pattern matching system to `get` and `sync` with 'similar' rather than 'iden"
"tical' paths. Let's take a look."
msgstr "foo"

#: 10.3-Pattern-Matching.md:13
msgid "Match any path segment"
msgstr "あらゆるpath要素へのマッチ"

#: 10.3-Pattern-Matching.md:15
msgid "Let's assume we want to wait for the next event that has three path segments:"
msgstr "pathが3つに区切られている次のイベントを待ちたいとしましょう。"

#: 10.3-Pattern-Matching.md:17
#, no-wrap
msgid "sync \"/*/*/*\""
msgstr ""

#: 10.3-Pattern-Matching.md:21
msgid ""
"This will match any Time State event with exactly three path segments, regardl"
"ess of their names. For example:"
msgstr "このパターンはちょうど3つの区分を持つpathならば, その区分の名前に関わらずどんなTime Stateイベントにもマッチします。 例えば:"

#: 10.3-Pattern-Matching.md:24 10.3-Pattern-Matching.md:46
#: 10.3-Pattern-Matching.md:68 10.3-Pattern-Matching.md:78
msgid "`cue \"/foo/bar/baz\"`"
msgstr "`cue \"/foo/bar/baz\"`"

#: 10.3-Pattern-Matching.md:25
msgid "`cue \"/foo/baz/quux\"`"
msgstr "`cue \"/foo/baz/quux\"`"

#: 10.3-Pattern-Matching.md:26
msgid "`cue \"/eggs/beans/toast\"`"
msgstr ""

#: 10.3-Pattern-Matching.md:27
msgid "`cue \"/moog/synths/rule\"`"
msgstr ""

#: 10.3-Pattern-Matching.md:29
msgid ""
"However, it will *not* match paths with fewer or more path segments. The follo"
"wing will not match:"
msgstr "しかし、区分の数が少なかったり多かったりするpathにはマッチしません。 "
"例えば以下のものにはマッチしないでしょう:"

#: 10.3-Pattern-Matching.md:32
msgid "`cue \"/foo/bar\"`"
msgstr "`cue \"/foo/bar\"`"

#: 10.3-Pattern-Matching.md:33
msgid "`cue \"/foo/baz/quux/quaax\"`"
msgstr "`cue \"/foo/baz/quux/quaax\"`"

#: 10.3-Pattern-Matching.md:34
msgid "`cue \"/eggs\"`"
msgstr ""

#: 10.3-Pattern-Matching.md:36
msgid ""
"Each `*` means *any content*. So we could match paths with just one segment wi"
"th `/*` or paths with five segments with `/*/*/*/*/*`"
msgstr ""
"それぞれの`*`は「あらゆるもの」を意味しています。 なので、"
"区分が一つだけのpathには `/*` "
"でマッチでき、5つの区分を持つpathには次のパターンでマッチできます: "
"`/*/*/*/*/*`"

#: 10.3-Pattern-Matching.md:38
msgid "Matching partial segments"
msgstr "部分的なパス要素へのマッチング"

#: 10.3-Pattern-Matching.md:40
#, fuzzy
msgid ""
"If we know what the segment is going to start or finish with, we can use a `*`"
" in addition to a partial segment name. For example: `\"/foo/b*/baz\"` will matc"
"h any path that has three segments, the first of which is `foo`, the last `baz"
"` and the middle segment can be anything that starts with `b`. So, it would ma"
"tch:"
msgstr "foo"

#: 10.3-Pattern-Matching.md:47
#, fuzzy
msgid "`cue \"/foo/baz/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:48
#, fuzzy
msgid "`cue \"/foo/beans/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:50
msgid "However, it wouldn't match the following:"
msgstr "しかし、以下のものにはマッチしないでしょう："

#: 10.3-Pattern-Matching.md:52
#, fuzzy
msgid "`cue \"/foo/flibble/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:53
#, fuzzy
msgid "`cue \"/foo/abaz/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:54
#, fuzzy
msgid "`cue \"/foo/beans/baz/eggs\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:56
#, fuzzy
msgid ""
"You can also place the `*` at the start of the segment to specify the last cha"
"racters of a segment: `\"/foo/*zz/baz\"` which will match any 3 segment `cue` or"
" `set` where the first segment is `foo`, the last is `baz` and the middle segm"
"ent ends with `zz` such as `\"cue \"/foo/whizz/baz\"`."
msgstr "foo"

#: 10.3-Pattern-Matching.md:62
msgid "Matching Nested Path Segments"
msgstr "ネストされたpath要素へのマッチ"

#: 10.3-Pattern-Matching.md:64
#, fuzzy
msgid ""
"Sometimes you don't know how many path segments you want to match. In these ca"
"ses you can use the powerful double star: `**` such as `\"/foo/**/baz\"` which w"
"ill match:"
msgstr "foo"

#: 10.3-Pattern-Matching.md:69
#, fuzzy
msgid "`cue \"/foo/bar/beans/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:70
#, fuzzy
msgid "`cue \"/foo/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:71
#, fuzzy
msgid "`cue \"/foo/a/b/c/d/e/f/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:73
msgid "Matching Single Letters"
msgstr "一文字へのマッチング"

#: 10.3-Pattern-Matching.md:75
msgid ""
"You can use the `?` character to match against a single char such as `\"/?oo/ba"
"r/baz\"` which will match:"
msgstr "1文字へのマッチングには `?` の文字を使うことができ、`\"/?oo/bar/baz\"` "
"は次のようにマッチします:"

#: 10.3-Pattern-Matching.md:79
msgid "`cue \"/goo/bar/baz\"`"
msgstr ""

#: 10.3-Pattern-Matching.md:80
msgid "`cue \"/too/bar/baz\"`"
msgstr ""

#: 10.3-Pattern-Matching.md:81
msgid "`cue \"/woo/bar/baz\"`"
msgstr ""

#: 10.3-Pattern-Matching.md:83
msgid "Matching Multiple Words"
msgstr "複数の文字へのマッチング"

#: 10.3-Pattern-Matching.md:85
#, fuzzy
msgid ""
"If you know that a segment may be one of a select number of words, you can use"
" the `{` and `}` matchers to specify a list of choices such as `\"/foo/{bar,bea"
"ns,eggs}/quux\"` which will only match the following:"
msgstr "foo"

#: 10.3-Pattern-Matching.md:89
#, fuzzy
msgid "`cue \"/foo/bar/quux\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:90
#, fuzzy
msgid "`cue \"/foo/beans/quux\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:91
#, fuzzy
msgid "`cue \"/foo/eggs/quux\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:93
msgid "Matching Multiple Letters"
msgstr "複数の文字へのマッチング"

#: 10.3-Pattern-Matching.md:95
#, fuzzy
msgid ""
"Finally, you can match against a selection of letters if you use the `[` and `"
"]` matchers to specify a list of choices such as `\"/foo/[abc]ux/baz\"` which wi"
"ll match only:"
msgstr "foo"

#: 10.3-Pattern-Matching.md:99 10.3-Pattern-Matching.md:106
#, fuzzy
msgid "`cue \"/foo/aux/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:100 10.3-Pattern-Matching.md:107
#, fuzzy
msgid "`cue \"/foo/bux/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:101 10.3-Pattern-Matching.md:108
#, fuzzy
msgid "`cue \"/foo/cux/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:104
#, fuzzy
msgid ""
"You can also use the `-` character to specify ranges of letters. For example `"
"\"/foo/[a-e]ux/baz\"` which will match only:"
msgstr "foo"

#: 10.3-Pattern-Matching.md:109
#, fuzzy
msgid "`cue \"/foo/dux/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:110
#, fuzzy
msgid "`cue \"/foo/eux/baz\"`"
msgstr "foo"

#: 10.3-Pattern-Matching.md:112
msgid "Combining Matchers"
msgstr ""

#: 10.3-Pattern-Matching.md:114
msgid ""
"When calling `sync` or `get` you are free to combine matchers in any order you"
" see fit to powerfully match any Time State event created by `cue` or `set`. L"
"et's look at a crazy example:"
msgstr ""
"`sync`または`get`を呼び出している時には、マッチング規則を自由な順番に組み合わ"
"せて`cue`や`set`で生まれるどんなTime "
"Stateイベントにもパワフルにマッチさせることができます。 "
"すごい例を見てみましょう。"

#: 10.3-Pattern-Matching.md:118
#, no-wrap
#, fuzzy
msgid ""
"in_thread do\n"
"  sync \"/?oo/[a-z]*/**/ba*/{quux,quaax}/\"\n"
"  sample :loop_amen\n"
"end\n"
"sleep 1\n"
"cue \"/foo/beans/a/b/c/d/e/bark/quux/\""
msgstr "sample :loop_amen"

#: 10.3-Pattern-Matching.md:129
msgid "OSC Pattern Matching"
msgstr "OSC パターンマッチング"

#: 10.3-Pattern-Matching.md:131
msgid ""
"For those curious, these matching rules are based on the Open Sound Control pa"
"ttern matching specification which is explained in detail here: http://opensou"
"ndcontrol.org/spec-1_0"
msgstr ""
"気になる人のために説明すると、これらのマッチング規則はこのリンク先に詳しく書かれているOpen Sound Control "
"パターンマッチング仕様に基づいています: http://opensoundcontrol.org/spec-1_0"

#: 11-MIDI.md:1
msgid "11 MIDI"
msgstr ""

#: 11-MIDI.md:3
msgid "MIDI"
msgstr ""

#: 11-MIDI.md:5
msgid ""
"Once you've mastered converting code to music, you might wonder - what's next?"
" Sometimes the constraints of working purely within Sonic Pi's syntax and soun"
"d system can be exciting and put you into a new creative position. However, so"
"metimes it is essential to break out of the code into the real world. We want "
"two extra things:"
msgstr ""
"さて、コードを音楽に変換することをマスターしたあなたはこう思うかもしれません—"
"次は何をすればいいんだろう？ Sonic Piの構文やサウンドシステムの中で作業すると"
"いう制約は時に刺激的で、新しい創造性をもたらすこともあるでしょう。しかし、コ"
"ードを現実世界に持ち出すことも時には必要なのです。私たちが欲しいのは次の2つの"
"追加要素です。"

#: 11-MIDI.md:11
msgid ""
"To be able to convert actions in the real world into Sonic Pi events to code w"
"ith"
msgstr "現実世界での行動をSonic "
"Piのイベントに変換し、コーディングできるようになること"

#: 11-MIDI.md:12
msgid ""
"To be able to use Sonic Pi's strong timing model and semantics to control and "
"manipulate objects in the real world"
msgstr ""

#: 11-MIDI.md:14
msgid ""
"Luckily there's a protocol that's been around since the 80s that enables exact"
"ly this kind of interaction - MIDI. There's an incredible number of external d"
"evices including keyboards, controllers, sequencers, and pro audio software th"
"at all support MIDI. We can use MIDI to receive data and also use it to send d"
"ata."
msgstr ""

#: 11-MIDI.md:20
msgid ""
"Sonic Pi provides full support for the MIDI protocol enabling you to connect y"
"our live code to the real world. Let's explore it further..."
msgstr ""

#: 11.1-MIDI-In.md:1
msgid "11.1 MIDI In"
msgstr "11.1 MIDI入力"

#: 11.1-MIDI-In.md:3
msgid "MIDI In"
msgstr "MIDI 入力"

#: 11.1-MIDI-In.md:5
msgid ""
"In this section we will learn how to connect a MIDI controller to send events "
"into Sonic Pi to control our synths and sounds. Go and grab a MIDI controller "
"such as a keyboard or control surface and let's get physical!"
msgstr ""
"この章では、MIDIコントローラを接続し、シンセや音をコントロールするためにSonic "
"Piへイベントを送信する方法を学びます。キーボード、またはコントローラを接続して実際に動かしてみましょう！"

#: 11.1-MIDI-In.md:11
msgid "Connecting a MIDI Controller"
msgstr "MIDIコントローラーの接続"

#: 11.1-MIDI-In.md:13
msgid ""
"In order to get information from an external MIDI device into Sonic Pi we firs"
"t need to connect it to our computer. Typically this will be via a USB connect"
"ion, although older equipment will have a 5-pin DIN connector for which you'll"
" need hardware support for your computer (for example, some sound cards have M"
"IDI DIN connectors). Once you've connected your device, launch Sonic Pi and ta"
"ke a look at the IO section of the Preferences panel. You should see your devi"
"ce listed there. If not, try hitting the 'Reset MIDI' button and see if it app"
"ears. If you're still not seeing anything, the next thing to try is to consult"
" your operating system's MIDI config to see if it sees your device. Failing al"
"l that, feel free to ask questions in our friendly forums: https://in-thread.s"
"onic-pi.net"
msgstr ""

#: 11.1-MIDI-In.md:26
msgid "Receiving MIDI Events"
msgstr ""

#: 11.1-MIDI-In.md:28
msgid ""
"Once your device is connected, Sonic Pi will automatically receive events. You"
" can see for yourself by manipulating your MIDI device and looking at the cue "
"logger in the bottom right of the application window below the log (if this is"
"n't visible go to Preferences->Editor->Show & Hide and enable the 'Show cue lo"
"g' tickbox). You'll see a stream of events such as:"
msgstr ""

#: 11.1-MIDI-In.md:35
#, no-wrap
msgid ""
"/midi:nanokey2_keyboard:0:1/note_off  [55, 64]\n"
"/midi:nanokey2_keyboard:0:1/note_on   [53, 102]\n"
"/midi:nanokey2_keyboard:0:1/note_off  [57, 64]\n"
"/midi:nanokey2_keyboard:0:1/note_off  [53, 64]\n"
"/midi:nanokey2_keyboard:0:1/note_on   [57, 87]\n"
"/midi:nanokey2_keyboard:0:1/note_on   [55, 81]\n"
"/midi:nanokey2_keyboard:0:1/note_on   [53, 96]\n"
"/midi:nanokey2_keyboard:0:1/note_off  [55, 64]"
msgstr ""

#: 11.1-MIDI-In.md:46
msgid ""
"Once you can see a stream of messages like this, you've successfully connected"
" your MIDI device. Congratulations, let's see what we can do with it!"
msgstr ""

#: 11.1-MIDI-In.md:50
msgid "MIDI Time State"
msgstr ""

#: 11.1-MIDI-In.md:52
msgid ""
"These events are broken into two sections. Firstly there's the name of the eve"
"nt such as `/midi:nanokey2_keyboard:0:1/note_on` and secondly there's the valu"
"es of the event such as `[18, 62]`. Interestingly, these are the two things we"
" need to store information in Time State. *Sonic Pi automatically inserts inco"
"ming MIDI events into Time State*. This means you can `get` the latest MIDI va"
"lue and also `sync` waiting for the next MIDI value using everything we learne"
"d in section 10 of this tutorial."
msgstr ""

#: 11.1-MIDI-In.md:60
#, fuzzy
msgid "Controlling Code"
msgstr "エフェクトの制御"

#: 11.1-MIDI-In.md:62
msgid ""
"Now we've connected a MIDI device, seen its events in the cue log and discover"
"ed that our knowledge of Time State is all we need to work with the events, we"
" can now start having fun. Let's build a simple MIDI piano:"
msgstr ""

#: 11.1-MIDI-In.md:67
#, no-wrap
msgid ""
"live_loop :midi_piano do\n"
"  note, velocity = sync \"/midi:nanokey2_keyboard:0:1/note_on\"\n"
"  synth :piano, note: note\n"
"end"
msgstr ""

#: 11.1-MIDI-In.md:74
msgid ""
"There's a few things going on in the code above including some issues. Firstly"
", we have a simple `live_loop` which will repeat forever running the code betw"
"een the `do`/`end` block. This was introduced in Section 9.2. Secondly, we're "
"calling `sync` to wait for the next matching Time State event. We use a string"
" representing the MIDI message we're looking for (which is the same as was dis"
"played in the cue logger). Notice that this long string is provided to you by "
"Sonic Pi's autocompletion system, so you don't have to type it all out by hand"
". In the log we saw that there were two values for each MIDI note on event, so"
" we assign the result to two separate variables `note` and `velocity`. Finally"
" we trigger the `:piano` synth passing our note."
msgstr ""

#: 11.1-MIDI-In.md:86
msgid ""
"Now, you try it. Type in the code above, replace the sync key with a string ma"
"tching your specific MIDI device and hit Run. Hey presto, you have a working p"
"iano! However, you'll probably notice a couple of problems: firstly all the no"
"tes are the same volume regardless of how hard you hit the keyboard. This can "
"be easily fixed by using the velocity MIDI value and converting it to an ampli"
"tude. Given that MIDI has a range of 0->127, to convert this number to a value"
" between 0->1 we just need to divide it by 127:"
msgstr ""

#: 11.1-MIDI-In.md:95
#, no-wrap
msgid ""
"live_loop :midi_piano do\n"
"  note, velocity = sync \"/midi:nanokey2_keyboard:0:1/note_on\"\n"
"  synth :piano, note: note, amp: velocity / 127.0\n"
"end"
msgstr ""

#: 11.1-MIDI-In.md:102
msgid ""
"Update the code and hit Run again. Now the velocity of the keyboard is honoure"
"d. Next, let's get rid of that pesky pause."
msgstr ""

#: 11.1-MIDI-In.md:105
msgid "Removing Latency"
msgstr ""

#: 11.1-MIDI-In.md:107
msgid ""
"Before we can remove the pause, we need to know why it's there. In order to ke"
"ep all the synths and FX well-timed across a variety of differently capable CP"
"Us, Sonic Pi schedules the audio *in advance* by 0.5s by default. (Note that t"
"his added latency can be configured via the fns `set_sched_ahead_time!` and `u"
"se_sched_ahead_time`). This 0.5s latency is being added to our `:piano` synth "
"triggers as it is added to all synths triggered by Sonic Pi. Typically we real"
"ly want this added latency as it means all synths will be well timed. However,"
" this only makes sense for synths triggered by code using `play` and `sleep`. "
"In this case, we're actually triggering the `:piano` synth with our external M"
"IDI device and therefore don't want Sonic Pi to control the timing for us. We "
"can turn off this latency with the command `use_real_time` which disables the "
"latency for the current thread. This means you can use real time mode for live"
" loops that have their timing controlled by `sync`ing with external devices, a"
"nd keep the default latency for all other live loops. Let's see:"
msgstr ""

#: 11.1-MIDI-In.md:124
#, no-wrap
msgid ""
"live_loop :midi_piano do\n"
"  use_real_time\n"
"  note, velocity = sync \"/midi:nanokey2_keyboard:0:1/note_on\"\n"
"  synth :piano, note: note, amp: velocity / 127.0\n"
"end"
msgstr ""

#: 11.1-MIDI-In.md:132
msgid ""
"Update your code to match the code above and hit Run again. Now we have a low "
"latency piano with variable velocity coded in just 5 lines. Wasn't that easy!"
msgstr ""

#: 11.1-MIDI-In.md:136
#, fuzzy
msgid "Getting Values"
msgstr "入門"

#: 11.1-MIDI-In.md:138
msgid ""
"Finally, as our MIDI events are going straight into the Time State, we can als"
"o use the `get` fn to retrieve the last seen value. This doesn't block the cur"
"rent thread and returns `nil` if there's no value to be found (which you can o"
"verride by passing a default value - see the docs for `get`). Remember that yo"
"u can call `get` in any thread at any time to see the latest matching Time Sta"
"te value. You can even use `time_warp` to jump back in time and call `get` to "
"see past events..."
msgstr ""

#: 11.1-MIDI-In.md:147
msgid "Now You are in Control"
msgstr ""

#: 11.1-MIDI-In.md:149
#, fuzzy
msgid ""
"The exciting thing now is that you can now use the same code structures to `sy"
"nc` and `get` MIDI information from any MIDI device and do whatever you want w"
"ith the values. You can now choose what your MIDI device will do!"
msgstr "choose：選択"

#: 11.2-MIDI-Out.md:1
msgid "11.2 MIDI Out"
msgstr ""

#: 11.2-MIDI-Out.md:3
msgid "MIDI Out"
msgstr ""

#: 11.2-MIDI-Out.md:5
msgid ""
"In addition to receiving MIDI events we can also send out MIDI events to trigg"
"er and control external hardware synths, keyboards and other devices. Sonic Pi"
" provides a full set of fns for sending various MIDI messages such as:"
msgstr ""

#: 11.2-MIDI-Out.md:9
msgid "Note on - `midi_note_on`"
msgstr ""

#: 11.2-MIDI-Out.md:10
msgid "Note off - `midi_note_off`"
msgstr ""

#: 11.2-MIDI-Out.md:11
msgid "Control change - `midi_cc`"
msgstr ""

#: 11.2-MIDI-Out.md:12
msgid "Pitch bend - `midi_pitch_bend`"
msgstr ""

#: 11.2-MIDI-Out.md:13
msgid "Clock ticks - `midi_clock_tick`"
msgstr ""

#: 11.2-MIDI-Out.md:15
msgid ""
"There are many other supported MIDI messages too - check out the API documenta"
"tion for all the other fns that start with `midi_`."
msgstr ""

#: 11.2-MIDI-Out.md:18
msgid "Connecting to a MIDI Device"
msgstr ""

#: 11.2-MIDI-Out.md:20
msgid ""
"In order to send a MIDI message to an external device, we must first have conn"
"ected it. Check out the subsection 'Connecting a MIDI Controller' in section 1"
"1.1 for further details. Note that if you're using USB, connecting to a device"
" which you're sending to (rather than receiving from) is the same procedure. H"
"owever, if you're using the classic DIN connectors, make sure you connect to t"
"he MIDI out port of your computer. You should see your MIDI device listed in t"
"he preferences pane."
msgstr ""

#: 11.2-MIDI-Out.md:29
msgid "Sending MIDI events"
msgstr ""

#: 11.2-MIDI-Out.md:31
msgid ""
"The many `midi_*` fns work just like `play`, `sample` and `synth` in that they"
" send a message at the current (logical) time. For example, to spread out call"
"s to the `midi_*` fns you need to use `sleep` just like you did with `play`. L"
"et's take a look:"
msgstr ""

#: 11.2-MIDI-Out.md:36
#, no-wrap
msgid "midi_note_on :e3, 50"
msgstr ""

#: 11.2-MIDI-Out.md:40
msgid ""
"This will send a MIDI note on event to the connected MIDI device with velocity"
" 50. (Note that Sonic Pi will automatically convert notes in the form `:e3` to"
" their corresponding MIDI number such as 52 in this case.)"
msgstr ""

#: 11.2-MIDI-Out.md:44
msgid ""
"If your connected MIDI device is a synthesiser, you should be able to hear it "
"playing a note. To disable it use `midi_note_off`:"
msgstr ""

#: 11.2-MIDI-Out.md:47
#, no-wrap
msgid "midi_note_off :e3"
msgstr ""

#: 11.2-MIDI-Out.md:51
msgid "Selecting a MIDI device"
msgstr ""

#: 11.2-MIDI-Out.md:53
msgid ""
"By default, Sonic Pi will send each MIDI message to all connected devices on a"
"ll MIDI channels. This is to make it easy to work with a single connected devi"
"ce without having to configure anything. However, sometimes a MIDI device will"
" treat MIDI channels in a special way (perhaps each note has a separate channe"
"l) and also you may wish to connect more than one MIDI device at the same time"
". In more complicated setups, you may wish to be more selective about which MI"
"DI device receives which message(s) and on which channel."
msgstr ""

#: 11.2-MIDI-Out.md:62
msgid ""
"We can specify which device to send to using the `port:` opt, using the device"
" name as displayed in the preferences:"
msgstr ""

#: 11.2-MIDI-Out.md:65
#, no-wrap
msgid "midi_note_on :e3, port: \"moog_minitaur\""
msgstr ""

#: 11.2-MIDI-Out.md:69
msgid ""
"We can also specify which channel to send to using the `channel:` opt (using a"
" value in the range 1-16):"
msgstr ""

#: 11.2-MIDI-Out.md:72
#, no-wrap
msgid "midi_note_on :e3, channel: 3"
msgstr ""

#: 11.2-MIDI-Out.md:76
msgid ""
"Of course we can also specify both at the same time to send to a specific devi"
"ce on a specific channel:"
msgstr ""

#: 11.2-MIDI-Out.md:79
#, no-wrap
msgid "midi_note_on :e3, port: \"moog_minitaur\", channel: 5"
msgstr ""

#: 11.2-MIDI-Out.md:83
msgid "MIDI Studio"
msgstr ""

#: 11.2-MIDI-Out.md:85
msgid ""
"Finally, a really fun thing to do is to connect the audio output of your MIDI "
"synthesiser to one of the audio inputs of your soundcard. You can then control"
" your synth with code using the `midi_*` fns and also manipulate the audio usi"
"ng `live_audio` and FX:"
msgstr ""

#: 11.2-MIDI-Out.md:90
#, no-wrap
#, fuzzy
msgid ""
"with_fx :reverb, room: 1 do\n"
"  live_audio :moog\n"
"end\n"
"live_loop :moog_trigger do\n"
"  midi (octs :e1, 3).tick, sustain: 0.1\n"
"  sleep 0.125\n"
"end"
msgstr "reverb,"

#: 11.2-MIDI-Out.md:101
msgid ""
"(The fn `midi` is available as a handy shortcut to sending both note on and no"
"te off events with a single command. Check out its documentation for further i"
"nformation)."
msgstr ""

#: 12-OSC.md:1
msgid "12 OSC"
msgstr ""

#: 12-OSC.md:3
msgid "OSC"
msgstr ""

#: 12-OSC.md:5
msgid ""
"In addition to MIDI, another way to get information in and out of Sonic Pi is "
"via the network using a simple protocol called OSC - Open Sound Control. This "
"will let you send messages to and from external programs (both running on your"
" computer and on external computers) which opens up the potential for control "
"way beyond MIDI which has limitations due to its 1980s design."
msgstr ""

#: 12-OSC.md:12
msgid ""
"For example, you could write a program in another programming language which s"
"ends and receives OSC (there are OSC libraries for pretty much every common la"
"nguage) and work directly with Sonic Pi. What you can use this for is only lim"
"ited by your imagination."
msgstr ""
"例えば, OSCを送受信するプログラムを別の言語で書いてSonicPiと直接つなげて動かすことができます(多くの言語にはOSCのライブラリがあります)。 "
"これをどう使うかはみなさんの想像次第というわけです。"

#: 12.1-Receiving-OSC.md:1
msgid "12.1 Receiving OSC"
msgstr ""

#: 12.1-Receiving-OSC.md:3
msgid "Receiving OSC"
msgstr ""

#: 12.1-Receiving-OSC.md:5
msgid ""
"By default when Sonic Pi is launched it listens to port 4560 for incoming OSC "
"messages from programs on the same computer. This means that without any confi"
"guration, you can send Sonic Pi an OSC message and it will be displayed in the"
" cue log just like incoming MIDI messages. This also means that any incoming O"
"SC message is also automatically added to the Time State which means you can a"
"lso use `get` and `sync` to work with the incoming data - just like with MIDI "
"and synchronising `live_loops` - see sections 5.7 and 10.2 to recap how this w"
"orks."
msgstr ""

#: 12.1-Receiving-OSC.md:15
msgid "A Basic OSC Listener"
msgstr ""

#: 12.1-Receiving-OSC.md:17
msgid "Let's build a basic OSC listener:"
msgstr ""

#: 12.1-Receiving-OSC.md:19
#, no-wrap
#, fuzzy
msgid ""
"live_loop :foo do\n"
"  use_real_time\n"
"  a, b, c = sync \"/osc*/trigger/prophet\"\n"
"  synth :prophet, note: a, cutoff: b, sustain: c\n"
"end"
msgstr "foo"

#: 12.1-Receiving-OSC.md:27
msgid ""
"In this example we described an OSC path `\"/osc*/trigger/prophet\"` which we're"
" syncing on. This can be any valid OSC path (all letters and numbers are suppo"
"rted and the `/` is used like in a URL to break up the path to multiple words)"
". The `/osc` prefix is added by Sonic Pi to all incoming OSC messages, so we n"
"eed to send an OSC message with the path `/trigger/prophet` for our `sync` to "
"stop blocking and the prophet synth to be triggered."
msgstr ""

#: 12.1-Receiving-OSC.md:36
msgid "Sending OSC to Sonic Pi"
msgstr ""

#: 12.1-Receiving-OSC.md:38
msgid ""
"We can send OSC to Sonic Pi from any programming language that has an OSC libr"
"ary. For example, if we're sending OSC from Python we might do something like "
"this:"
msgstr ""

#: 12.1-Receiving-OSC.md:42
#, no-wrap
msgid ""
"from pythonosc import osc_message_builder\n"
"from pythonosc import udp_client\n"
"sender = udp_client.SimpleUDPClient('127.0.0.1', 4560)\n"
"sender.send_message('/trigger/prophet', [70, 100, 8])"
msgstr ""

#: 12.1-Receiving-OSC.md:50
msgid ""
"Or, if we're sending OSC from Clojure we might do something like this from the"
" REPL:"
msgstr ""

#: 12.1-Receiving-OSC.md:52
#, no-wrap
msgid ""
"(use 'overtone.core)\n"
"(def c (osc-client \"127.0.0.1\" 4560))\n"
"(osc-send c \"/trigger/prophet\" 70 100 8)"
msgstr ""

#: 12.1-Receiving-OSC.md:58
msgid "Receiving from External Machines"
msgstr "外部マシンから受信する"

#: 12.1-Receiving-OSC.md:60
msgid ""
"For security reasons, by default Sonic Pi does not let remote machines send it"
" OSC messages. However, you can enable support for remote machines in Preferen"
"ces->IO->Network->Receive Remote OSC Messages. Once you've enabled this, you c"
"an receive OSC messages from any computer on your network. Typically the sendi"
"ng machine will need to know your IP address (a unique identifier for your com"
"puter on your network - kind of like a phone number or an email address). You "
"can discover the IP address of your computer by looking at the IO section of t"
"he preferences pane. (If your machine happens to have more than one IP address"
", hovering the mouse over the listed address will pop up with a list of all kn"
"own addresses)."
msgstr ""

#: 12.1-Receiving-OSC.md:72
msgid ""
"Note, some programs such as TouchOSC for iPhone and Android support sending OS"
"C as a standard feature. So, once you're listening to remote machines and know"
" your IP address you can instantly start sending messages from apps like Touch"
"OSC which enable you to build your own custom touch controls with sliders, but"
"tons, dials etc. This can provide you with an enormous range of input options."
msgstr ""

#: 12.2-Sending-OSC.md:1
msgid "12.2 Sending OSC"
msgstr ""

#: 12.2-Sending-OSC.md:3
msgid "Sending OSC"
msgstr ""

#: 12.2-Sending-OSC.md:5
msgid ""
"In addition to receiving OSC and working with it using Time State, we can also"
" send out OSC messages in time with our music (just like we can send out MIDI "
"messages in time with our music). We just need to know which IP address and po"
"rt we're sending to. Let's give it a try:"
msgstr ""

#: 12.2-Sending-OSC.md:10
#, no-wrap
msgid ""
"use_osc \"localhost\", 4560\n"
"osc \"/hello/world\""
msgstr ""

#: 12.2-Sending-OSC.md:15
msgid ""
"If you run the code above, you'll notice that Sonic Pi is sending itself an OS"
"C message! This is because we set the IP address to the current machine and th"
"e port to the default OSC in port. This is essentially the same as posting a l"
"etter to yourself - the OSC packet is created, leaves Sonic Pi, gets to the ne"
"twork stack of the operating system which then routes the packed back to Sonic"
" Pi and then it's received as a standard OSC message and is visible in the cue"
" logger as the incoming message `/osc:127.0.0.1:4560/hello/world`. (Notice how"
" Sonic Pi automatically prefixes all incoming OSC messages with `/osc` and the"
"n the hostname and port of the sender.)"
msgstr ""

#: 12.2-Sending-OSC.md:25
msgid "Sending OSC to other programs"
msgstr ""

#: 12.2-Sending-OSC.md:27
msgid ""
"Of course, sending OSC messages to ourselves may be fun but it's not that usef"
"ul. The real benefit starts when we send messages to other programs:"
msgstr ""

#: 12.2-Sending-OSC.md:32
#, no-wrap
msgid ""
"use_osc \"localhost\", 123456\n"
"osc \"/hello/world\""
msgstr ""

#: 12.2-Sending-OSC.md:37
msgid ""
"In this case we're assuming there's another program on the same machine listen"
"ing to port 123456. If there is, then it will receive a `\"/hello/world` OSC me"
"ssage with which it can do what it wants."
msgstr ""

#: 12.2-Sending-OSC.md:41
msgid ""
"If our program is running on another machine, we need to know its IP address w"
"hich we use instead of `\"localhost\"`:"
msgstr ""

#: 12.2-Sending-OSC.md:44
#, no-wrap
msgid ""
"use_osc \"192.168.10.23\", 123456\n"
"osc \"/hello/world\""
msgstr ""

#: 12.2-Sending-OSC.md:49
msgid ""
"Now we can send OSC messages to any device reachable to us via our local netwo"
"rks and even the internet!"
msgstr ""

#: 13-Multichannel-Audio.md:1
msgid "13 Multichannel Audio"
msgstr ""

#: 13-Multichannel-Audio.md:3
msgid "Multichannel Audio"
msgstr ""

#: 13-Multichannel-Audio.md:5
msgid ""
"So far, in terms of sound production, we've explored triggering synths and rec"
"orded sounds via the fns `play`, `synth` and `sample`. These have then generat"
"ed audio which has played through our stereo speaker system. However, many com"
"puters also have the ability to input sound, perhaps through a microphone, in "
"addition to the ability to send sound out to more than two speakers. Often, th"
"is capability is made possible through the use of an external sound card - the"
"se are available for all platforms. In this section of the tutorial we'll take"
" a look at how we can take advantage of these external sound cards and effortl"
"essly work with multiple channels of audio in and out of Sonic Pi."
msgstr ""

#: 13.1-Sound-In.md:1
msgid "13.1 Sound In"
msgstr ""

#: 13.1-Sound-In.md:3
msgid "Sound In"
msgstr ""

#: 13.1-Sound-In.md:5
msgid ""
"One simple (and perhaps familiar) way of accessing sound inputs is using our f"
"riend `synth` by specifying the `:sound_in` synth:"
msgstr ""

#: 13.1-Sound-In.md:7
#, no-wrap
msgid "synth :sound_in"
msgstr ""

#: 13.1-Sound-In.md:11
msgid ""
"This will operate just like any synth such as `synth :dsaw` with the exception"
" that the audio generated will be read directly from the first input of your s"
"ystem's sound card. On laptops, this is typically the built-in microphone, but"
" if you have an external sound card, you can plug any audio input to the first"
" input."
msgstr ""

#: 13.1-Sound-In.md:17
#, fuzzy
msgid "Increasing the Duration"
msgstr "デュレーション"

#: 13.1-Sound-In.md:19
msgid ""
"One thing you might notice is that just like `synth :dsaw` the `:sound_in` syn"
"th only lasts for 1 beat as it has a standard envelope. If you'd like to keep "
"it open for a little longer, change the ADSR envelope settings. For example th"
"e following will keep the synth open for 8 beats before closing the connection"
":"
msgstr ""

#: 13.1-Sound-In.md:22
#, no-wrap
msgid "synth :sound_in, sustain: 8"
msgstr ""

#: 13.1-Sound-In.md:28
msgid ""
"Of course, just like any normal synth, you can easily layer on effects with th"
"e FX block:"
msgstr ""

#: 13.1-Sound-In.md:30
#, no-wrap
msgid ""
"with_fx :reverb do\n"
"  with_fx :distortion do\n"
"    synth :sound_in, sustain: 8\n"
"  end\n"
"end"
msgstr ""

#: 13.1-Sound-In.md:38
msgid ""
"If you have plugged in a guitar to your first input, you should be able to hea"
"r it with distortion and reverb until the synth terminates as expected."
msgstr ""

#: 13.1-Sound-In.md:40
msgid ""
"You are free to use the `:sound_in` synth as many times as you like concurrent"
"ly (just like you would do with any normal synth). For example, the following "
"will play two `:sound_in` synths at the same time - one through distortion and"
" one through reverb:"
msgstr ""

#: 13.1-Sound-In.md:42
#, no-wrap
msgid ""
"with_fx :distortion do\n"
"  synth :sound_in, sustain: 8\n"
"end\n"
"with_fx :reverb do  \n"
"  synth :sound_in, sustain: 8\n"
"end"
msgstr ""

#: 13.1-Sound-In.md:52
#, fuzzy
msgid "Multiple Inputs"
msgstr "多重チェイン"

#: 13.1-Sound-In.md:54
msgid ""
"You can select which audio input you want to play with the `input:` opt. You c"
"an also specify a stereo input (two consecutive inputs) using the `:sound_in_s"
"tereo` synth. For example, if you have a sound card with at least three inputs"
", you can treat the first two as a stereo stream and add distortion and the th"
"ird as a mono stream and add reverb with the following code:"
msgstr ""

#: 13.1-Sound-In.md:61
#, no-wrap
msgid ""
"with_fx :distortion do\n"
"  synth :sound_in_stereo, sustain: 8, input: 1\n"
"end\n"
"with_fx :reverb do  \n"
"  synth :sound_in, sustain: 8, input: 3\n"
"end"
msgstr ""

#: 13.1-Sound-In.md:72
msgid "Potential Issues"
msgstr ""

#: 13.1-Sound-In.md:74
msgid ""
"However, although this is a useful technique, there are a couple of limitation"
"s to this approach. Firstly, it only works for a specific duration (due to it "
"having an ADSR envelope) and secondly, there's no way to switch the FX around "
"once the synth has been triggered. Both of these things are typical requests w"
"hen working with external audio feeds such as microphones, guitars and externa"
"l synthesisers. We'll therefore take a look at Sonic Pi's solution to the prob"
"lem of manipulating a (potentially) infinite stream of live audio input: `live"
"_audio`."
msgstr ""

#: 13.2-Live-Audio.md:1
msgid "13.2 Live Audio"
msgstr ""

#: 13.2-Live-Audio.md:3
#, fuzzy
msgid "Live Audio"
msgstr "ライブコーディング"

#: 13.2-Live-Audio.md:5
msgid ""
"The `:sound_in` synth as described in the previous section provides a very fle"
"xible and familiar method for working with input audio. However, as also discu"
"ssed it has a few issues when working with a single input of audio as a single"
" instrument (such as a voice or guitar). By far the best approach to working w"
"ith a single continuous stream of audio is to use `live_audio`."
msgstr ""

#: 13.2-Live-Audio.md:12
msgid "A Named Audio Input"
msgstr ""

#: 13.2-Live-Audio.md:14
msgid ""
"`live_audio` shares a couple of core design constraints with `live_loop` (henc"
"e the similar name). Firstly it must have a unique name and secondly only one "
"`live_audio` stream with that name may exist at any one time. Let's take a loo"
"k:"
msgstr ""

#: 13.2-Live-Audio.md:19 13.2-Live-Audio.md:92
#, no-wrap
#, fuzzy
msgid "live_audio :foo"
msgstr "foo"

#: 13.2-Live-Audio.md:23
msgid ""
"This code will act in a similar fashion to `synth :sound_in` with some key dif"
"ferences: it runs forever (until you explicitly stop it) and you can *move* it"
" to new FX contexts dynamically."
msgstr ""

#: 13.2-Live-Audio.md:28
msgid "Working with FX"
msgstr ""

#: 13.2-Live-Audio.md:30
msgid ""
"On initial triggering `live_audio` works exactly as you might expect it to wor"
"k with FX. For example, to start a live audio stream with added reverb simply "
"use a `:reverb` FX block:"
msgstr ""

#: 13.2-Live-Audio.md:34
#, no-wrap
#, fuzzy
msgid ""
"with_fx :reverb do\n"
"  live_audio :foo\n"
"end"
msgstr "foo"

#: 13.2-Live-Audio.md:40
msgid ""
"However, given that `live_audio` runs forever (at least until you stop it) it "
"would be pretty limiting if, like typical synths, the live audio was bound wit"
"hin the `:reverb` FX for its entire existence. Luckily this is not the case an"
"d it was designed to be easy to move between different FX. Let's try it. Run t"
"he code above to hear live audio coming directly from the first input of your "
"sound card. Note, if you're using a laptop, this will typically be out of your"
" built-in microphone, so it's recommended to use headphones to stop feedback."
msgstr ""

#: 13.2-Live-Audio.md:49
#, fuzzy
msgid ""
"Now, whilst you're still hearing the audio live from the sound card with rever"
"b, change the code to the following:"
msgstr "reverb,"

#: 13.2-Live-Audio.md:52
#, no-wrap
#, fuzzy
msgid ""
"with_fx :echo do\n"
"  live_audio :foo\n"
"end"
msgstr "foo"

#: 13.2-Live-Audio.md:58
msgid ""
"Now, hit Run, and you'll immediately hear the audio played through the echo FX"
" and no longer through reverb. If you wanted them both, just edit the code aga"
"in and hit Run:"
msgstr ""

#: 13.2-Live-Audio.md:62
#, no-wrap
#, fuzzy
msgid ""
"with_fx :reverb do\n"
"  with_fx :echo do\n"
"    live_audio :foo\n"
"  end\n"
"end"
msgstr "foo"

#: 13.2-Live-Audio.md:70
#, fuzzy
msgid ""
"It's important to point out that you can call `live_audio :foo` from any threa"
"d or live loop and it will move the live audio synth to *that* thread's curren"
"t FX context. You could therefore easily have multiple live loops calling `liv"
"e_audio :foo` at different times resulting in the FX context being automatical"
"ly swapped around for some interesting results."
msgstr "foo"

#: 13.2-Live-Audio.md:78
msgid "Stopping live audio"
msgstr ""

#: 13.2-Live-Audio.md:80
msgid ""
"Unlike standard synths, as `live_audio` has no envelope, it will continue runn"
"ing forever (even if you delete the code, just like a function is still define"
"d in memory if you delete the code in the editor). To stop it, you need to use"
" the `:stop` arg:"
msgstr ""

#: 13.2-Live-Audio.md:85
#, no-wrap
#, fuzzy
msgid "live_audio :foo, :stop"
msgstr "foo"

#: 13.2-Live-Audio.md:89
msgid "It can easily be restarted by calling it without the `:stop` arg again:"
msgstr ""

#: 13.2-Live-Audio.md:96
msgid ""
"Additionally all running live audio synths are stopped when you hit the global"
" Stop button (as with all other running synths and FX)."
msgstr ""

#: 13.2-Live-Audio.md:99
msgid "Stereo input"
msgstr ""

#: 13.2-Live-Audio.md:101
msgid ""
"With respect to audio channels, by default `live_audio` acts similarly to the "
"`:sound_in` synth in that it takes a single mono input stream of audio and con"
"verts it to a stereo stream using the specified panning. However, just like `:"
"sound_in_stereo` it's also possible to tell `live_audio` to read two consecuti"
"ve audio inputs and treat them as the left and right channels directly. This i"
"s achieved via the `:stereo` opt. For example, to treat input 2 as the left si"
"gnal and input 3 as the right signal, you need to configure the `input:` opt t"
"o 2 and enable stereo mode as follows:"
msgstr ""

#: 13.2-Live-Audio.md:111
#, no-wrap
#, fuzzy
msgid "live_audio :foo, stereo: true, input: 2"
msgstr "foo"

#: 13.2-Live-Audio.md:115
msgid ""
"Note that once you have started a live audio stream in stereo mode, you cannot"
" change it to mono without stopping and starting. Similarly, if you start it i"
"n the default mono mode, you can't switch to stereo without starting and stopp"
"ing the stream."
msgstr ""

#: 13.3-Sound-Out.md:1
msgid "13.3 Sound Out"
msgstr ""

#: 13.3-Sound-Out.md:3
msgid "Sound Out"
msgstr ""

#: 13.3-Sound-Out.md:5
msgid ""
"So far in this section we've looked at how to get multiple streams of audio in"
"to Sonic Pi - either through the use of the `:sound_in` synth or via the power"
"ful `live_audio` system. In addition to working with multiple streams of input"
" audio, Sonic Pi can also output multiple streams of audio. This is achieved v"
"ia the `:sound_out` FX."
msgstr ""

#: 13.3-Sound-Out.md:11
msgid "Output contexts"
msgstr ""

#: 13.3-Sound-Out.md:13
msgid ""
"Let's quickly recap on how Sonic Pi's synths and FX output their audio to thei"
"r current FX context. For example, consider the following:"
msgstr ""

#: 13.3-Sound-Out.md:16
#, no-wrap
msgid ""
"with_fx :reverb do    # C\n"
"  with_fx :echo do    # B\n"
"    sample :bd_haus   # A\n"
"  end\n"
"end"
msgstr ""

#: 13.3-Sound-Out.md:24
msgid ""
"The simplest way to understand what's happening with the audio stream is to st"
"art at the innermost audio context and work our way out. In this case, the inn"
"ermost context is labelled `A` and is the `:bd_haus` sample being triggered. T"
"he audio for this goes directly into its context which is `B` - the `:echo` FX"
". This then adds echo to the incoming audio and outputs it to its context whic"
"h is `C` - the `:reverb` FX. This then adds reverb to the incoming audio and o"
"utputs to its context which is the top level - the left and right speakers (ou"
"tputs 1 and 2 in your audio card). The audio flows outwards with a stereo sign"
"al all the way through."
msgstr ""

#: 13.3-Sound-Out.md:35
msgid "Sound Out FX"
msgstr ""

#: 13.3-Sound-Out.md:37
msgid ""
"The above behaviour is true for all synths (including `live_audio`) and the ma"
"jority of FX with the exception of `:sound_out`. The `:sound_out` FX does two "
"things. Firstly it outputs its audio to its external context as described abov"
"e. Secondly it *also* outputs its audio directly to an output on your sound ca"
"rd. Let's take a look:"
msgstr ""

#: 13.3-Sound-Out.md:43
#, no-wrap
msgid ""
"with_fx :reverb do      # C\n"
"  with_fx :sound_out, output: 3 do # B\n"
"    sample :bd_haus     # A\n"
"  end\n"
"end"
msgstr ""

#: 13.3-Sound-Out.md:51
msgid ""
"In this example, our `:bd_haus` sample outputs its audio to its external conte"
"xt which is the `:sound_out` FX. This in turn outputs its audio to its externa"
"l context the `:reverb` FX (as expected). However, it *also* outputs a mono mi"
"x to the 3rd output of the system's soundcard. The audio generated within `:so"
"und_out` therefore has two destinations - the `:reverb` FX and audio card outp"
"ut 3."
msgstr ""

#: 13.3-Sound-Out.md:58
msgid "Mono and Stereo out"
msgstr ""

#: 13.3-Sound-Out.md:60
#, fuzzy
msgid ""
"As we've seen, by default, the `:sound_out` FX outputs a mono mix of the stere"
"o input to a specific channel in addition to passing the stereo feed to the ou"
"ter context (as expected). If outputting a mono mix isn't precisely what you w"
"ant to do, there are a number of alternative options. Firstly, by using the `m"
"ode:` opt you can choose to output just the left or just the right input signa"
"l to the audio card. Or you can use the `:sound_out_stereo` FX to output to tw"
"o consecutive sound card outputs. See the function documentation for more info"
"rmation and examples."
msgstr "choose：選択"

#: 13.3-Sound-Out.md:70
msgid "Direct Out"
msgstr ""

#: 13.3-Sound-Out.md:72
msgid ""
"As we have also seen, the default behaviour for `:sound_out` and `:sound_out_s"
"tereo` is to send the audio both to their external context (as is typical of a"
"ll FX) *and* to the specified output on your soundcard. However, occasionally "
"you may wish to *only* send to the output on your soundcard and not to the ext"
"ernal context (and therefore not have any chance of the sound being mixed and "
"sent to the standard output channels 1 and 2). This is possible by using the s"
"tandard FX opt `amp:` which operates on the audio *after* the FX has been able"
" to manipulate the audio:"
msgstr ""

#: 13.3-Sound-Out.md:82
#, no-wrap
#, fuzzy
msgid ""
"with_fx :sound_out, output: 3, amp: 0 do # B\n"
"  sample :loop_amen                      # A\n"
"end"
msgstr "sample :loop_amen"

#: 13.3-Sound-Out.md:88
msgid ""
"In the above example, the `:loop_amen` sample is sent to its outer context, th"
"e `:sound_out` FX. This then sends a mono mix to audio card output 3 and then "
"multiplies the audio by 0 which essentially silences it. It is this silenced s"
"ignal which is then sent out to the `:sound_out`'s outer context which is the "
"standard output. Therefore with this code, the default output channels will no"
"t receive any audio, and channel 3 will receive a mono mix of the amen drum br"
"eak."
msgstr ""

#: 14-Conclusions.md:1
#, fuzzy
msgid "14 Conclusions"
msgstr "12 おわりに"

#: 14-Conclusions.md:3
msgid "Conclusions"
msgstr "おわりに"

#: 14-Conclusions.md:5
msgid ""
"This concludes the Sonic Pi introductory tutorial. Hopefully you've learned so"
"mething along the way. Don't worry if you feel you didn't understand everythin"
"g - just play and have fun and you'll pick things up in your own time. Feel fr"
"ee to dive back in when you have a question that might be covered in one of th"
"e sections."
msgstr ""
"これでSonic Pi入門のチュートリアルを終了します。皆さんがここに至るまでに何かを学べたと願っています。すべてを理解していなくても心配せずに、演奏を楽し"
"んでください。そうすれば、あなたのペースで習得できるはずです。何か疑問点があれば、チュートリアルのどこかに書いてあるかもしれないので、気軽に戻って読み直して"
"みてください。"

#: 14-Conclusions.md:11
#, fuzzy
msgid ""
"If you have any questions that haven't been covered in the tutorial, then plea"
"se jump onto the [Sonic Pi community forums](https://in-thread.sonic-pi.net/) "
"and ask your question there. You'll find someone friendly and willing to lend "
"a hand."
msgstr ""
"もし、チュートリアルでカバーしていない疑問がある場合は、[Sonic Pi forums](http://groups.google.com/group/s"
"onic-pi/)を開いて、質問してみてください。誰かが親身に手を貸してくれるでしょう。"

#: 14-Conclusions.md:16
msgid ""
"Finally, I also invite you to take a deeper look at the rest of the documentat"
"ion in this help system. There are a number of features that haven't been cove"
"red in this tutorial that are waiting for your discovery."
msgstr ""
"最後に、ヘルプシステムのドキュメントをより深くチェックすることをお勧めします。このチュートリアルでは紹介していない機能がいくつかあるので、新たな発見が待って"
"いるでしょう。"

#: 14-Conclusions.md:21
msgid ""
"So play, have fun, share your code, perform for your friends, show your screen"
"s and remember:"
msgstr "遊んで、楽しんで、コードを共有して、そしてスクリーンを見せながら、友人のために演奏してください。そして思い出してください。"

#: 14-Conclusions.md:24
msgid "*There are no mistakes, only opportunities.*"
msgstr "*間違いはない、あるのはただ可能性だけ*"

#: 14-Conclusions.md:26
#, fuzzy
msgid "[Sam Aaron](https://twitter.com/samaaron)"
msgstr "[Sam Aaron](http://twitter.com/samaaron)"

#: A-Articles.md:1
msgid "A Appendix A - MagPi Articles"
msgstr "A 付録A - MagPi掲載記事"

#: A-Articles.md:3
msgid "MagPi Articles"
msgstr "MagPi掲載記事"

#: A-Articles.md:5
msgid "Appendix A collects all the Sonic Pi articles written for the MagPi magazine."
msgstr "付録Aは、雑誌MagPiのために書かれたSonic Piの記事を集録しています。"

#: A-Articles.md:8
msgid "Dive into Topics"
msgstr "トピックに進む"

#: A-Articles.md:10
msgid ""
"These articles aren't meant to be read in any strict order and contain a lot o"
"f cross-over material from the tutorial itself. Rather than try and teach you "
"all of Sonic Pi, they instead each focus on a specific aspect of Sonic Pi and "
"cover it in a fun and accessible way."
msgstr ""
"付録に集録されている記事は、決まった順序で読むように意図されたものではなく、またチュートリアルとの重複した内容も数多く含まれています。これらの記事は、Son"
"ic Piの全てを紹介するというよりは、Sonic Piの特定の面にフォーカスし、分かりやすく、また楽しく紹介しています。"

#: A-Articles.md:15
msgid "Read the MagPi"
msgstr "MagPiを読む"

#: A-Articles.md:17
msgid ""
"You can see them in their glorious professionally typeset form in the free PDF"
" downloads of The MagPi here: https://www.raspberrypi.org/magpi/"
msgstr ""
"MagPiは、美しく活字化されたPDFファイルを以下のサイトから無料でダウンロードできます。https://www.raspberrypi.org/magp"
"i/"

#: A-Articles.md:20
msgid "Suggest a Topic"
msgstr "トピックを提案する"

#: A-Articles.md:22
msgid ""
"If you don't see a topic that interests you covered in these articles - why no"
"t suggest one? The easiest way to do that is to tweet your suggestion to [@Son"
"ic_Pi](http://twitter.com/sonic_pi). You never know - your suggestion might be"
" the subject of the next article!"
msgstr ""
"もしあなたが関心があってこれらのMagPiの記事で紹介されていないトピックがあったら、提案してみてはどうでしょう？ 最も簡単な方法は、提案を[@Sonic_"
"Pi](http://twitter.com/sonic_pi)宛にツイートすることです。あなたの提案が次のMagPiの記事のテーマになるかもしれないのです"
"！"

#: A.01-tips.md:1
msgid "A.1 Tips for Sonic Pi"
msgstr "A.1 Sonic Piのためのヒント"

#: A.01-tips.md:3
msgid "Five Top Tips"
msgstr "トップ5のヒント"

#: A.01-tips.md:5
msgid "1. There are no mistakes"
msgstr "1. 間違いはない"

#: A.01-tips.md:7
msgid ""
"The most important lesson to learn with Sonic Pi is that there really are no m"
"istakes. The best way to learn is to just try and try and try. Try lots of dif"
"ferent things out, stop worrying whether your code sounds good or not and star"
"t experimenting with as many different synths, notes, FX and opts as possible."
" You'll discover a lot of things that make you laugh because they sound just a"
"wful and some real gems that sound truly amazing. Simply drop the things you d"
"on't like and keep the things you do. The more 'mistakes' you allow yourself t"
"o make the quicker you'll learn and discover your personal coding sound."
msgstr ""
"Sonic Piで学ぶ最も重要な教訓は、*間違いはない*ということです。Sonic Piの一番の習得方法は、繰り返し試してみることです。いろんなことを試し、"
"コードから出る音が良いか悪いか気にするのをやめ、できるだけ異なるシンセ、異なる音符、異なるエフェクト、異なるオプションを実験してみましょう。とてもひどくて笑"
"ってしまうものも数多くある一方で、宝石のような本当に素晴らしい音もあるでしょう。そして、単純にあなたの好みの音は取っておき、そうでないものは捨ててしまえばよ"
"いのです。より多くの`間違い`をすればするほど、あなたにしか出来ないコーディング音楽をより早く発見し、習得できるに違いありません。"

#: A.01-tips.md:18
msgid "2. Use the FX"
msgstr "2. エフェクトを使う"

#: A.01-tips.md:20
msgid ""
"Say you've already mastered the Sonic Pi basics of making sounds with `sample`"
", `play`? What's next? Did you know that Sonic Pi supports over 27 studio FX t"
"o change the sound of your code? FX are like fancy image filters in drawing pr"
"ograms except that instead of blurring or making something black and white, yo"
"u can add things like reverb, distortion and echo to your sound. Think of it l"
"ike sticking the cable from your guitar to an effects pedal of your choice and"
" then into the amplifier. Luckily, Sonic Pi makes using FX really easy and req"
"uires no cables! All you need to do is to choose which section of your code yo"
"u'd like the FX added to and wrap it with the FX code. Let's look at an exampl"
"e. Say you had the following code:"
msgstr ""
"`sample`や`play`といったSonic Piの音作りの基本をマスターしたとして、次はどうしよう？ Sonic Piには、あなたのコードの音を変える"
"ことができる27を超えるスタジオ・エフェクトがあるのを知っていますか？ エフェクトは、ドローソフトの派手なイメージフィルタと同じようなものです。ただし、イメ"
"ージフィルタがぼかしを入れたり、白黒にしたりするのに対し、エフェクトは音にリバーブやディストーション、エコーなどを追加します。それはちょうどギターからエフェ"
"クトペダルにケーブルを差して、さらにアンプに差すようなものと考えるとよいでしょう。幸いにも、Sonic Piではエフェクトが本当に簡単になっていて、ケーブル"
"も必要としないのです！ あなたのやることは、エフェクトを追加したいコード領域を選択し、エフェクトのコードで包むだけです。たとえば、次のようなコードがあったと"
"しましょう。"

#: A.01-tips.md:32
#, no-wrap
msgid ""
"sample :loop_garzul\n"
"16.times do\n"
"  sample :bd_haus\n"
"  sleep 0.5\n"
"end"
msgstr ""
"sample :loop_garzul\n"
"16.times do\n"
"  sample :bd_haus\n"
"  sleep 0.5\n"
"end"

#: A.01-tips.md:41
msgid ""
"If you wanted to add FX to the `:loop_garzul` sample, you'd just tuck it insid"
"e a `with_fx` block like this:"
msgstr "`:loop_garzul`のサンプルにエフェクトを追加したい場合には、次のように`with_fx`に押し込むだけでよいのです。"

#: A.01-tips.md:44
#, no-wrap
msgid ""
"with_fx :flanger do\n"
"  sample :loop_garzul\n"
"end\n"
"16.times do\n"
"  sample :bd_haus\n"
"  sleep 0.5\n"
"end"
msgstr ""
"with_fx :flanger do\n"
"  sample :loop_garzul\n"
"end\n"
"16.times do\n"
"  sample :bd_haus\n"
"  sleep 0.5\n"
"end"

#: A.01-tips.md:55
msgid ""
"Now, if you wanted to add FX to the bass drum, go and wrap that with `with_fx`"
" too:"
msgstr "では次にバスドラムにエフェクトを追加したい場合には、同じように`with_fx`で包んでみましょう。"

#: A.01-tips.md:58
#, no-wrap
msgid ""
"with_fx :flanger do\n"
"  sample :loop_garzul\n"
"end\n"
"with_fx :echo do\n"
"  16.times do\n"
"    sample :bd_haus\n"
"    sleep 0.5\n"
"  end\n"
"end"
msgstr ""
"with_fx :flanger do\n"
"  sample :loop_garzul\n"
"end\n"
"with_fx :echo do\n"
"  16.times do\n"
"    sample :bd_haus\n"
"    sleep 0.5\n"
"  end\n"
"end"

#: A.01-tips.md:71
msgid ""
"Remember, you can wrap *any* code within `with_fx` and any sounds created will"
" pass through that FX."
msgstr "*どんな*コードでも`with_fx`で包めば、どんな音もそのままエフェクトに送られることを覚えておくとよいでしょう。"

#: A.01-tips.md:75
msgid "3. Parameterise your synths"
msgstr "3. オプションを使う"

#: A.01-tips.md:77
msgid ""
"In order to really discover your coding sound you'll soon want to know how to "
"modify and control synths and FX. For example, you might want to change the du"
"ration of a note, add more reverb, or change the time between echoes. Luckily,"
" Sonic Pi gives you an amazing level of control to do exactly this with specia"
"l things called optional parameters or opts for short. Let's take a quick look"
". Copy this code into a workspace and hit run:"
msgstr ""
"もしあなた自身のコーディング音楽を本当に発見したい場合に、あなたはすぐにシンセやエフェクトを変更したり制御する方法を知りたくなるに違いありません。たとえば、"
"音符の長さを変更したり、リバーブをもっと追加したり、エコーの間隔を変更したりしたいかもしれません。幸いにも、Sonic Piでは驚くべきレベルの制御の方法が"
"提供されていて、オプション・パラメータ、略してオプションと呼ばれる特別な仕組みによって、まさしくこれと同じことが可能です。ちょっと見てみましょう。以下のコー"
"ドをBufferにコピーして実行してみましょう。"

#: A.01-tips.md:85
#, no-wrap
msgid "sample :guit_em9"
msgstr "sample :guit_em9"

#: A.01-tips.md:89
msgid ""
"Ooh, a lovely guitar sound! Now, let's start playing with it. How about changi"
"ng its rate?"
msgstr "おお、すてきなギターサウンドですね！ では、これで遊んでみましょう。レートを変えてみるのはどうでしょう？"

#: A.01-tips.md:92 A.17-sample-stretching.md:25
#, no-wrap
msgid "sample :guit_em9, rate: 0.5"
msgstr "sample :guit_em9, rate: 0.5"

#: A.01-tips.md:96
msgid ""
"Hey, what's that `rate: 0.5` bit I just added at the end? That's called an opt"
". All of Sonic Pi's synths and FX support them and there's loads to play aroun"
"d with. They're also available for FX too. Try this:"
msgstr ""
"行の最後にちょっと付けた`rate: 0.5`は何だろう？ これはオプションと呼ばれています。Sonic Piの全てのシンセとエフェクトはオプションをサポー"
"トしていて、たくさんのオプションで遊べます。エフェクトでもオプションは利用可能です。次を試してみましょう。"

#: A.01-tips.md:100
#, no-wrap
msgid ""
"with_fx :flanger, feedback: 0.6 do\n"
"  sample :guit_em9\n"
"end"
msgstr ""
"with_fx :flanger, feedback: 0.6 do\n"
"  sample :guit_em9\n"
"end"

#: A.01-tips.md:106
msgid ""
"Now, try increasing that feedback to 1 to hear some crazy sounds! Read the doc"
"s for full details on all the many opts available to you."
msgstr "では、`feedback`を1に変更して、クレイジーな音を聞いてみましょう！ 利用可能な多くのオプションの詳細について、ドキュメントを読んでみましょう。"

#: A.01-tips.md:110
#, fuzzy
msgid "4. Live Code"
msgstr "4. ライブコーディング"

#: A.01-tips.md:112
msgid ""
"The best way to quickly experiment and explore Sonic Pi is to live code. This "
"allows you to start off some code and continually change and tweak it whilst i"
"t's still playing. For example, if you don't know what the cutoff parameter do"
"es to a sample, just play around. Let's have a try! Copy this code into one of"
" your Sonic Pi workspaces:"
msgstr ""
"Sonic Piについて素早く調べてみたり実験したりする一番の方法は、ライブコーディングすることです。ライブコーディングにより、あるコードから演奏を開始して"
"、演奏を止めずに継続してコードをいじったり、変更したりできます。たとえば、`sample`でcutoffのオプションがどのように動作するか分からない場合には"
"、ただ実行してみればよいのです。では試し見てみましょう！ 以下のコードをSonic PiのBufferにコピーしてみましょう。"

#: A.01-tips.md:118
#, no-wrap
msgid ""
"live_loop :experiment do\n"
"  sample :loop_amen, cutoff: 70\n"
"  sleep 1.75\n"
"end"
msgstr ""
"live_loop :experiment do\n"
"  sample :loop_amen, cutoff: 70\n"
"  sleep 1.75\n"
"end"

#: A.01-tips.md:125
msgid ""
"Now, hit run and you'll hear a slightly muffled drum break. Now, change the `c"
"utoff:` value to `80` and hit run again. Can you hear the difference? Try `90`"
", `100`, `110`..."
msgstr ""
"実行すると、こもった音のドラムブレイクを聞くことができるでしょう。では、`cutoff:`の値を`80`に変更して再度実行してみましょう。違いが分かりますか"
"？ `90`, `100`, `110`も試してみましょう。"

#: A.01-tips.md:129
msgid ""
"Once you get the hang of using `live_loop`s you'll not turn back. Whenever I d"
"o a live coding gig I rely on `live_loop` as much as a drummer relies on their"
" sticks. For more information about live coding check out Section 9 of the bui"
"lt-in tutorial."
msgstr ""
"`live_loop`を一度使い始めると、`live_loop`を使わないコードに戻れなくなるでしょう。ドラマーがスティックを頼りにするのと同じように、私も"
"ライブコーディングするときはいつも`live_loop`を頼りにしています。ライブコーディングについての詳細は、チュートリアルの9章をチェックしてみてくださ"
"い。"

#: A.01-tips.md:134
msgid "5. Surf the random streams"
msgstr "5. ランダムストリームに乗る"

#: A.01-tips.md:136
msgid ""
"Finally, one thing I love doing is cheating by getting Sonic Pi to compose thi"
"ngs for me. A really great way to do this is using randomisation. It might sou"
"nd complicated but it really isn't. Let's take a look. Copy this into a spare "
"workspace:"
msgstr ""
"最後に、私が好きでよくやるのは、Sonic Piに作曲してもらうズルい方法です。これを実現する本当に卓越した方法は、ランダム化を使用することです。ランダム化"
"と言うと複雑そうに聞こえるかもしれませんが、実際にはそうでもありません。少し見てみましょう。以下のコードをBufferにコピーしてください。"

#: A.01-tips.md:141
#, no-wrap
msgid ""
"live_loop :rand_surfer do\n"
"  use_synth :dsaw\n"
"  notes = (scale :e2, :minor_pentatonic, num_octaves: 2)\n"
"  16.times do\n"
"    play notes.choose, release: 0.1, cutoff: rrand(70, 120)\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"live_loop :rand_surfer do\n"
"  use_synth :dsaw\n"
"  notes = (scale :e2, :minor_pentatonic, num_octaves: 2)\n"
"  16.times do\n"
"    play notes.choose, release: 0.1, cutoff: rrand(70, 120)\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: A.01-tips.md:152
msgid ""
"Now, when you play this, you'll hear a constant stream of random notes from th"
"e scale `:e2 :minor_pentatonic` played with the `:dsaw` synth. \"Wait, wait! Th"
"at's not a melody\", I hear you shout! Well, here's the first part of the magic"
" trick. Every time we go round the `live_loop` we can tell Sonic Pi to reset t"
"he random stream to a known point. This is a bit like going back in time in th"
"e TARDIS with the Doctor to a particular point in time and space. Let's try it"
" - add the line `use_random_seed 1` to the `live_loop`:"
msgstr ""
"ここで、上記のコードを実行すると、`:e2 :minor_pentatonic`のスケールから選ばれ"
"た音符の絶え間ないランダムな流れが、`:dsaw`のシンセで再生されるのを聞くことが"
"できるでしょう。「待って！ これはメロディーじゃない」とあなたが叫んでいるのが"
"想像できます。落ち着いてください。これはマジックのトリックの前半部分です。"
"Sonic Piでは、`live_loop`を繰り返す度に、特定の位置にランダムストリームをリセ"
"ットするように指示することができます。それは、「Dr. Who」に登場するタイムマシ"
"ンのTARDISが、特定の時間と場所に辿り着くのとちょっと似ています。ではやってみ"
"ましょう。`live_loop`に`use_random_seed 1`の行を追加してみてください。"

#: A.01-tips.md:161
#, no-wrap
msgid ""
"live_loop :rand_surfer do\n"
"  use_random_seed 1\n"
"  use_synth :dsaw\n"
"  notes = (scale :e2, :minor_pentatonic, num_octaves: 2)\n"
"  16.times do\n"
"    play notes.choose, release: 0.1, cutoff: rrand(70, 120)\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"live_loop :rand_surfer do\n"
"  use_random_seed 1\n"
"  use_synth :dsaw\n"
"  notes = (scale :e2, :minor_pentatonic, num_octaves: 2)\n"
"  16.times do\n"
"    play notes.choose, release: 0.1, cutoff: rrand(70, 120)\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: A.01-tips.md:173
msgid ""
"Now, every time the `live_loop` loops around, the random stream is reset. This"
" means it chooses the same 16 notes every time. Hey presto! An instant melody."
" Now, here's the really exciting bit. Change the seed value from `1` to anothe"
"r number. Say `4923`. Wow! Another melody! So, just by changing one number (th"
"e random seed), you can explore as many melodic combinations as you can imagin"
"e! Now, that's the magic of code."
msgstr ""
"これで、`live_loop`がループする度に、ランダムストリームがリセットされるようになりました。これは、ループの度に同じ16の音符が選択されていることを"
"意味しています。あら不思議！ 手軽なメロディーでしょう。ここからが本当に面白くなるところです。シードの値を`1`から別な数値、たとえば`4923`に変更して"
"みましょう。ワオ！ 別なメロディーになったでしょう！ 1つの数字（ランダムシード）を変更するだけで、あなたの想像する限り多くのメロディーの組合せを試すことが"
"できるのです！ これがコードのマジックなのです。"

#: A.02-live-coding.md:1
msgid "A.2 Live Coding"
msgstr "A.2 ライブコーディング"

#: A.02-live-coding.md:5
msgid ""
"The laser beams sliced through the wafts of smoke as the subwoofer pumped bass"
" deep into the bodies of the crowd. The atmosphere was ripe with a heady mix o"
"f synths and dancing. However something wasn't quite right in this nightclub. "
"Projected in bright colours above the DJ booth was futuristic text, moving, da"
"ncing, flashing. This wasn't fancy visuals, it was merely a projection of Soni"
"c Pi running on a Raspberry Pi. The occupant of the DJ booth wasn't spinning d"
"isks, he was writing, editing and evaluating code. Live. This is Live Coding."
msgstr ""
"漂うスモークをレーザー光線がスライスし、サブウーファーは観衆の体の奥深くまで低音を震わせている。その雰囲気は、眩暈のするようなシンセのミックスとダンスで満た"
"されている。しかし、このクラブでは何かがおかしい。DJブースの上に映し出された明るい色は、小刻みに動き、舞い、きらめく未来的なテキストである。それは、手の込"
"んだビジュアルではなく、Raspberry Pi上で動いているSonic Piを単に映し出したものである。DJブースでは、レコードを回しているのではなく、コ"
"ードを書き、編集し、実行しているのである。ライブである。これがライブコーディングである。"

#: A.02-live-coding.md:14
#, fuzzy
msgid ""
"![Sam Aaron Live Coding](../../../etc/doc/images/tutorial/articles/A.02-live-c"
"oding/sam-aaron-live-coding.png)"
msgstr ""
"![Sam Aaron Live Coding](../../../etc/doc/images/tutorial/articles/A.02-live-c"
"oding/sam-aaron-live-coding.png)"

#: A.02-live-coding.md:16
msgid ""
"This may sound like a far fetched story from a futuristic night club but codin"
"g music like this is a growing trend and is often described as Live Coding (ht"
"tp://toplap.org). One of the recent directions this approach to music making h"
"as taken is the Algorave (http://algorave.com) - events where artists like mys"
"elf code music for people to dance to. However, you don't need to be in a nigh"
"tclub to Live Code - with Sonic Pi v2.6+ you can do it anywhere you can take y"
"our Raspberry Pi and a pair of headphones or some speakers. Once you reach the"
" end of this article, you'll be programming your own beats and modifying them "
"live. Where you go afterwards will only be constrained by your imagination."
msgstr ""
"これは未来のクラブの現実的でない話のように聞こえるかもしれませんが、音楽をコーディングすることは盛り上がりつつあるトレンドであり、しばしばライブコーディング"
"（http://toplap.org）と呼ばれています。この音楽制作アプローチの最近の流れの1つは、Algorave（http://algorave.com"
"）です。私のようなアーティストが、人々をダンスさせるために音楽をコーディングするイベントです。しかし、ライブコーディングするのにクラブに居る必要はありません"
"。Sonic Pi v2.6以上では、ヘッドホンやスピーカーとRaspberry Piを持っていける場所であればどこでも、ライブコーディングができます。一度"
"この記事を最後まで読めば、あなた自身のビートをプログラミングでき、それをライブで変更できるでしょう。その後どこに進むかは、あなたのイマジネーションにだけ制約"
"されるでしょう。"

#: A.02-live-coding.md:27
msgid "Live Loop"
msgstr "ライブループ"

#: A.02-live-coding.md:29
msgid ""
"The key to live coding with Sonic Pi is mastering the `live_loop`. Let's look "
"at one:"
msgstr "Sonic Piでライブコーディングする鍵は、`live_loop`をマスターすることです。次のコードを見てみましょう。"

#: A.02-live-coding.md:32
#, no-wrap
msgid ""
"live_loop :beats do\n"
"  sample :bd_haus\n"
"  sleep 0.5\n"
"end"
msgstr ""
"live_loop :beats do\n"
"  sample :bd_haus\n"
"  sleep 0.5\n"
"end"

#: A.02-live-coding.md:39
#, fuzzy
msgid ""
"There are 4 core ingredients to a `live_loop`. The first is its name. Our `liv"
"e_loop` above is called `:beats`. You're free to call your `live_loop` anythin"
"g you want. Go crazy. Be creative. I often use names that communicate somethin"
"g about the music they're making to the audience. The second ingredient is the"
" `do` word which marks where the `live_loop` starts. The third is the `end` wo"
"rd which marks where the `live_loop` finishes, and finally there is the body o"
"f the `live_loop` which describes what the loop is going to repeat - that's th"
"e bit between the `do` and `end`. In this case we're repeatedly playing a bass"
" drum sample and waiting for half a beat. This produces a nice regular bass be"
"at. Go ahead, copy it into an empty Sonic Pi buffer and hit run. Boom, Boom, B"
"oom!."
msgstr ""
"`live_loop`には、4つのコアな構成要素があります。1つめは、その名前です。上の`live_loop`の名前は`:beats`です。`live_lo"
"op`はどんな名前でも自由に付けることができます。創造的に、またクレイジーになりましょう。私は、作っている音楽に関して何か観衆と意思疎通するような名前をしば"
"しば付けます。2つめの構成要素は`do`という単語で、`live_loop`の開始する位置を示しています。3つめは`end`で`live_loop`を終了す"
"る位置を示しています。そして最後は、`live_loop`のボディ部分です。これは`do`と`end`に囲まれたコードで、ループで何を繰り返すかが記述されて"
"いる箇所です。上のコードでは、定期的にバスドラムのサンプルを再生と半拍分の待機を繰り返しています。これにより、心地良い規則的なビートが作られています。さあ、"
"Sonic PiのBufferに上のコードをコピーして実行してみましょう。Boom, Boom, Boom!"

#: A.02-live-coding.md:52
msgid "Redefining On-the-fly"
msgstr "その場で再定義する"

#: A.02-live-coding.md:54
msgid ""
"Ok, so what's so special about the `live_loop`? So far it just seems like a gl"
"orified `loop`! Well, the beauty of `live_loop`s is that you can redefine them"
" on-the-fly. This means that whilst they're still running, you can change what"
" they do. This is the secret to live coding with Sonic Pi. Let's have a play:"
msgstr ""
"では、`live_loop`の何が特別なのでしょう？ 見たところ`loop`にそっくりですね！ ええと、`live_loop`の利点は、その場で再定義できる"
"ことです。これは、ライブループが実行されている間にも、その中でやっていることが変更できるということです。これがSonic Piのライブコーディングの秘訣です"
"。試してみましょう。"

#: A.02-live-coding.md:60
#, no-wrap
msgid ""
"live_loop :choral_drone do\n"
"  sample :ambi_choir, rate: 0.4\n"
"  sleep 1\n"
"end"
msgstr ""
"live_loop :choral_drone do\n"
"  sample :ambi_choir, rate: 0.4\n"
"  sleep 1\n"
"end"

#: A.02-live-coding.md:67
#, fuzzy
msgid ""
"Now press the Run button or hit `Meta-r`. You're now listening to some gorgeou"
"s choir sounds. Now, whilst it's still playing, change the rate from `0.4` to "
"`0.38`. Hit run again. Woah! Did you hear the choir change note? Change it bac"
"k up to `0.4` to return back to how it was. Now, drop it to `0.2`, down to `0."
"19` and then back up to `0.4`. See how changing just one parameter on the fly "
"can give you real control of the music? Now play around with the rate yourself"
" - choose your own values. Try negative numbers, really small numbers and larg"
"e numbers. Have fun!"
msgstr ""
"では、`Run`ボタンをクリックするか、キーボードから`alt-r`を叩いてみてください。美しいコーラスのサウンドが聞こえると思います。次に、それが演奏され"
"ている間に、rateを`0.4`から`0.38`に変更して、`Run`を叩いてみてください。ワオ！ コーラスの音程が変わったのが聞こえましたか？ rateを"
"`0.4`に上げて、値を戻すとどうなるか聞いてみましょう。続いて、rateを`0.2`に下げ、さらに`0.19`に下げ、再び`0.4`にあげてみましょう。た"
"った1つのオプションをその場で変更するだけで、音楽をコントロールできるのを実感できるでしょう。では、rateを自分自身で選んで遊んでみましょう。マイナスの数"
"、とても小さい数や大きい数を試してみましょう。楽しんでみてください！"

#: A.02-live-coding.md:77
msgid "Sleeping is important"
msgstr "休みは大切"

#: A.02-live-coding.md:79
msgid ""
"One of the most important lessons about `live_loop`s is that they need rest. C"
"onsider the following `live_loop`:"
msgstr "`live_loop`に関する最も重要な教訓の1つは、それを*休ませる*ことが必要だということです。次の`live_loop`を考えてみましょう。"

#: A.02-live-coding.md:82
#, no-wrap
msgid ""
"live_loop :infinite_impossibilities do\n"
"  sample :ambi_choir\n"
"end"
msgstr ""
"live_loop :infinite_impossibilities do\n"
"  sample :ambi_choir\n"
"end"

#: A.02-live-coding.md:88
msgid ""
"If you try running this code, you'll immediately see Sonic Pi complaining that"
" the `live_loop` did not sleep. This is a safety system kicking in! Take a mom"
"ent to think about what this code is asking the computer to do. That's right, "
"it's asking the computer to play an infinite amount of choir samples in zero t"
"ime. Without the safety system the poor computer will try and do this and cras"
"h and burn in the process. So remember, your `live_loop`s must contain a `slee"
"p`."
msgstr ""
"このコードを実行しようとすると、`live_loop`が`sleep`していないとSonic Piがエラーを出すでしょう。これはセーフティシステムが実行され"
"たことを示しています。このコードがコンピュータに何を実行させようとしているか、少し考えてみてください。そうです。無限の数のコーラスのサンプルを0秒の間に再生"
"するように指示してるのですね。もしセーフティシステムが無ければ、コンピュータはこれを実行しようして壊れてしまうでしょう。そんな訳で、`live_loop`に"
"は必ず`sleep`を含めることを覚えておいてください。"

#: A.02-live-coding.md:97
msgid "Combining Sounds"
msgstr "音を混ぜ合わせる"

#: A.02-live-coding.md:99
msgid ""
"Music is full of things happening at the same time. Drums at the same time as "
"bass at the same time as vocals at the same time as guitars... In computing we"
" call this concurrency and Sonic Pi provides us with an amazingly simple way o"
"f playing things at the same time. Simply use more than one `live_loop`!"
msgstr ""
"音楽は同時に発生する事象で溢れています。ギターとボーカルが同時に鳴っているところにベースが同時に鳴り、それらと同時にドラムが鳴るといったように…計算機の世界"
"ではこれを*並行性*と呼び、Sonic Piも驚異的にシンプルな方法で同時に演奏することができます。単純に1つより多い`live_loop`を使えばよいので"
"す。"

#: A.02-live-coding.md:105
#, no-wrap
msgid ""
"live_loop :beats do\n"
"  sample :bd_tek\n"
"  with_fx :echo, phase: 0.125, mix: 0.4 do\n"
"    sample  :drum_cymbal_soft, sustain: 0, release: 0.1\n"
"    sleep 0.5\n"
"  end\n"
"end\n"
"live_loop :bass do\n"
"  use_synth :tb303\n"
"  synth :tb303, note: :e1, release: 4, cutoff: 120, cutoff_attack: 1\n"
"  sleep 4\n"
"end"
msgstr ""
"live_loop :beats do\n"
"  sample :bd_tek\n"
"  with_fx :echo, phase: 0.125, mix: 0.4 do\n"
"    sample  :drum_cymbal_soft, sustain: 0, release: 0.1\n"
"    sleep 0.5\n"
"  end\n"
"end\n"
"live_loop :bass do\n"
"  use_synth :tb303\n"
"  synth :tb303, note: :e1, release: 4, cutoff: 120, cutoff_attack: 1\n"
"  sleep 4\n"
"end"

#: A.02-live-coding.md:121
msgid ""
"Here, we have two `live_loop`s, one looping quickly making beats and another l"
"ooping slowly making a crazy bass sound."
msgstr "ここでは、2つの`live_loop`を使っています。1つ目はせわしなくビートを刻み、もう1つはゆっくりとクレイジーなベース音を奏でています。"

#: A.02-live-coding.md:124
msgid ""
"One of the interesting things about using multiple `live_loop`s is that they e"
"ach manage their own time. This means it's really easy to create interesting p"
"olyrhythmical structures and even play with phasing Steve Reich style. Check t"
"his out:"
msgstr ""
"複数の`live_loop`を使った場合に興味深いのは、それぞれのループがそれぞれの時間を管理しているということです。これは、とても簡単にポリリズム的な構造"
"を作ることを意味していて、スティーヴ・ライヒのような位相のずれを演奏することも簡単にできます。以下を見てください。"

#: A.02-live-coding.md:129
#, no-wrap
msgid ""
"# Steve Reich's Piano Phase\n"
"notes = (ring :E4, :Fs4, :B4, :Cs5, :D5, :Fs4, :E4, :Cs5, :B4, :Fs4, :D5, :Cs5"
")\n"
"live_loop :slow do\n"
"  play notes.tick, release: 0.1\n"
"  sleep 0.3\n"
"end\n"
"live_loop :faster do\n"
"  play notes.tick, release: 0.1\n"
"  sleep 0.295\n"
"end"
msgstr ""
"# Steve Reich's Piano Phase\n"
"notes = (ring :E4, :Fs4, :B4, :Cs5, :D5, :Fs4, :E4, :Cs5, :B4, :Fs4, :D5, :Cs5"
")\n"
"live_loop :slow do\n"
"  play notes.tick, release: 0.1\n"
"  sleep 0.3\n"
"end\n"
"live_loop :faster do\n"
"  play notes.tick, release: 0.1\n"
"  sleep 0.295\n"
"end"

#: A.02-live-coding.md:145 A.03-coded-beats.md:155 A.04-synth-riffs.md:166
#: A.05-acid-bass.md:147 A.06-minecraft.md:156 A.07-bizet.md:138
#: A.09-randomisation.md:145 A.10-controlling-your-sound.md:149
#: A.11-beat-tracking.md:176 A.12-sample-slicing.md:137
#: A.13-probabilistic-sequencer.md:137 A.14-amplitude-modulation.md:192
#: A.15-performance.md:152 A.16-practice.md:166 A.17-sample-stretching.md:153
#: A.18-additive-synthesis.md:115 A.19-subtractive-synthesis.md:138
msgid "Bringing it all together"
msgstr "まとめ"

#: A.02-live-coding.md:147
msgid ""
"In each of these tutorials, we'll end with a final example in the form of a ne"
"w piece of music which draws from all of the ideas introduced. Read this code "
"and see if you can imagine what it's doing. Then, copy it into a fresh Sonic P"
"i buffer and hit Run and actually hear what it sounds like. Finally, change on"
"e of the numbers or comment and uncomment things out. See if you can use this "
"as a starting point for a new performance, and most of all have fun! See you n"
"ext time..."
msgstr ""
"これらの個々のチュートリアルで紹介したアイデアの全てから引き出された新しい楽曲の例で終わりにしたいと思います。以下のコードを読んで、何をしているか想像してみ"
"てください。次に、それをSonic Piの新しいBufferにコピーし、`Run`を叩いて実際にどんな音がするか聞いてみましょう。最後に、どれかの数値を変更"
"したり、コードをコメントアウトしたりコメントインしたりしてみましょう。そして、このコードが新しいパフォーマンスの開始点として使えるか見てみましょう。これらは"
"とても楽しいと思います！ ではまた会いましょう。"

#: A.02-live-coding.md:156
#, no-wrap
msgid ""
"with_fx :reverb, room: 1 do\n"
"  live_loop :time do\n"
"    synth :prophet, release: 8, note: :e1, cutoff: 90, amp: 3\n"
"    sleep 8\n"
"  end\n"
"end\n"
"live_loop :machine do\n"
"  sample :loop_garzul, rate: 0.5, finish: 0.25\n"
"  sample :loop_industrial, beat_stretch: 4, amp: 1\n"
"  sleep 4\n"
"end\n"
"live_loop :kik do\n"
"  sample :bd_haus, amp: 2\n"
"  sleep 0.5\n"
"end\n"
"with_fx :echo do\n"
"  live_loop :vortex do\n"
"    # use_random_seed 800\n"
"    notes = (scale :e3, :minor_pentatonic, num_octaves: 3)\n"
"    16.times do\n"
"      play notes.choose, release: 0.1, amp: 1.5\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end"
msgstr ""
"with_fx :reverb, room: 1 do\n"
"  live_loop :time do\n"
"    synth :prophet, release: 8, note: :e1, cutoff: 90, amp: 3\n"
"    sleep 8\n"
"  end\n"
"end\n"
"live_loop :machine do\n"
"  sample :loop_garzul, rate: 0.5, finish: 0.25\n"
"  sample :loop_industrial, beat_stretch: 4, amp: 1\n"
"  sleep 4\n"
"end\n"
"live_loop :kik do\n"
"  sample :bd_haus, amp: 2\n"
"  sleep 0.5\n"
"end\n"
"with_fx :echo do\n"
"  live_loop :vortex do\n"
"    # use_random_seed 800\n"
"    notes = (scale :e3, :minor_pentatonic, num_octaves: 3)\n"
"    16.times do\n"
"      play notes.choose, release: 0.1, amp: 1.5\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end"

#: A.03-coded-beats.md:1
msgid "A.3 Coded Beats"
msgstr "A.3 コード化されたビート"

#: A.03-coded-beats.md:3
msgid "Coded Beats"
msgstr "コード化されたビート"

#: A.03-coded-beats.md:5
msgid ""
"One of the most exciting and disrupting technical developments in modern music"
" was the invention of samplers. These were boxes that allowed you to record an"
"y sound into them and then manipulate and play back those sounds in many inter"
"esting ways. For example, you could take an old record, find a drum solo (or b"
"reak), record it into your sampler and then play it back on repeat at half-spe"
"ed to provide the foundation for your latest beats. This is how early hip-hop "
"music was born and today it's almost impossible to find electronic music that "
"doesn't incorporate samples of some kind. Using samples is a really great way "
"of easily introducing new and interesting elements into your live coded perfor"
"mances."
msgstr ""
"現代の音楽における技術的な発展で最も刺激的かつ飛躍的なものの1つは、サンプラーの発明だったと言えます。サンプラーは、あらゆる音を記録し、操作し、そしてさまざ"
"まな方法でこれらのサウンドを再生することができる箱です。たとえば、もしあなたが古いレコードを持っていたとして、そこからドラムソロ（もしくはブレイク）を探しだ"
"し、サンプラーに記録して半分の速度で再生すれば、あなたの作品のビートの下地として利用可能です。これはどのように初期のヒップホップが生まれたかを示すものですが"
"、今日の電子音楽でこのようなサンプルを含まないものを探すことは、ほぼ不可能でしょう。サンプルを使用することは、あなたのライブコーディングのパフォーマンスに、"
"新しく面白い要素を簡単に追加する本当に素晴らしい方法です。"

#: A.03-coded-beats.md:17
msgid ""
"So where can you get a sampler? Well you already have one - it's your Raspberr"
"y Pi! The built-in live coding app Sonic Pi has an extremely powerful sampler "
"built into its core. Let's play with it!"
msgstr ""
"ではサンプラーはどこにあるのでしょう？ サンプラーは既にRaspberry Piの中にあります！ Raspberry Piに同梱されたSonic Piはとて"
"もパワフルなサンプラーを内蔵しています。これで遊んでみましょう！"

#: A.03-coded-beats.md:21
msgid "The Amen Break"
msgstr "アーメン・ブレイク"

#: A.03-coded-beats.md:23
msgid ""
"One of the most classic and recognisable drum break samples is called the Amen"
" Break. It was first performed in 1969 in the song \"Amen Brother\" by the Winst"
"ons as part of a drum break. However, it was when it was discovered by early h"
"ip-hop musicians in the 80s and used in samplers that it started being heavily"
" used in a wide variety of other styles such as drum and bass, breakbeat, hard"
"core techno and breakcore."
msgstr ""
"古典的でよく知られたドラムブレイクはアーメン・ブレイクと呼ばれるものです。アーメン・ブレイクは、Winstonsによって1969年に\"Amen Brothe"
"r\"という曲で、ドラムブレイクの一部として演奏されました。しかし、それは初期のヒップホップミュージシャンによって80年代に発見されてサンプラーで使用された後"
"、ドラムンベース、ブレイクビート、ハードコア・テクノ、ブレイクコアといった他の幅広いジャンルでも頻繁に使用されるようになりました。"

#: A.03-coded-beats.md:30
msgid ""
"I'm sure you're excited to hear that it's also built right into Sonic Pi. Clea"
"r up a buffer and throw in the following code:"
msgstr ""
"アーメン・ブレイクがSonic Piにも内蔵していると聞いて、あなたがワクワクしてくれると思っています。Bufferをきれいにして、次のコードを入力してみて"
"ください。"

#: A.03-coded-beats.md:37
msgid ""
"Hit *Run* and boom! You're listening to one of the most influential drum break"
"s in the history of dance music. However, this sample wasn't famous for being "
"played as a one-shot, it was built for being looped."
msgstr ""
"*Run*を叩いて、ブーンとやってみてください！ ダンスミュージックの歴史で最も影響力のあったドラムブレイクの1つを聞くことができるでしょう。しかし、これは"
"1回限りで演奏されることよりも、ループとして演奏されることで有名です。"

#: A.03-coded-beats.md:42
msgid "Beat Stretching"
msgstr "ビートを引き延ばす"

#: A.03-coded-beats.md:44
msgid ""
"Let's loop the Amen Break by using our old friend the `live_loop` introduced i"
"n this tutorial last month:"
msgstr "先月のチュートリアルで紹介した、我々にはもうお馴染みの`live_loop`を使って、アーメン・ブレイクをループしてみましょう。"

#: A.03-coded-beats.md:47
#, no-wrap
msgid ""
"live_loop :amen_break do\n"
"  sample :loop_amen\n"
"  sleep 2\n"
"end"
msgstr ""
"live_loop :amen_break do\n"
"  sample :loop_amen\n"
"  sleep 2\n"
"end"

#: A.03-coded-beats.md:54
msgid ""
"OK, so it is looping, but there's an annoying pause every time round. That is "
"because we asked it to sleep for `2` beats and with the default BPM of 60 the "
"`:loop_amen` sample only lasts for `1.753` beats. We therefore have a silence "
"of `2 - 1.753 = 0.247` beats. Even though it's short, it's still noticeable."
msgstr ""
"ループはしていますね。でもループする度に不快な無音部分がありますね。これは、`2`拍sleepするように指示しているのに、`:loop_amen`のサンプル"
"は、デフォルトのBPM60で`1.753`拍しか持続しないからです。したがって、`2 - 1.753 = 0.247`拍の無音が発生していしまいます。その時"
"間は短くはありますが、容易に気づくことができます。"

#: A.03-coded-beats.md:60
msgid ""
"To fix this issue we can use the `beat_stretch:` opt to ask Sonic Pi to stretc"
"h (or shrink) the sample to match the specified number of beats."
msgstr ""
"この問題を解決するのに、`beat_stretch:`オプションを使うことができます。このオプションは、指定した数値の拍に合うようにサンプルを引き延ばす（あ"
"るいは縮める）ことを、Sonic Piに指示します。"

#: A.03-coded-beats.md:63
msgid ""
"Sonic Pi's `sample` and `synth` fns give you a lot of control via optional par"
"ameters such as `amp:`, `cutoff:` and `release:`. However, the term optional p"
"arameter is a real mouthful so we just call them *opts* to keep things nice an"
"d simple."
msgstr ""
"Sonic Piの`sample`と`synth`関数は、`amp:`や`cutoff:`、`release:`といったオプション引数によって、数多くの操作"
"を提供しています。しかし、オプション引数という言葉は言いにくいので、単純にするために*オプション*と呼ぶようにします。"

#: A.03-coded-beats.md:68
#, no-wrap
msgid ""
"live_loop :amen_break do\n"
"  sample :loop_amen, beat_stretch: 2\n"
"  sleep 2\n"
"end  "
msgstr ""
"live_loop :amen_break do\n"
"  sample :loop_amen, beat_stretch: 2\n"
"  sleep 2\n"
"end  "

#: A.03-coded-beats.md:75
msgid ""
"Now we're dancing! Although, perhaps we want to speed it up or slow it down to"
" suit the mood."
msgstr "これでダンスできますね！ だけど、おそらく雰囲気に合わせてこのサンプルを速くしたり遅くしたりしたいと思うのではないでしょうか。"

#: A.03-coded-beats.md:78
msgid "Playing with Time"
msgstr "時間に合わせて演奏する"

#: A.03-coded-beats.md:80
msgid ""
"OK, so what if we want to change styles to old school hip hop or breakcore? On"
"e simple way of doing this is to play with time - or in other words mess with "
"the tempo. This is super easy in Sonic Pi - just throw in a `use_bpm` into you"
"r live loop:"
msgstr ""
"では、オールドスクールのヒップホップやブレイクコアのスタイルに変更したい場合にはどうしたら良いでしょう。それを実現する簡単な方法は、時間に合わせて演奏するこ"
"とです。言い換えると、テンポを操作するということです。これは、Sonic Piではとても簡単です。`use_bpm`をライブループに入れるだけでよいのです。"

#: A.03-coded-beats.md:85
#, no-wrap
msgid ""
"live_loop :amen_break do\n"
"  use_bpm 30\n"
"  sample :loop_amen, beat_stretch: 2\n"
"  sleep 2\n"
"end "
msgstr ""
"live_loop :amen_break do\n"
"  use_bpm 30\n"
"  sample :loop_amen, beat_stretch: 2\n"
"  sleep 2\n"
"end "

#: A.03-coded-beats.md:93
msgid ""
"Whilst you're rapping over those slow beats, notice that we're still sleeping "
"for 2 and our BPM is 30, yet everything is in time. The `beat_stretch` opt wor"
"ks with the current BPM to make sure everything just works."
msgstr ""
"この遅いビートでラップしている間に、BPM30であっても2拍sleepして全てが時間通りであることに気がつくと思います。全てがただ時間通りに動くように、`b"
"eat_stretch`オプションが現行のBPMと協調して動作しているのです。"

#: A.03-coded-beats.md:97
msgid ""
"Now, here's the fun part. Whilst the loop is still live, change the `30` in th"
"e `use_bpm 30` line to `50`. Woah, everything just got faster yet *kept in tim"
"e*! Try going faster - up to 80, to 120, now go crazy and punch in 200!"
msgstr ""
"ここからが面白くなるところです。ループが動作している状態のまま、`use_bpm 30`の`30`を`50`に変更してみましょう。ワオ、全てが、*時間通りの"
"まま*速くなりました！ もっと速く、80や、120、そしてもっとクレイジーになって200を打ち込んでみましょう！"

#: A.03-coded-beats.md:103
msgid "Filtering"
msgstr "フィルタリング"

#: A.03-coded-beats.md:105
msgid ""
"Now we can live loop samples, let's look at some of the most fun opts provided"
" by the `sample` synth. First up is `cutoff:` which controls the cutoff filter"
" of the sampler. By default this is disabled but you can easily turn it on:"
msgstr ""
"サンプルをライブループできるようになったので、`sample`で提供されている楽しいオプションを見ていきましょう。最初は、`cutoff:`です。これはサン"
"プラーのカットオフ・フィルタを操作します。このオプションはデフォルトでは無効になっていますが、簡単に有効にできます。"

#: A.03-coded-beats.md:110
#, no-wrap
msgid ""
"live_loop :amen_break do\n"
"  use_bpm 50\n"
"  sample :loop_amen, beat_stretch: 2, cutoff: 70\n"
"  sleep 2\n"
"end  "
msgstr ""
"live_loop :amen_break do\n"
"  use_bpm 50\n"
"  sample :loop_amen, beat_stretch: 2, cutoff: 70\n"
"  sleep 2\n"
"end  "

#: A.03-coded-beats.md:118
msgid ""
"Go ahead and change the `cutoff:` opt. For example, increase it to 100, hit *R"
"un* and wait for the loop to cycle round to hear the change in the sound. Noti"
"ce that low values like 50 sound mellow and bassy and high values like 100 and"
" 120 are more full-sounding and raspy. This is because the `cutoff:` opt will "
"chop out the high frequency parts of the sound just like a lawn-mower chops of"
"f the top of the grass. The `cutoff:` opt is like the length setting - determi"
"ning how much grass is left over."
msgstr ""
"続いて`cutoff:`オプションを変更してみましょう。たとえば100に変更後*Run*を叩いて、どう音が変化するかループの終わりまで聞いてみてください。5"
"0のような小さい値はメロウで低音が強調され、100や120といった大きい値は、より幅広い音が聞こえ、ザラザラとしていることに気付くでしょう。これは`cuto"
"ff:`オプションが、ちょうど草刈機が芝生を刈るように、高い周波数の部分を削り取るからです。`cutoff:`オプションは長さの設定（どれだけ芝生を残すか）"
"のようなものです。"

#: A.03-coded-beats.md:128
msgid "Slicing"
msgstr "スライスする"

#: A.03-coded-beats.md:130
msgid ""
"Another great tool to play with is the slicer FX. This will chop (slice) the s"
"ound up. Wrap the `sample` line with the FX code like this:"
msgstr ""
"もう1つの遊んでみるべき凄いツールは、スライサー・エフェクトです。これは音をブツ切り（スライス）にします。`sample`の行を次のようにスライサー・エフェ"
"クトで包んでみましょう。"

#: A.03-coded-beats.md:133
#, no-wrap
msgid ""
"live_loop :amen_break do\n"
"  use_bpm 50\n"
"  with_fx :slicer, phase: 0.25, wave: 0, mix: 1 do\n"
"    sample :loop_amen, beat_stretch: 2, cutoff: 100\n"
"  end\n"
"  sleep 2\n"
"end"
msgstr ""
"live_loop :amen_break do\n"
"  use_bpm 50\n"
"  with_fx :slicer, phase: 0.25, wave: 0, mix: 1 do\n"
"    sample :loop_amen, beat_stretch: 2, cutoff: 100\n"
"  end\n"
"  sleep 2\n"
"end"

#: A.03-coded-beats.md:143
#, fuzzy
msgid ""
"Notice how the sound bounces up and down a little more. (You can hear the orig"
"inal sound without the FX by changing the `mix:` opt to `0`.) Now, try playing"
" around with the `phase:` opt. This is the rate (in beats) of the slicing effe"
"ct. A smaller value like `0.125` will slice faster and larger values like `0.5"
"` will slice more slowly. Notice that successively halving or doubling the `ph"
"ase:` opts val tends to always sound good. Finally, change the `wave:` opt to "
"one of 0, 1, or 2 and hear how it changes the sound. These are the various wav"
"e shapes. 0 is a saw wave, (hard in, fade out) 1 is a square wave (hard in, ha"
"rd out) and 2 is a triangle wave (fade in, fade out)."
msgstr ""
"音が弾むように聞こえるようになったのに気付くでしょう（`mix`オプションを`0`に変更することで、エフェクトの掛かっていない元の音を聞くこともできます）。"
"では、`phase:`オプションで遊んでみましょう。これは、スライサー・エフェクトの（ビートに対する）レートです。`0.125`といった小さい値は速くスライ"
"スし、より大きな` 0.5`といった値はより遅くスライスします。`phase:`を半分にしたり倍にしたりすると、良い感じに聞こえるでしょう。最後に、`wav"
"e:`オプションを0, 1, 2のいずれかにして、音の変化を聞いてみましょう。これらは波形の形で、0はノコギリ波、1は矩形波、2は三角波です。"

#: A.03-coded-beats.md:157
msgid ""
"Finally, let's go back in time and revisit the early Bristol drum and bass sce"
"ne with this month's example. Don't worry too much about what all this means, "
"just type it in, hit Run, then start live coding it by changing opt numbers an"
"d see where you can take it. Please do share what you create! See you next tim"
"e..."
msgstr ""
"最後に、今月の例として、時代を遡って初期のブリストルのドラムンベースシーンを再訪してみましょう。あまり上記の意味するところは気にせずに、ただコードをタイプし"
"て実行し、オプションの値を変更してライブコーディングを開始して、どのような音になるか聞いてみましょう。そして、あなたの作ったものを是非共有してください！ で"
"はまた。"

#: A.03-coded-beats.md:163
#, no-wrap
msgid ""
"use_bpm 100\n"
"live_loop :amen_break do\n"
"  p = [0.125, 0.25, 0.5].choose\n"
"  with_fx :slicer, phase: p, wave: 0, mix: rrand(0.7, 1) do\n"
"    r = [1, 1, 1, -1].choose\n"
"    sample :loop_amen, beat_stretch: 2, rate: r, amp: 2\n"
"  end\n"
"  sleep 2\n"
"end\n"
"live_loop :bass_drum do\n"
"  sample :bd_haus, cutoff: 70, amp: 1.5\n"
"  sleep 0.5\n"
"end\n"
"live_loop :landing do\n"
"  bass_line = (knit :e1, 3, [:c1, :c2].choose, 1)\n"
"  with_fx :slicer, phase: [0.25, 0.5].choose, invert_wave: 1, wave: 0 do\n"
"    s = synth :square, note: bass_line.tick, sustain: 4, cutoff: 60\n"
"    control s, cutoff_slide: 4, cutoff: 120\n"
"  end\n"
"  sleep 4\n"
"end"
msgstr ""
"use_bpm 100\n"
"live_loop :amen_break do\n"
"  p = [0.125, 0.25, 0.5].choose\n"
"  with_fx :slicer, phase: p, wave: 0, mix: rrand(0.7, 1) do\n"
"    r = [1, 1, 1, -1].choose\n"
"    sample :loop_amen, beat_stretch: 2, rate: r, amp: 2\n"
"  end\n"
"  sleep 2\n"
"end\n"
"live_loop :bass_drum do\n"
"  sample :bd_haus, cutoff: 70, amp: 1.5\n"
"  sleep 0.5\n"
"end\n"
"live_loop :landing do\n"
"  bass_line = (knit :e1, 3, [:c1, :c2].choose, 1)\n"
"  with_fx :slicer, phase: [0.25, 0.5].choose, invert_wave: 1, wave: 0 do\n"
"    s = synth :square, note: bass_line.tick, sustain: 4, cutoff: 60\n"
"    control s, cutoff_slide: 4, cutoff: 120\n"
"  end\n"
"  sleep 4\n"
"end"

#: A.04-synth-riffs.md:1
msgid "A.4 Synth Riffs"
msgstr "A.4 シンセ・リフ"

#: A.04-synth-riffs.md:3
msgid "Synth Riffs"
msgstr "シンセ・リフ"

#: A.04-synth-riffs.md:5
msgid ""
"Whether it's the haunting drift of rumbling oscillators or the detuned punch o"
"f saw waves piercing through the mix, the lead synth plays an essential role o"
"n any electronic track. In last month's edition of this tutorial series we cov"
"ered how to code our beats. In this tutorial we'll cover how to code up the th"
"ree core components of a synth riff - the timbre, melody and rhythm."
msgstr ""
"リードシンセは、たとえそれがゴロゴロ鳴るオシレーターの浮遊であったり、ミックスを通して耳をつんざくようなデチューンされたノコギリ波であったしても、あらゆる電"
"子音楽において不可欠な役割を果たしています。先月の記事では、ビートをどのようにコーディングするかについて紹介しました。今月の記事では、シンセ・リフの3つのコ"
"アな要素、すなわち、その音色、メロディー、リズムをどのようにコーディングするかについて紹介したいと思います。"

#: A.04-synth-riffs.md:12
msgid ""
"OK, so power up your Raspberry Pi, crack open Sonic Pi v2.6+ and let's make so"
"me noise!"
msgstr "では、Raspberry Piを起動し、v2.6以降のSonic Piを開いて、音を出してみましょう！"

#: A.04-synth-riffs.md:16
msgid "Timbral Possibilities"
msgstr "音色の可能性"

#: A.04-synth-riffs.md:18
msgid ""
"An essential part of any synth riff is changing and playing with the timbre of"
" the sounds. We can control the timbre in Sonic Pi in two ways - choosing diff"
"erent synths for a dramatic change and setting the various synth opts for more"
" subtle modifications. We can also use FX, but that's for another tutorial..."
msgstr ""
"シンセ・リフに不可欠な要素は、音色で遊んだり変更したりすることです。Sonic Piでは、2つの方法で音色を操作することができます。劇的な変化として異なるシ"
"ンセを選択することと、より微かな調整としてシンセのオプションの設定を変更することです。またエフェクトも使用できますが、これについては別なチュートリアルが必要"
"そうです…"

#: A.04-synth-riffs.md:24
msgid "Let's create a simple live loop where we continually change the current synth:"
msgstr "シンセを継続的に変更するシンプルなライブループを作ってみましょう。"

#: A.04-synth-riffs.md:27
#, no-wrap
msgid ""
"live_loop :timbre do\n"
"  use_synth (ring :tb303, :blade, :prophet, :saw, :beep, :tri).tick\n"
"  play :e2, attack: 0, release: 0.5, cutoff: 100\n"
"  sleep 0.5\n"
"end"
msgstr ""
"live_loop :timbre do\n"
"  use_synth (ring :tb303, :blade, :prophet, :saw, :beep, :tri).tick\n"
"  play :e2, attack: 0, release: 0.5, cutoff: 100\n"
"  sleep 0.5\n"
"end"

#: A.04-synth-riffs.md:35
msgid ""
"Take a look at the code. We're simply ticking through a ring of synth names (t"
"his will cycle through each of these in turn repeating the list over and over)"
". We pass this synth name to the `use_synth` fn (function) which will change t"
"he `live_loop`'s current synth. We also play note `:e2` (E at the second octav"
"e), with a release time of 0.5 beats (half a second at the default BPM of 60) "
"and with the `cutoff:` opt set to 100."
msgstr ""
"コードを見てみてください。ここでは、シンセの名前のリングを単純にチックしています（リングはリストを何度も繰り返すことで、シンセの名前を循環します）。そして、"
"シンセの名前を`use_synth`関数に渡すことで、`live_loop`で使用するシンセを変更しています。また、`:e2`（2番目のオクターブのE）の音"
"符を、リリースタイムを0.5拍（デフォルトBPMの60では0.5秒）、`cutoff:`オプションを100で演奏しています。"

#: A.04-synth-riffs.md:42
msgid ""
"Hear how the different synths have very different sounds even though they're a"
"ll playing the same note. Now experiment and have a play. Change the release t"
"ime to bigger and smaller values. For example, change the `attack:` and `relea"
"se:` opts to see how different fade in/out times have a huge impact on the sou"
"nd. Finally change the `cutoff:` opt to see how different cutoff values also m"
"assively influence the timbre (values between 60 and 130 are good). See how ma"
"ny different sounds you can create by just changing a few values. Once you've "
"mastered that, just head to the Synths tab in the Help system for a full list "
"of all the synths and all the available opts each individual synth supports to"
" see just how much power you have under your coding fingertips."
msgstr ""
"異なるシンセが、全く同じ音符を鳴らしているにもかかわらず、とても異なった音に聞こえるでしょう。では、実験して遊んでみましょう。リリースタイムを大きい値や小さ"
"い値に変更してみましょう。たとえば、`attack:`や`release:`オプションを変更して、フェードイン・フェードアウトの時間が音にとても大きなインパ"
"クトを与えるのを見てみましょう。最後に`cutoff:`オプションを変更して（60と130の間の値が良いでしょう）、カットオフの値もまた音色にとても大きな影"
"響を与えるのを見てみましょう。いくつかの値を変更するだけで、多くの音を作り出せたのではないでしょうか。このことを一度修得してしまえば、ヘルプシステムの`シン"
"セ`タブには全てのシンセの一覧と個々のシンセが利用可能な全てのオプションがあり、コーディングの際にすぐ利用できるでしょう。"

#: A.04-synth-riffs.md:55
msgid "Timbre"
msgstr "音色"

#: A.04-synth-riffs.md:57
msgid ""
"Timbre is just a fancy word describing the sound of a sound. If you play the s"
"ame note with different instruments such as a violin, guitar, or piano, the pi"
"tch (how high or low it sounds) would be the same, but the sound quality would"
" be different. That sound quality - the thing which allows you to tell the dif"
"ference between a piano and a guitar is the timbre."
msgstr ""
"音色とは、ある音がどう鳴っているかを表現する、ただの聞こえの良い言葉です。もしあなたがバイオリン、ギター、ピアノといった異なる楽器で同じ音符を演奏すると、音"
"程（音が高いか低いか）は同じでも、音の質は違うでしょう。その音の質、つまりピアノとギターとの違いを指摘できるような内容、が音色です。"

#: A.04-synth-riffs.md:65
msgid "Melodic Composition"
msgstr "メロディーの作曲"

#: A.04-synth-riffs.md:67
msgid ""
"Another important aspect to our lead synth is the choice of notes we want to p"
"lay. If you already have a good idea, then you can simply create a ring with y"
"our notes in and tick through them:"
msgstr ""
"リード・シンセで重要なもう1つの側面は、演奏する音符の選択です。もしあなたが良いメロディーのアイデアを既に持っていたら、単純にそれをリングに入れてチックして"
"いくことができます。"

#: A.04-synth-riffs.md:71
#, no-wrap
msgid ""
"live_loop :riff do\n"
"  use_synth :prophet\n"
"  riff = (ring :e3, :e3, :r, :g3, :r, :r, :r, :a3)\n"
"  play riff.tick, release: 0.5, cutoff: 80\n"
"  sleep 0.25\n"
"end"
msgstr ""
"live_loop :riff do\n"
"  use_synth :prophet\n"
"  riff = (ring :e3, :e3, :r, :g3, :r, :r, :r, :a3)\n"
"  play riff.tick, release: 0.5, cutoff: 80\n"
"  sleep 0.25\n"
"end"

#: A.04-synth-riffs.md:80
msgid ""
"Here, we've defined our melody with a ring which includes both notes such as `"
":e3` and rests represented by `:r`. We're then using `.tick` to cycle through "
"each note to give us a repeating riff."
msgstr ""
"ここでは、`:e3`といった音符と`:r`で表現される休符を含むリングでメロディーを定義しています。そして、リフが繰り返し演奏されるように、`.tick`を"
"使ってリングを循環しています。"

#: A.04-synth-riffs.md:84
msgid "Auto Melody"
msgstr "自動メロディー"

#: A.04-synth-riffs.md:86
msgid ""
"It's not always easy to come up with a nice riff from scratch. Instead it's of"
"ten easier to ask Sonic Pi for a selection of random riffs and to choose the o"
"ne you like the best. To do that we need to combine three things: rings, rando"
"misation and random seeds. Let's look at an example:"
msgstr ""
"良いリフを一から思いつくのは、いつも簡単であるとは限りません。ランダムなリフの生成をSonic Piにお願いして、出来たリフから一番良いと思うものを選ぶほう"
"が、より簡単なケースが多いでしょう。これを実現するのに、次の3つのものが必要です。リングとランダム化とランダムシードです。例を見てみましょう。"

#: A.04-synth-riffs.md:91
#, no-wrap
msgid ""
"live_loop :random_riff do\n"
"  use_synth :dsaw\n"
"  use_random_seed 3\n"
"  notes = (scale :e3, :minor_pentatonic).shuffle\n"
"  play notes.tick, release: 0.25, cutoff: 80\n"
"  sleep 0.25\n"
"end"
msgstr ""
"live_loop :random_riff do\n"
"  use_synth :dsaw\n"
"  use_random_seed 3\n"
"  notes = (scale :e3, :minor_pentatonic).shuffle\n"
"  play notes.tick, release: 0.25, cutoff: 80\n"
"  sleep 0.25\n"
"end"

#: A.04-synth-riffs.md:101
msgid ""
"There's a few things going on - let's look at them in turn. First, we specify "
"that we're using random seed 3. What does this mean? Well, the useful thing is"
" that when we set the seed, we can predict what the next random value is going"
" to be - it's the same as it was last time we set the seed to 3! Another usefu"
"l thing to know is that shuffling a ring of notes works in the same way. In th"
"e example above we're essentially asking for the 'third shuffle' in the standa"
"rd list of shuffles - which is also the same every time as we're always settin"
"g the random seed to the same value right before the shuffle. Finally we're ju"
"st ticking through our shuffled notes to play the riff."
msgstr ""
"ここではいくつかのことが実行されています。順番に見ていきましょう。最初に、ランダムシードとしてここでは3を使っています。これは何を意味するのでしょうか？ そ"
"うですね、シードを設定することで便利な点は、次のランダム値が何になるか正確に予測できることです。つまり、最後にシードを3に設定したときと同じになります。もう"
"1つ便利な点は、音符のリングのシャッフルでも同じように動作することです。上記の例では、標準的なシャッフルのリストの内の`3番目のシャッフル`を必然的に要求し"
"ていることになります。これもシャッフルする直前に設定したランダムシードの値が同じであれば常に同じになります。最後に、シャッフルされた音符を単純にチックして、"
"リフを演奏しています。"

#: A.04-synth-riffs.md:112
msgid ""
"Now, here's where the fun starts. If we change the random seed value to anothe"
"r number, say 3000, we get an entirely different shuffling of the notes. So no"
"w it's extremely easy to explore new melodies. Simply choose the list of notes"
" we want to shuffle (scales are a great starting point) and then choose the se"
"ed we want to shuffle with. If we don't like the melody, just change one of th"
"ose two things and try again. Repeat until you like what you hear!"
msgstr ""
"ここからが面白くなるところです。ランダムシードを別な値、たとえば3000に変更すると、全く異なったシャッフルの音符が得られるでしょう。これは、新しいメロディ"
"ーを探索する方法としては、極めて簡単でしょう。シャッフルしたい音符のリスト（スケールはとても良い出発点でしょう）を選択し、続いてシードを選択してみましょう。"
"もし生成されたメロディーが気に入らなかったら、音符のリストかシードのいずれかを変更して、もう一度やってみましょう。気にいったものが生成されるまで、続けてみま"
"しょう！"

#: A.04-synth-riffs.md:121
msgid "Pseudo Randomisation"
msgstr "疑似ランダム化"

#: A.04-synth-riffs.md:123
msgid ""
"Sonic Pi's randomisation is not actually random it's what's called pseudo rand"
"om. Imagine if you were to roll a dice 100 times and write down the result of "
"each roll onto a piece of paper. Sonic Pi has the equivalent of this list of r"
"esults which it uses when you ask for a random value. Instead of rolling an ac"
"tual dice, it just picks the next value from the list. Setting the random seed"
" is just jumping to a specific point in that list."
msgstr ""
"Sonic Piのランダム化は、実際には真のランダムではなく擬似ランダムと呼ばれるものです。サイコロを100回振ってその結果を紙切れに書いておくのを想像して"
"みてください。Sonic Piは、その結果のリストと同等のものを持っていて、ランダムな値を要求されるとそれを使っています。実際のサイコロを振る代わりに、リス"
"トから次の値を単純に取得しているのです。そして、ランダムシードの設定は、リストの特定の場所に移動しているに過ぎません。"

#: A.04-synth-riffs.md:131
msgid "Finding your Rhythm"
msgstr "リズムを発見する"

#: A.04-synth-riffs.md:133
msgid ""
"Another important aspect to our riff is the rhythm - when to play a note and w"
"hen not to. As we saw above we can use `:r` in our rings to insert rests. Anot"
"her very powerful way is to use spreads which we'll cover in a future tutorial"
". Today we'll use randomisation to help us find our rhythm. Instead of playing"
" every note we can use a conditional to play a note with a given probability. "
"Let's take a look:"
msgstr ""
"リフで重要なもう1つの側面は、リズム（いつ音符を演奏していつ演奏しないのか）です。以前に、休符として`:r`をリングに使用できることを見たと思います。他の非"
"常に強力な方法としては、`spread`関数を使う方法がありますが、これはいずれチュートリアルで扱いたいと思います。今回はリズムの発見にランダム化を使ってみ"
"たいと思います。全ての音符を演奏する代わりに、確率によってある特定の条件でのみ演奏することが可能です。次のコードを見てみましょう。"

#: A.04-synth-riffs.md:140
#, no-wrap
msgid ""
"live_loop :random_riff do\n"
"  use_synth :dsaw\n"
"  use_random_seed 30\n"
"  notes = (scale :e3, :minor_pentatonic).shuffle\n"
"  16.times do\n"
"    play notes.tick, release: 0.2, cutoff: 90 if one_in(2)\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"live_loop :random_riff do\n"
"  use_synth :dsaw\n"
"  use_random_seed 30\n"
"  notes = (scale :e3, :minor_pentatonic).shuffle\n"
"  16.times do\n"
"    play notes.tick, release: 0.2, cutoff: 90 if one_in(2)\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: A.04-synth-riffs.md:152
msgid ""
"A really useful fn to know is `one_in` which will give us a `true` or `false` "
"value with the specified probability. Here, we're using a value of 2 so on ave"
"rage one time every two calls to `one_in` it will return `true`. In other word"
"s, 50% of the time it will return `true`. Using higher values will make it ret"
"urn `false` more often introducing more space into the riff."
msgstr ""
"知ってると本当に便利な関数は、`one_in`でしょう。この関数は指定した確率に依存して`true`か`false`を返します。ここでは、引数として2を使用"
"しているので、`one_in`を2回呼ぶ度に1回`true`を返します。言い換えると、50％の確率で`true`を返します。2よりも大きな値を使用すると`f"
"alse`をより多く返し、リフにより多くの休符を与えるでしょう。"

#: A.04-synth-riffs.md:159
msgid ""
"Notice that we've added some iteration in here with `16.times`. This is becaus"
"e we only want to reset our random seed value every 16 notes so our rhythm rep"
"eats every 16 times. This doesn't affect the shuffling as that is still done i"
"mmediately after the seed is set. We can use the iteration size to alter the l"
"ength of the riff. Try changing the 16 to 8 or even 4 or 3 and see how it affe"
"cts the rhythm of the riff."
msgstr ""
"また、ここで`16.times`という繰り返しが追加されていることに気づいたかもしれません。これは、16個の音符の度にランダムシードをリセットしたいためです"
"。これにより、16回の繰り返しの度に、リフのリズムが繰り返されます。これはシャッフルには影響しません。なぜなら、それはシードを設定した直後に実行されているか"
"らです。リフの長さを変更するために、繰り返しのサイズを変更することができます。16という値を、8, 4, 3といった値に変更して、それがどのようにリフのリズ"
"ムに影響するか見てみてください。"

#: A.04-synth-riffs.md:168
msgid ""
"OK, so let's combine everything we've learned together into one final example."
" See you next time!"
msgstr "今回学習したことをまとめて最後の例としましょう。ではまた！"

#: A.04-synth-riffs.md:171
#, no-wrap
msgid ""
"live_loop :random_riff do\n"
"  #  uncomment to bring in:\n"
"  #  synth :blade, note: :e4, release: 4, cutoff: 100, amp: 1.5\n"
"  use_synth :dsaw\n"
"  use_random_seed 43\n"
"  notes = (scale :e3, :minor_pentatonic, num_octaves: 2).shuffle.take(8)\n"
"  8.times do\n"
"    play notes.tick, release: rand(0.5), cutoff: rrand(60, 130) if one_in(2)\n"
"    sleep 0.125\n"
"  end\n"
"end\n"
" \n"
"live_loop :drums do\n"
"  use_random_seed 500\n"
"  16.times do\n"
"    sample :bd_haus, rate: 2, cutoff: 110 if rand < 0.35\n"
"    sleep 0.125\n"
"  end\n"
"end\n"
" \n"
"live_loop :bd do\n"
"  sample :bd_haus, cutoff: 100, amp: 3\n"
"  sleep 0.5\n"
"end"
msgstr ""
"live_loop :random_riff do\n"
"  #  uncomment to bring in:\n"
"  #  synth :blade, note: :e4, release: 4, cutoff: 100, amp: 1.5\n"
"  use_synth :dsaw\n"
"  use_random_seed 43\n"
"  notes = (scale :e3, :minor_pentatonic, num_octaves: 2).shuffle.take(8)\n"
"  8.times do\n"
"    play notes.tick, release: rand(0.5), cutoff: rrand(60, 130) if one_in(2)\n"
"    sleep 0.125\n"
"  end\n"
"end\n"
" \n"
"live_loop :drums do\n"
"  use_random_seed 500\n"
"  16.times do\n"
"    sample :bd_haus, rate: 2, cutoff: 110 if rand < 0.35\n"
"    sleep 0.125\n"
"  end\n"
"end\n"
" \n"
"live_loop :bd do\n"
"  sample :bd_haus, cutoff: 100, amp: 3\n"
"  sleep 0.5\n"
"end"

#: A.05-acid-bass.md:1
msgid "A.5 Acid Bass"
msgstr "A.5 アシッドベース"

#: A.05-acid-bass.md:3
msgid "Acid Bass"
msgstr "アシッドベース"

#: A.05-acid-bass.md:5
msgid ""
"It's impossible to look through the history of electronic dance music without "
"seeing the enormous impact of the tiny Roland TB-303 synthesiser. It's the sec"
"ret sauce behind the original acid bass sound. Those classic squealing and squ"
"elching TB-303 bass riffs can be heard from the early Chicago House scene thro"
"ugh to more recent electronic artists such as Plastikman, Squarepusher and Aph"
"ex Twin."
msgstr ""
"エレクトロニック・ダンス・ミュージックの歴史を俯瞰する上で、ローランドTB-303の多大な影響を無視することは出来ないでしょう。それはアシッドベースサウンド"
"の秘伝のタレであると言えます。古典的なTB-303のベースリフは、初期のシカゴハウスのシーンからPlastikman, SquarepusherやAphex"
" Twinといったより最近の電子音楽のアーティストで聞くことができるでしょう。"

#: A.05-acid-bass.md:12
msgid ""
"Interestingly, Roland never intended for the TB-303 to be used in dance music."
" It was originally created as a practice aid for guitarists. They imagined tha"
"t people would program them to play bass lines to jam along to. Unfortunately "
"there were a number of problems: they were a little fiddly to program, didn't "
"sound particularly good as a bass-guitar replacement and were pretty expensive"
" to buy. Deciding to cut their losses, Roland stopped making them after 10,000"
" units were sold and after a number of years sitting on guitarist's shelves, t"
"hey soon could be found in the windows of second hand shops. These lonely disc"
"arded TB-303s were waiting to be discovered by a new generation of experimente"
"rs who started using them in ways that Roland didn't imagine to create new cra"
"zy sounds. Acid House was born."
msgstr ""
"興味深いことに、ローランドはTB-303をダンスミュージックで使うことを全く意図していませんでした。それは元々ギタリストの練習の補助として作られ、一緒にジャ"
"ムセッションする際のベースラインを演奏するのにプログラムされるだろうと思われていました。しかし残念なことに、TB-303には多くの問題がありました。プログラ"
"ムするのが少し厄介であったり、ベースの代わりとしてはそれ程良い音がしなかったこと、そして購入するのにかなり高かったことがあります。ローランドは利益の損失を削"
"減するために、TB-303が10,000個売れた後で、製造を中止することにしました。そして、ギタリストの棚に数年置かれていた後に、中古ショップのウィンドウで"
"見かけることになりました。これらの寂しく捨てられたTB-303は、ローランドが想像もしなかった方法でクレイジーなサウンドを作り出す新しい時代の実験的なアーテ"
"ィストによって発見されるのを待つことになったのです。そしてアシッドハウスは生まれたのです。"

#: A.05-acid-bass.md:25
msgid ""
"Although getting your hands on an original TB-303 is not so easy you will be p"
"leased to know that you can turn your Raspberry Pi into one using the power of"
" Sonic Pi. Behold, fire up Sonic Pi and throw this code into an empty buffer a"
"nd hit Run:"
msgstr ""
"オリジナルのTB-303を入手するのはとても困難ですが、Sonic Piの力でRaspberry PiをTB-303にすることが出来るのです。よく見ていてく"
"ださい。Sonic Piを起動して、空のBufferに以下のコードを打ち込んで、`Run`を打ってください。"

#: A.05-acid-bass.md:30
#, no-wrap
msgid ""
"use_synth :tb303\n"
"play :e1"
msgstr ""
"use_synth :tb303\n"
"play :e1"

#: A.05-acid-bass.md:35
msgid "Instant acid bass! Let's play around..."
msgstr "とても簡単なアシッドベースですね！ これで遊んでみましょう…"

#: A.05-acid-bass.md:37
#, fuzzy
msgid "Squelch that Bass"
msgstr "ベースをスケルチさせる"

#: A.05-acid-bass.md:39
msgid ""
"First, let's build a live arpeggiator to make things fun. In the last tutorial"
" we looked at how riffs can just be a ring of notes that we tick through one a"
"fter another, repeating when we get to the end. Let's create a live loop that "
"does exactly that:"
msgstr ""
"最初に、音が面白くなるようにライブ・アルペジエーターを作ってみましょう。前回のチュートリアルで、リフが音符のリングで実現できるのを見ました。リングは、要素を"
"次々と進めて行って（チックして）、末尾に達すると先頭に戻って繰り返します。それと同じことを実行するライブループを作ってみましょう。"

#: A.05-acid-bass.md:44
#, no-wrap
msgid ""
"use_synth :tb303\n"
"live_loop :squelch do\n"
"  n = (ring :e1, :e2, :e3).tick\n"
"  play n, release: 0.125, cutoff: 100, res: 0.8, wave: 0\n"
"  sleep 0.125\n"
"end"
msgstr ""
"use_synth :tb303\n"
"live_loop :squelch do\n"
"  n = (ring :e1, :e2, :e3).tick\n"
"  play n, release: 0.125, cutoff: 100, res: 0.8, wave: 0\n"
"  sleep 0.125\n"
"end"

#: A.05-acid-bass.md:53
msgid "Take a look at each line."
msgstr "一行ごとに見て行きましょう。"

#: A.05-acid-bass.md:55
msgid ""
"On the first line we set the default synth to be `tb303` with the `use_synth` "
"fn."
msgstr "最初の行では、`use_synth`関数でデフォルトのシンセを`tb303`に設定しています。"

#: A.05-acid-bass.md:58
msgid ""
"On line two we create a live loop called `:squelch` which will just loop round"
" and round."
msgstr "2行目では、`:squelch`という名前のライブループを作って、単純にループを繰り返しています。"

#: A.05-acid-bass.md:61
msgid ""
"Line three is where we create our riff - a ring of notes (E in octaves 1, 2, a"
"nd 3) which we simply tick through with `.tick`. We define `n` to represent th"
"e current note in the riff. The equals sign just means to assign the value on "
"the right to the name on the left. This will be different every time round the"
" loop. The first time round, `n` will be set to `:e1`. The second time round i"
"t will be `:e2`, followed by `:e3`, and then back to `:e1`, cycling round fore"
"ver."
msgstr ""
"3行目ではリフを作っています。1, 2, 3番目のオクターブのEからなる音符のリングを`.tick`で単純に進めて行っています。リフの現在の音符を示すのに`"
"n`を定義しています。等号は、単に右の値を左の名前に割り当てることを意味しています。この値はループが繰り返される度に異なります。最初の繰り返しでは、`n`は"
"`:e1`に設定されています。2回目の繰り返しでは`:e2`になり、その次は`:e3`です。そして、その次には`:e1`に戻って、永遠に繰り返し循環していま"
"す。"

#: A.05-acid-bass.md:70
msgid ""
"Line four is where we actually trigger our `:tb303` synth. We're passing a few"
" interesting opts here: `release:`, `cutoff:`, `res:` and `wave:` which we'll "
"discuss below."
msgstr ""
"4行目では、実際に`:tb303`シンセをトリガーしています。ここで、いくつか興味深いオプションを渡しています。`release:`, `cutoff:`,"
" `res:`と`wave:`です。これらについては、この後議論します。"

#: A.05-acid-bass.md:74
msgid ""
"Line five is our `sleep` - we're asking the live loop to loop round every `0.1"
"25`s or 8 times a second at the default BPM of 60."
msgstr "5行目は`sleep`です。デフォルトBPMの60で、`0.125`秒毎または1秒間に8回ライブループを繰り返すよう指示しています。"

#: A.05-acid-bass.md:77
msgid ""
"Line six is the `end` to the live loop. This just tells Sonic Pi where the end"
" of the live loop is."
msgstr "6行目はライブループの`end`です。これは単にSonic Piにライブループの終わりの箇所を示しています。"

#: A.05-acid-bass.md:80
msgid ""
"Whilst you're still figuring out what's going on, type in the code above and h"
"it the Run button. You should hear the `:tb303` kick into action. Now, this is"
" where the action is: let's start live coding."
msgstr ""
"このコードで何が起きているか思い描いている途中かもしれませんが、上記のコードをタイプして`Run`ボタンを叩いてみてください。`:tb303`が動作し始める"
"のを聞くことができるでしょう。では、ライブコーディングを始めましょう。"

#: A.05-acid-bass.md:84
msgid ""
"Whilst the loop is still live, change the `cutoff:` opt to `110`. Now hit the "
"Run button again. You should hear the sound become a little harsher and more s"
"quelchy. Dial in `120` and hit run. Now `130`. Listen how higher cutoff values"
" make it sound more piercing and intense. Finally, drop it down to `80` when y"
"ou feel like a rest. Then repeat as many times as you want. Don't worry, I'll "
"still be here..."
msgstr ""
"ライブループが動作している最中に、`cutoff:`オプションを`110`に変更して、`Run`ボタンを再度叩いてみてください。音がざらついて押しつぶされた"
"ように聞こえると思います。次に`120`に変更して`Run`を叩いてみてください。更に`130`はどうでしょう。より大きなカットオフの値が、よりけたたましく"
"激しい音にしているのを聞くことができるでしょう。最後に、休みたくなったら`80`にしてみましょう。これらを好きなだけ繰り返してみてください。心配しないで。私"
"はずっとここに居ますよ…"

#: A.05-acid-bass.md:91
msgid ""
"Another opt worth playing with is `res:`. This controls the level of resonance"
" of the filter. A high resonance is characteristic of acid bass sounds. We cur"
"rently have our `res:` set to `0.8`. Try cranking it up to `0.85`, then `0.9`,"
" and finally `0.95`. You might find that a cutoff such as `110` or higher will"
" make the differences easier to hear. Finally go crazy and dial in `0.999` for"
" some insane sounds. At a `res` this high, you're hearing the cutoff filter re"
"sonate so much it starts to make sounds of its own!"
msgstr ""
"他に遊んでみる価値のあるオプションは、`res:`でしょう。これはフィルタのレゾナンスのレベルを制御しています。高いレゾナンスはアシッドベースサウンドの特徴"
"です。上のコードで`res:`は`0.8`に設定されています。これを`0.85`に上げ、次に`0.9`に上げ、最後に`0.95`に上げてみましょう。`110"
"`やそれより大きいカットオフで、より違いを聞き分けることができるかもしれません。最後に、狂ったサウンドを出すのに、思い切って`0.999`にしてみましょう。"
"`res`が高いと、カットオフフィルタがより共振し、独特のサウンドを出し始めるのを聞くことができるでしょう。"

#: A.05-acid-bass.md:100
msgid ""
"Finally, for a big impact on the timbre try changing the `wave:` opt to `1`. T"
"his is the choice of source oscillator. The default is `0` which is a sawtooth"
" wave. `1` is a pulse wave and `2` is a triangle wave."
msgstr ""
"最後に、音色に大きなインパクトを与えるのに、`wave:`オプションを`1`に変更してみてください。これはオシレーターの選択です。デフォルトは`0`で、ノコ"
"ギリ波です。`1`はパルス波で、`2`は三角波です。"

#: A.05-acid-bass.md:104
msgid ""
"Of course, try different riffs by changing the notes in the ring or even picki"
"ng notes from scales or chords. Have fun with your first acid bass synth."
msgstr ""
"もちろん、リングの中の音符を変更したり、スケールやコードから音符を選択して、異なるリフを試してみるのも良いでしょう。はじめてのアシッドベースシンセを楽しんで"
"ください。"

#: A.05-acid-bass.md:108
msgid "Deconstructing the TB-303"
msgstr "TB-303の分解"

#: A.05-acid-bass.md:110
msgid ""
"The design of the original TB-303 is actually pretty simple. As you can see fr"
"om the following diagram there's only 4 core parts."
msgstr "オリジナルのTB-303の設計は、実際のところとてもシンプルです。以下の略図から分かるように、4つのコアな部分しかありません。"

#: A.05-acid-bass.md:113
#, fuzzy
msgid ""
"![TB-303 Design](../../../etc/doc/images/tutorial/articles/A.05-acid-bass/tb30"
"3-design.png)"
msgstr ""
"![TB-303 Design](../../../etc/doc/images/tutorial/articles/A.05-acid-bass/tb30"
"3-design.png)"

#: A.05-acid-bass.md:115
#, fuzzy
msgid ""
"First is the oscillator wave - the raw ingredients of the sound. In this case "
"we have a square wave. Next there's the oscillator's amplitude envelope which "
"controls the amp of the square wave through time. These are accessed in Sonic "
"Pi by the `attack:`, `decay:`, `sustain:` and `release:` opts along with their"
" level counterparts. For more information read Section 2.4 'Duration with Enve"
"lopes' in the built-in tutorial. We then pass our enveloped square wave throug"
"h a resonant low pass filter. This chops off the higher frequencies as well as"
" having that nice resonance effect. Now this is where the fun starts. The cuto"
"ff value of this filter is also controlled by its own envelope! This means we "
"have amazing control over the timbre of the sound by playing with both of thes"
"e envelopes. Let's take a look:"
msgstr ""
"最初はオシレーターです。これは音の原材料となるものです。この図では、矩形波を使っています。次にオシレーターのエンベロープがあります。これは矩形波の音量を時間"
"に沿って制御しています。Sonic Piでは、`attack:`, `decay:`, `sustain:`, `release:`オプションで対応する音量"
"レベルにアクセスできます。より詳細な情報は、チュートリアルの'2.4 エンベロープでのデュレーション'を参照してください。エンベロープされた矩形波は、ローパ"
"スフィルタに渡しています。これは、高い周波数をカットするとともに、レゾナンスエフェクトを追加します。ここからが面白くなるところです。このローパスフィルタのカ"
"ットオフの値もまた、独自のエンベロープで制御されているのです！ これは、2つのエンベロープを弄ることで、サウンドの音色を驚異的に変化できることを意味している"
"のです。次のコードを見てみましょう。"

#: A.05-acid-bass.md:128
#, no-wrap
msgid ""
"use_synth :tb303\n"
"with_fx :reverb, room: 1 do\n"
"  live_loop :space_scanner do\n"
"    play :e1, cutoff: 100, release: 7, attack: 1, cutoff_attack: 4, cutoff_rel"
"ease: 4\n"
"    sleep 8\n"
"  end\n"
"end"
msgstr ""
"use_synth :tb303\n"
"with_fx :reverb, room: 1 do\n"
"  live_loop :space_scanner do\n"
"    play :e1, cutoff: 100, release: 7, attack: 1, cutoff_attack: 4, cutoff_rel"
"ease: 4\n"
"    sleep 8\n"
"  end\n"
"end"

#: A.05-acid-bass.md:138
msgid ""
"For each standard envelope opt, there's a `cutoff_` equivalent opt in the `:tb"
"303` synth. So, to change the cutoff attack time we can use the `cutoff_attack"
":` opt. Copy the code above into an empty buffer and hit Run. You'll hear a cr"
"azy sound warble in and out. Now start to play. Try changing the `cutoff_attac"
"k:` time to `1` and then `0.5`. Now try `8`."
msgstr ""
"`:tb303`シンセでは、標準的なエンベロープオプションの1つ1つに対応して、`cutoff_`に同等のオプションがあります。したがって、カットオフのアタ"
"ック時間を変更するのには、`cutoff_attack:`オプションを使うことができます。上のコードを空のBufferにコピーして実行してみてください。震え"
"たクレイジーな音を聞くことができるでしょう。では遊んでみましょう。`cutoff_attack:`を`1`に変更し、次に`0.5`に変更してみてください。さ"
"らに`8`を試してみましょう。"

#: A.05-acid-bass.md:144
msgid ""
"Notice that I've passed everything through a `:reverb` FX for extra atmosphere"
" - try other FX to see what works!"
msgstr "追加の雰囲気のために全てを`:reverb`エフェクトに渡しているのに気が付いたかもしれません。他のエフェクトもどう作用するか試してみてください！"

#: A.05-acid-bass.md:149
msgid ""
"Finally, here's a piece I composed using the ideas in this tutorial. Copy it i"
"nto an empty buffer, listen for a while and then start live coding your own ch"
"anges. See what crazy sounds you can make with it! See you next time..."
msgstr ""
"最後に、今回のチュートリアルのアイデアを使って制作したコードを紹介します。空のBufferにコピーして少しの間聞いてみてください。そしてあなた自身のコードに"
"なるようライブコーディングしてみてください。このコードでどんなクレイジーな音が作れたか見てみてください！ では次回…"

#: A.05-acid-bass.md:154
#, no-wrap
msgid ""
"use_synth :tb303\n"
"use_debug false\n"
" \n"
"with_fx :reverb, room: 0.8 do\n"
"  live_loop :space_scanner do\n"
"    with_fx :slicer, phase: 0.25, amp: 1.5 do\n"
"      co = (line 70, 130, steps: 8).tick\n"
"      play :e1, cutoff: co, release: 7, attack: 1, cutoff_attack: 4, cutoff_re"
"lease: 4\n"
"      sleep 8\n"
"    end\n"
"  end\n"
" \n"
"  live_loop :squelch do\n"
"    use_random_seed 3000\n"
"    16.times do\n"
"      n = (ring :e1, :e2, :e3).tick\n"
"      play n, release: 0.125, cutoff: rrand(70, 130), res: 0.9, wave: 1, amp: "
"0.8\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end"
msgstr ""
"use_synth :tb303\n"
"use_debug false\n"
" \n"
"with_fx :reverb, room: 0.8 do\n"
"  live_loop :space_scanner do\n"
"    with_fx :slicer, phase: 0.25, amp: 1.5 do\n"
"      co = (line 70, 130, steps: 8).tick\n"
"      play :e1, cutoff: co, release: 7, attack: 1, cutoff_attack: 4, cutoff_re"
"lease: 4\n"
"      sleep 8\n"
"    end\n"
"  end\n"
" \n"
"  live_loop :squelch do\n"
"    use_random_seed 3000\n"
"    16.times do\n"
"      n = (ring :e1, :e2, :e3).tick\n"
"      play n, release: 0.125, cutoff: rrand(70, 130), res: 0.9, wave: 1, amp: "
"0.8\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end"

#: A.06-minecraft.md:1
msgid "A.6 Musical Minecraft"
msgstr "A.6 音楽的なMinecraft"

#: A.06-minecraft.md:3
msgid "Musical Minecraft"
msgstr "音楽的なMinecraft"

#: A.06-minecraft.md:7
msgid ""
"Hello and welcome back! In the previous tutorials we've focussed purely on the"
" music possibilities of Sonic Pi - (turning your Raspberry Pi into a performan"
"ce ready musical instrument). So far we've learned how to:"
msgstr ""
"こんにちは、そしてまたお会いしましたね！ 前回のチュートリアルでは、純粋にSonic Piの音楽的な可能性に焦点を当てました（Raspberry Piをパフ"
"ォーマンスに十分対応可能な楽器にしました）。ここまでで、我々は以下のことを学びました："

#: A.06-minecraft.md:11
msgid "Live Code - changing the sounds on-the-fly,"
msgstr "ライブコーディング - 音楽を止めずに変更する、"

#: A.06-minecraft.md:12
msgid "Code some huge beats,"
msgstr "大規模なビートをコードする、"

#: A.06-minecraft.md:13
msgid "Generate powerful synth leads,"
msgstr "強力なシンセリードを生成する、"

#: A.06-minecraft.md:14
msgid "Re-create the famous TB-303 acid-bass sound."
msgstr "有名なTB-303のアシッドベースサウンドを再生成する。"

#: A.06-minecraft.md:16
msgid ""
"There's so much more to show you (which we will explore in future editions). H"
"owever, this month, let's look at something Sonic Pi can do that you probably "
"didn't realise: control Minecraft."
msgstr ""
"他にもたくさん紹介したい内容はあります（いずれこのチュートリアルで掘り下げる予定です）が、今月は、Sonic Piで出来ることのうち、おそらくあなたが知らな"
"いものを紹介したいと思います。Minecraftの制御です。"

#: A.06-minecraft.md:20
msgid "Hello Minecraft World"
msgstr "Minecraftのワールドへようこそ"

#: A.06-minecraft.md:22
msgid ""
"OK, let's get started. Boot up your Raspberry Pi, fire up Minecraft Pi and cre"
"ate a new world. Now start up Sonic Pi and re-size and move your windows so yo"
"u can see both Sonic Pi and Minecraft Pi at the same time."
msgstr ""
"では始めましょう。Raspberry Piをブートし、Minecraft Piを起動して新しいワールドを作りましょう。そして、Sonic Piを起動し、So"
"nic PiとMinecraft Piの両方が見えるように、ウィンドウをリサイズしたり移動したりしましょう。"

#: A.06-minecraft.md:26
msgid "In a fresh buffer type the following:"
msgstr "新しいBufferに次のコードを入力してみましょう。"

#: A.06-minecraft.md:28
#, no-wrap
msgid "mc_message \"Hello Minecraft from Sonic Pi!\""
msgstr "mc_message \"Hello Minecraft from Sonic Pi!\""

#: A.06-minecraft.md:32
msgid ""
"Now, hit Run. Boom! Your message appeared in Minecraft! How easy was that? Now"
", stop reading this for a moment and play about with your own messages. Have f"
"un!"
msgstr ""
"では、`Run`を叩いてみてください。ブーン！ メッセージがMinecraftに表示されましたね！ とても簡単だったでしょう？ では、チュートリアルを読むの"
"を止めて、少しの間メッセージを変更して遊んでみましょう。楽しでみて！"

#: A.06-minecraft.md:36
#, fuzzy
msgid ""
"![Screen 0](../../../etc/doc/images/tutorial/articles/A.06-minecraft/Musical-M"
"inecraft-0-small.png)"
msgstr ""
"![Screen 0](../../../etc/doc/images/tutorial/articles/A.06-minecraft/Musical-M"
"inecraft-0-small.png)"

#: A.06-minecraft.md:38
msgid "Sonic Teleporter"
msgstr "Sonic Teleporter"

#: A.06-minecraft.md:40
msgid ""
"Now let's do some exploring. The standard option is to reach for the mouse and"
" keyboard and start walking around. That works, but it's pretty slow and borin"
"g. It would be far better if we had some sort of teleport machine. Well, thank"
"s to Sonic Pi, we have one. Try this:"
msgstr ""
"では、少し探検してみましょう。ワールドで移動する標準的なやりかたは、マウスとキーボードを使って、あたりを歩き始めることです。これは機能しますが、かなり遅いし"
"退屈でしょう。何か瞬間移動マシンのようなものがあると良いのですが。。ええ、Sonic Piのおかげで、それは実現できます。これを試してみてください。"

#: A.06-minecraft.md:45
#, no-wrap
msgid "mc_teleport 80, 40, 100"
msgstr "mc_teleport 80, 40, 100"

#: A.06-minecraft.md:49
msgid ""
"Crikey! That was a long way up. If you weren't in flying-mode then you would h"
"ave fallen back down all the way to the ground. If you double-tap space to ent"
"er flying-mode and teleport again, you'll stay hovering at the location you za"
"p to."
msgstr ""
"びっくりした！ 遠くまで移動できたでしょう。もし飛行モードなかったら、全ての行程を戻って地面に落ちてしまうでしょう。スペースキーをダブルタップして飛行モード"
"に入ってもう一度瞬間移動すると、指定した場所に移動して浮いているでしょう。"

#: A.06-minecraft.md:54
msgid ""
"Now, what do those numbers mean? We have three numbers which describe the coor"
"dinates of where in the world we want to go. We give each number a name - x, y"
" and z:"
msgstr ""
"では、これらの数字は何を意味するのでしょうか？ ワールド内の行きたい場所の座標を表現するのに、3つの数字を使っています。そしてそれらに名前を付けています。x"
", yそしてzです。"

#: A.06-minecraft.md:58
msgid "x - how far left and right (80 in our example)"
msgstr "x - どのくらい右端から左に離れてるか（我々の例では80）"

#: A.06-minecraft.md:59
msgid "y - how high we want to be (40 in our example)"
msgstr "y - どのくらい高くあがったか（我々の例では40）"

#: A.06-minecraft.md:60
msgid "z - how far forward and back (100 in our example)"
msgstr "z - どのくらい手前から奥へ離れてるか（我々の例では100）"

#: A.06-minecraft.md:62
msgid ""
"By choosing different values for x, y and z we can teleport *anywhere* in our "
"world. Try it! Choose different numbers and see where you can end up. If the s"
"creen goes black it's because you've teleported yourself under the ground or i"
"nto a mountain. Just choose a higher y value to get back out above land. Keep "
"on exploring until you find somewhere you like..."
msgstr ""
"異なるx, y, zの値を選ぶことで、ワールドの中の*どこでも*瞬間移動することができます。試してみよう！ 違う値を選んで、どこに辿り着いたか見てみましょう"
"。もし画面が真っ黒になってしまったら、それは地面の下か山の中に瞬間移動してしまったからです。地面よりも上に戻るように大きなyの値を選択してください。何か発見"
"するまで探検を続けましょう…"

#: A.06-minecraft.md:69
msgid ""
"Using the ideas so far, let's build a Sonic Teleporter which makes a fun telep"
"ort sound whilst it whizzes us across the Minecraft world:"
msgstr "ここまでのアイデアを使って、Minecraftのワールドを瞬間移動するときの音を面白くする`Sonic Teleporter`を作ってみましょう。"

#: A.06-minecraft.md:72
#, no-wrap
msgid ""
"mc_message \"Preparing to teleport....\"\n"
"sample :ambi_lunar_land, rate: -1\n"
"sleep 1\n"
"mc_message \"3\"\n"
"sleep 1\n"
"mc_message \"2\"\n"
"sleep 1\n"
"mc_message \"1\"\n"
"sleep 1\n"
"mc_teleport 90, 20, 10\n"
"mc_message \"Whoooosh!\""
msgstr ""
"mc_message \"Preparing to teleport....\"\n"
"sample :ambi_lunar_land, rate: -1\n"
"sleep 1\n"
"mc_message \"3\"\n"
"sleep 1\n"
"mc_message \"2\"\n"
"sleep 1\n"
"mc_message \"1\"\n"
"sleep 1\n"
"mc_teleport 90, 20, 10\n"
"mc_message \"Whoooosh!\""

#: A.06-minecraft.md:86
#, fuzzy
msgid ""
"![Screen 1](../../../etc/doc/images/tutorial/articles/A.06-minecraft/Musical-M"
"inecraft-1-small.png)"
msgstr ""
"![Screen 1](../../../etc/doc/images/tutorial/articles/A.06-minecraft/Musical-M"
"inecraft-1-small.png)"

#: A.06-minecraft.md:88
msgid "Magic Blocks"
msgstr "魔法のブロック"

#: A.06-minecraft.md:90
msgid ""
"Now you've found a nice spot, let's start building. You could do what you're u"
"sed to and start clicking the mouse furiously to place blocks under the cursor"
". Or you could use the magic of Sonic Pi. Try this:"
msgstr ""
"では、良い場所が見つかったと思いますので、何か作り始めてみましょう。あなたの慣れたやり方でもできますし、マウスを激しくクリックしてカーソルの部分にブロックを"
"設置することも可能です。それ以外に、Sonic Piの魔法を使うことも可能です。これを試してみてください。"

#: A.06-minecraft.md:94
#, no-wrap
msgid ""
"x, y, z = mc_location\n"
"mc_set_block :melon, x, y + 5, z"
msgstr ""
"x, y, z = mc_location\n"
"mc_set_block :melon, x, y + 5, z"

#: A.06-minecraft.md:99
msgid ""
"Now look up! There's a melon in the sky! Take a moment to look at the code. Wh"
"at did we do? On line one we grabbed the current location of Steve as the vari"
"ables x, y and z. These correspond to our coordinates described above. We use "
"these coordinates in the fn `mc_set_block` which will place the block of your "
"choosing at the specified coordinates. In order to make something higher up in"
" the sky we just need to increase the y value which is why we add 5 to it. Let"
"'s make a long trail of them:"
msgstr ""
"見てみてください！ メロンが空中に現れました！ ここでは何をしてるのでしょうか？ 少し時間を取ってコードを見てみましょう。1行目では、プレイヤーの位置を取得"
"してx, y, zの変数に入れています。これらの対応する座標については上で説明しています。これらの座標は、次の行の`mc_set_block`関数で、指定し"
"たブロックを設置するのに使用されます。ブロックをより高い位置に設置するには、yの値に5を加えていたのを増やす必要があります。次にブロックの長い軌跡を作ってみ"
"ましょう。"

#: A.06-minecraft.md:107
#, no-wrap
msgid ""
"live_loop :melon_trail do\n"
"  x, y, z = mc_location\n"
"  mc_set_block :melon, x, y-1, z\n"
"  sleep 0.125\n"
"end"
msgstr ""
"live_loop :melon_trail do\n"
"  x, y, z = mc_location\n"
"  mc_set_block :melon, x, y-1, z\n"
"  sleep 0.125\n"
"end"

#: A.06-minecraft.md:115
msgid ""
"Now, jump over to Minecraft, make sure you're in flying-mode (double tap space"
" if not) and fly all around the world. Look behind you to see a pretty trail o"
"f melon blocks! See what kind of twisty patterns you can make in the sky."
msgstr ""
"では、Minecraftを表示して、飛行モードであることを確認して（もし飛行モードなかったらスペースキーをダブルタップしましょう）、ワールド中を飛び回ってみ"
"ましょう。後ろにメロンのブロックの可愛い軌跡を見ることができたでしょう。どんなに曲がりくねったパターンでも作れたと思います。"

#: A.06-minecraft.md:120
msgid "Live Coding Minecraft"
msgstr "Minecraftをライブコーディングする"

#: A.06-minecraft.md:122
msgid ""
"Those of you that have been following this tutorial over the last few months w"
"ill probably have your minds blown at this point. The trail of melons is prett"
"y cool, but the most exciting part of the previous example is that you can use"
" `live_loop` with Minecraft! For those that don't know, `live_loop` is Sonic P"
"i's special magic ability that no other programming language has. It lets you "
"run multiple loops at the same time and allows you to change them whilst they "
"run. They are incredibly powerful and amazing fun. I use `live_loop`s to perfo"
"rm music in nightclubs with Sonic Pi - DJs use discs and I use `live_loop`s :-"
") However, today we're going to live code both music and Minecraft."
msgstr ""
"このチュートリアルをここ数ヶ月読んできた人は驚いたかもしれません。メロンの軌跡はとてもクールだけど、先程の例の最もエキサイティングな部分はMinecraft"
"でも`live_loop`を使えるということです！ 知らない方のために説明すると、`live_loop`は他のプログラミング言語が持っていない、Sonic "
"Piの特別な機能です。`live_loop`は複数のループを同時に実行し、また実行している最中にそれを変更することができます。それは信じられないほど強力で、"
"驚くほど楽しいものです。私は、Sonic Piを使ってクラブで音楽を演奏するときに`live_loop`を使います。DJはレコードを使い、私は`live_l"
"oop`を使います:-) 今日は、音楽とMinecraftをライブコーディングしたいと思います。"

#: A.06-minecraft.md:133
msgid ""
"Let's get started. Run the code above and start making your melon trail again."
" Now, without stopping the code, just simply change `:melon` to `:brick` and h"
"it run. Hey presto, you're now making a brick trail. How simple was that! Fanc"
"y some music to go with it? Easy. Try this:"
msgstr ""
"では始めましょう。先程のコードを実行し、メロンの軌跡を作ってみましょう。そして、そのコードを止めずに、ただ`:melon`を`:brick`に変更して`Ru"
"n`を叩いてみてください。あら不思議、レンガの軌跡が作れたでしょう。なんと簡単なのでしょう！ それに合わせて何か気の利いた音楽はいかがでしょう？ それも簡単"
"です。これを試してみてください。"

#: A.06-minecraft.md:138
#, no-wrap
msgid ""
"live_loop :bass_trail do\n"
"  tick\n"
"  x, y, z = mc_location\n"
"  b = (ring :melon, :brick, :glass).look\n"
"  mc_set_block b, x, y -1, z\n"
"  note = (ring :e1, :e2, :e3).look\n"
"  use_synth :tb303\n"
"  play note, release: 0.1, cutoff: 70\n"
"  sleep 0.125\n"
"end"
msgstr ""
"live_loop :bass_trail do\n"
"  tick\n"
"  x, y, z = mc_location\n"
"  b = (ring :melon, :brick, :glass).look\n"
"  mc_set_block b, x, y -1, z\n"
"  note = (ring :e1, :e2, :e3).look\n"
"  use_synth :tb303\n"
"  play note, release: 0.1, cutoff: 70\n"
"  sleep 0.125\n"
"end"

#: A.06-minecraft.md:151
msgid ""
"Now, whilst that's playing start changing the code. Change the block types - t"
"ry `:water`, `:grass` or your favourite block type. Also, try changing the cut"
"off value from `70` to `80` and then up to `100`. Isn't this fun?"
msgstr ""
"では、それが演奏されている間に、コードを変更してみましょう。ブロックのタイプを変更してみましょう。`:water`や `:grass`、そしてあなたの好きな"
"ブロックを試してみましょう。それに加えて、カットオフの値を`70`から`80`に変更し、そして`100`に上げてみましょう。楽しいよね？"

#: A.06-minecraft.md:158
#, fuzzy
msgid ""
"![Screen 2](../../../etc/doc/images/tutorial/articles/A.06-minecraft/Musical-M"
"inecraft-2-small.png)"
msgstr ""
"![Screen 2](../../../etc/doc/images/tutorial/articles/A.06-minecraft/Musical-M"
"inecraft-2-small.png)"

#: A.06-minecraft.md:160
msgid ""
"Let's combine everything we've seen so far with a little extra magic. Let's co"
"mbine our teleportation ability with block placing and music to make a Minecra"
"ft Music Video. Don't worry if you don't understand it all, just type it in an"
"d have a play by changing some of the values whilst it's running live. Have fu"
"n and see you next time..."
msgstr ""
"ここまで見てきた全てに、ちょっとした魔法を追加して組み合わせてみましょう。瞬間移動とブロック設置の機能と音楽を組み合わせて、Minecraftのミュージック"
"ビデオを作ってみましょう。全てを理解できなくても気にせずに、ただ以下のコードをタイプして、いくつかの値を実行中に変更してみましょう。楽しんでください。ではま"
"た…"

#: A.06-minecraft.md:166
#, no-wrap
msgid ""
"live_loop :note_blocks do\n"
"  mc_message \"This is Sonic Minecraft\"\n"
"  with_fx :reverb do\n"
"    with_fx :echo, phase: 0.125, reps: 32 do\n"
"      tick\n"
"      x = (range 30, 90, step: 0.1).look\n"
"      y = 20\n"
"      z = -10\n"
"      mc_teleport x, y, z\n"
"      ns = (scale :e3, :minor_pentatonic)\n"
"      n = ns.shuffle.choose\n"
"      bs = (knit :glass, 3, :sand, 1)\n"
"      b = bs.look\n"
"      synth :beep, note: n, release: 0.1\n"
"      mc_set_block b, x+20, n-60+y, z+10\n"
"      mc_set_block b, x+20, n-60+y, z-10\n"
"      sleep 0.25\n"
"    end\n"
"  end\n"
"end\n"
"live_loop :beats do\n"
"  sample :bd_haus, cutoff: 100\n"
"  sleep 0.5\n"
"end"
msgstr ""
"live_loop :note_blocks do\n"
"  mc_message \"This is Sonic Minecraft\"\n"
"  with_fx :reverb do\n"
"    with_fx :echo, phase: 0.125, reps: 32 do\n"
"      tick\n"
"      x = (range 30, 90, step: 0.1).look\n"
"      y = 20\n"
"      z = -10\n"
"      mc_teleport x, y, z\n"
"      ns = (scale :e3, :minor_pentatonic)\n"
"      n = ns.shuffle.choose\n"
"      bs = (knit :glass, 3, :sand, 1)\n"
"      b = bs.look\n"
"      synth :beep, note: n, release: 0.1\n"
"      mc_set_block b, x+20, n-60+y, z+10\n"
"      mc_set_block b, x+20, n-60+y, z-10\n"
"      sleep 0.25\n"
"    end\n"
"  end\n"
"end\n"
"live_loop :beats do\n"
"  sample :bd_haus, cutoff: 100\n"
"  sleep 0.5\n"
"end"

#: A.07-bizet.md:1
msgid "A.7 Bizet Beats"
msgstr "A.7 ビゼービート"

#: A.07-bizet.md:3
msgid "Bizet Beats"
msgstr "ビゼービート"

#: A.07-bizet.md:5
msgid ""
"After our brief excursion to the fantastic world of coding Minecraft with Soni"
"c Pi last month, let's get musical again. Today we're going to bring a classic"
"al operatic dance piece straight into the 21st century using the awesome power"
" of code."
msgstr ""
"先月は、Sonic PiでMinecraftのコーディングの素晴らしい世界に小旅行しましたが、また音楽的なものに戻りましょう。今日は、コードの凄い力を使って"
"、クラシックのオペラ作品を21世紀に持ち込んでみましょう。"

#: A.07-bizet.md:10
msgid "Outrageous and Disruptive"
msgstr "奇抜で破壊的な"

#: A.07-bizet.md:12
msgid ""
"Let's jump into a time machine back to the year 1875. A composer called Bizet "
"had just finished his latest opera Carmen. Unfortunately like many exciting an"
"d disruptive new pieces of music people initially didn't like it at all becaus"
"e it was too outrageous and different. Sadly Bizet died ten years before the o"
"pera gained huge international success and became one of the most famous and f"
"requently performed operas of all time. In sympathy with this tragedy let's ta"
"ke one of the main themes from Carmen and convert it to a modern format of mus"
"ic that is also too outrageous and different for most people in our time - liv"
"e coded music!"
msgstr ""
"タイムマシンに乗って1875年に遡ってみましょう。ビゼーという作曲家が、彼の最後のオペラ作品となるカルメンを書き上げました。不運なことに、その作品は、多くの"
"刺激的で破壊的な新しい音楽作品と同じように、あまりに奇抜でまた普通でないために、当初人々には全く好かれませんでした。そして残念なことに、その作品が国際的に多"
"大な成功を収め、歴史上、最も有名で頻繁に公演されるオペラの1つになる10年前にビゼーは亡くなってしまいました。この悲劇に共感して、カルメンのメインテーマの1"
"つを取り上げ、現代を生きる多くの人々にとって、あまりに奇抜でまた普通でない形式の音楽 - ライブコーディングされた音楽に変換してみましょう！"

#: A.07-bizet.md:23
msgid "Decoding the Habanera"
msgstr "ハバネラの解読"

#: A.07-bizet.md:25
msgid ""
"Trying to live code the whole opera would be a bit of a challenge for this tut"
"orial, so let's focus on one of the most famous parts - the bass line to the H"
"abanera:"
msgstr "このチュートリアルでカルメンの全体をライブコーディングしようとするのは少し難しいので、最も有名な部分 - ハバネラのベースラインに着目しましょう。"

#: A.07-bizet.md:29
#, fuzzy
msgid ""
"![Habanera Riff](../../../etc/doc/images/tutorial/articles/A.07-bizet/habanera"
".png)"
msgstr ""
"![Habanera Riff](../../../etc/doc/images/tutorial/articles/A.07-bizet/habanera"
".png)"

#: A.07-bizet.md:31
msgid ""
"This may look extremely unreadable to you if you haven't yet studied music not"
"ation. However, as programmers we see music notation as just another form of c"
"ode - only it represents instructions to a musician instead of a computer. We "
"therefore need to figure out a way of decoding it."
msgstr ""
"もしあなたが楽譜について学んでいなかったら、これは全く読めないでしょう。しかし、プログラマとして楽譜を見ると、それはプログラミングコードの別な形式と捉えるこ"
"とができます。つまり楽譜は、コンピュータの代わりに演奏者に対する指示を表していると言えます。したがって我々は楽譜を解読する方法を理解する必要があります。"

#: A.07-bizet.md:36
msgid "Notes"
msgstr "音符"

#: A.07-bizet.md:38
msgid ""
"The notes are arranged from left to right like the words in this magazine but "
"also have different heights. *The height on the score represents the pitch of "
"the note.* The higher the note on the score, the higher the pitch of the note."
msgstr ""
"音符は、左から右に、ちょうどこの雑誌の単語と同じように並んでいますが、それぞれ異なる高さの位置を持っています。*楽譜上の高さは、音符のピッチ（音程）を表して"
"います。* つまり、楽譜上高い位置にあるものほど、音符のピッチは高くなります。"

#: A.07-bizet.md:43
msgid ""
"In Sonic Pi we already know how to change the pitch of a note - we either use "
"high or low numbers such as `play 75` and `play 80` or we use the note names: "
"`play :E` and `play :F`. Luckily each of the vertical positions of the musical"
" score represents a specific note name. Take a look at this handy look up tabl"
"e:"
msgstr ""
"Sonic Piでのピッチの変更方法は既に知っているはずです。`play 75`や`play 80`といったように数値を使ったり、`play :E`や`pl"
"ay :F`といったように音名を使ったりできます。楽譜の上下の位置は、それぞれ特定の音名を表しています。便利な対応表を見てみましょう。"

#: A.07-bizet.md:49
#, fuzzy
msgid "![Notes](../../../etc/doc/images/tutorial/articles/A.07-bizet/notes.png)"
msgstr "![Notes](../../../etc/doc/images/tutorial/articles/A.07-bizet/notes.png)"

#: A.07-bizet.md:51
msgid "Rests"
msgstr "休符"

#: A.07-bizet.md:53
msgid ""
"Music scores are an extremely rich and expressive kind of code capable of comm"
"unicating many things. It therefore shouldn't come as much of a surprise that "
"musical scores can not only tell you what notes to play but also when *not* to"
" play notes. In programming this is pretty much equivalent to the idea of `nil"
"` or `null` - the absence of a value. In other words not playing a note is lik"
"e the absence of a note."
msgstr ""
"楽譜はとても表現力豊かなコードで、多くのことを伝達できます。したがって、楽譜がどの音符を演奏するかについてのみならず、音符をいつ演奏*しない*かについて伝達"
"していても、それほど驚くことではないでしょう。これは、プログラミングにおいては`nil`とか`null`（値の無いこと）と同じ考え方です。言い換えると、音符"
"を演奏しないことは、音符が無いことに似ていると言えるでしょう。"

#: A.07-bizet.md:60
msgid ""
"If you look closely at the score you'll see that it's actually a combination o"
"f black dots with lines which represent notes to play and squiggly things whic"
"h represent the rests. Luckily Sonic Pi has a very handy representation for a "
"rest: `:r`, so if we run: `play :r` it actually plays silence! We could also w"
"rite `play :rest`, `play nil` or `play false` which are all equivalent ways of"
" representing rests."
msgstr ""
"楽譜をよく見ると、演奏する音符を表す点と線の記号と、休符を表す曲がりくねった記号との組合せであることが分かると思います。Sonic Piにはとても便利な休符"
"の表現として`:r`が用意されていて、`play :r`を実行するとSonic Piは無音を演奏するのです！ これはまた、`play :rest`や`pla"
"y nil`や`play false`とも書くことができ、これらはみな休符を表す同じ方法です。"

#: A.07-bizet.md:67
msgid "Rhythm"
msgstr "リズム"

#: A.07-bizet.md:69
msgid ""
"Finally, there's one last thing to learn how to decode in the notation - the t"
"imings of the notes. In the original notation you'll see that the notes are co"
"nnected with thick lines called beams. The second note has two of these beams "
"which means it lasts for a 16th of a beat. The other notes have a single beam "
"which means they last for an 8th of a beat. The rest has two squiggly beams wh"
"ich means it also represents a 16th of the beat."
msgstr ""
"楽譜を解読するのに学習する最後の内容は、音符のタイミングです。元の楽譜では、音符同士を繋げる細い線、連桁（beam）と呼ばれているものを見ることができるでし"
"ょう。2つ目の音符では2つの連桁があり、これは16分の1拍だけ音が持続することを意味しています。その他の音符は1つの連桁を持っていて、それは8分の1拍だけ音"
"が持続することを意味しています。休符は2つの曲がりくねった連桁を持っていて、これもまた16分の1拍を表しています。"

#: A.07-bizet.md:77
msgid ""
"When we attempt to decode and explore new things a very handy trick is to make"
" everything as similar as possible to try and see any relationships or pattern"
"s. For example, when we re-write our notation purely in 16ths you can see that"
" our notation just turns into a nice sequence of notes and rests."
msgstr ""
"新しいことを探索したり解読したりするときに役立つコツは、全てを可能な限り似たものにし、それらの関係やパターンを見出すことです。たとえば、元の楽譜を純粋に16"
"分で記述し直すと、音符と休符の良い感じのシークエンスに変わるでしょう。"

#: A.07-bizet.md:83
#, fuzzy
msgid ""
"![Habanera Riff 2](../../../etc/doc/images/tutorial/articles/A.07-bizet/habane"
"ra2.png)"
msgstr ""
"![Habanera Riff 2](../../../etc/doc/images/tutorial/articles/A.07-bizet/habane"
"ra2.png)"

#: A.07-bizet.md:85
msgid "Re-coding the Habanera"
msgstr "ハバネラの再コーディング"

#: A.07-bizet.md:87
msgid ""
"We're now in a position to start translating this bass line to Sonic Pi. Let's"
" encode these notes and rests in a ring:"
msgstr "ハバネラのベースラインをSonic Piに翻訳する準備ができました。音符と休符をリングにコード化しましょう。"

#: A.07-bizet.md:90
#, no-wrap
msgid "(ring :d, :r, :r, :a, :f5, :r, :a, :r)"
msgstr "(ring :d, :r, :r, :a, :f5, :r, :a, :r)"

#: A.07-bizet.md:94
msgid "Let's see what this sounds like. Throw it in a live loop and tick through it:"
msgstr "どんな音がするか聞いてみましょう。ライブループに入れて、チックでリングを循環するようにしましょう。"

#: A.07-bizet.md:97
#, no-wrap
msgid ""
"live_loop :habanera do\n"
"  play (ring :d, :r, :r, :a, :f5, :r, :a, :r).tick\n"
"  sleep 0.25\n"
"end"
msgstr ""
"live_loop :habanera do\n"
"  play (ring :d, :r, :r, :a, :f5, :r, :a, :r).tick\n"
"  sleep 0.25\n"
"end"

#: A.07-bizet.md:104
msgid ""
"Fabulous, that instantly recognisable riff springs to life through your speake"
"rs. It took a lot of effort to get here, but it was worth it - high five!"
msgstr ""
"すばらしい。スピーカーから一瞬でそれと分かるリフが活動的に鳴り始めたと思います。ここまで辿り着くのに多くの苦労がありましたが、その価値はありました。やったね"
"！"

#: A.07-bizet.md:108
msgid "Moody Synths"
msgstr "ムーディーなシンセ"

#: A.07-bizet.md:110
msgid ""
"Now we have the bass line, let's re-create some of the ambience of the operati"
"c scene. One synth to try out is `:blade` which is a moody 80s style synth lea"
"d. Let's try it with the starting note `:d` passed through a slicer and reverb"
":"
msgstr ""
"ベースラインが出来たので、オペラのシーンの背景音を再生成してみましょう。試してみるシンセの1つは、`:blade`です。これは、80年代スタイルのムーディー"
"なリードシンセです。そのシンセを`:d`の音で開始し、スライサーとリバーブに渡すようにしてみましょう。"

#: A.07-bizet.md:115
#, no-wrap
msgid ""
"live_loop :habanera do\n"
"  use_synth :fm\n"
"  use_transpose -12\n"
"  play (ring :d, :r, :r, :a, :f5, :r, :a, :r).tick\n"
"  sleep 0.25\n"
"end\n"
"with_fx :reverb do\n"
"  live_loop :space_light do\n"
"    with_fx :slicer, phase: 0.25 do\n"
"      synth :blade, note: :d, release: 8, cutoff: 100, amp: 2\n"
"    end\n"
"    sleep 8\n"
"  end\n"
"end"
msgstr ""
"live_loop :habanera do\n"
"  use_synth :fm\n"
"  use_transpose -12\n"
"  play (ring :d, :r, :r, :a, :f5, :r, :a, :r).tick\n"
"  sleep 0.25\n"
"end\n"
"with_fx :reverb do\n"
"  live_loop :space_light do\n"
"    with_fx :slicer, phase: 0.25 do\n"
"      synth :blade, note: :d, release: 8, cutoff: 100, amp: 2\n"
"    end\n"
"    sleep 8\n"
"  end\n"
"end"

#: A.07-bizet.md:133
msgid ""
"Now, try the other notes in the bass line: `:a` and `:f5`. Remember, you don't"
" need to hit stop, just modify the code whilst the music is playing and hit ru"
"n again. Also, try different values for the slicer's `phase:` opt such as `0.5"
"`, `0.75` and `1`."
msgstr ""
"では、ベースラインの`:a`と`:f5`を他の音に変えてみてください。注意すべきは、`Stop`を叩く必要はないということです。音楽が演奏されている最中に、"
"だたコードを変更して`Run`を再度叩いてください。そして、スライサーの`phase:`オプションを、`0.5`や`0.75`や`1`といった異なる値にして"
"みてください。"

#: A.07-bizet.md:140
msgid ""
"Finally, let's combine all the ideas so far into a new remix of the Habanera. "
"You might notice that I've included another part of the bass line as a comment"
". Once you've typed it all into a fresh buffer hit Run to hear the composition"
". Now, without hitting stop, *uncomment* the second line by removing the `#` a"
"nd hit run again - how marvellous is that! Now, start mashing it around yourse"
"lf and have fun."
msgstr ""
"最後に全てのアイデアを組合せて、ハバネラの新しいリミックスを作ってみましょう。もう1つのベースラインがコメントアウトされていることに気が付いたかもしれません"
"。新しいBufferにこれらをタイプしたら、`Run`を叩いて曲を聞いてみてください。そして、`Stop`を叩かずに、2行目のベースラインを*コメントを解除"
"*して、`#`を削除し、`Run`を再度叩いてみてください。なんと凄いのでしょう！ では、あなた自身でこのコードを弄って楽しんでください。"

#: A.07-bizet.md:147
#, no-wrap
msgid ""
"use_debug false\n"
"bizet_bass = (ring :d, :r, :r, :a, :f5, :r, :a, :r)\n"
"#bizet_bass = (ring :d, :r, :r, :Bb, :g5, :r, :Bb, :r)\n"
" \n"
"with_fx :reverb, room: 1, mix: 0.3 do\n"
"  live_loop :bizet do\n"
"    with_fx :slicer, phase: 0.125 do\n"
"      synth :blade, note: :d4, release: 8,\n"
"        cutoff: 100, amp: 1.5\n"
"    end\n"
"    16.times do\n"
"      tick\n"
"      play bizet_bass.look, release: 0.1\n"
"      play bizet_bass.look - 12, release: 0.3\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end\n"
" \n"
"live_loop :ind do\n"
"  sample :loop_industrial, beat_stretch: 1,\n"
"    cutoff: 100, rate: 1\n"
"  sleep 1\n"
"end\n"
" \n"
"live_loop :drums do\n"
"  sample :bd_haus, cutoff: 110\n"
"  synth :beep, note: 49, attack: 0,\n"
"    release: 0.1\n"
"  sleep 0.5\n"
"end"
msgstr ""
"use_debug false\n"
"bizet_bass = (ring :d, :r, :r, :a, :f5, :r, :a, :r)\n"
"#bizet_bass = (ring :d, :r, :r, :Bb, :g5, :r, :Bb, :r)\n"
" \n"
"with_fx :reverb, room: 1, mix: 0.3 do\n"
"  live_loop :bizet do\n"
"    with_fx :slicer, phase: 0.125 do\n"
"      synth :blade, note: :d4, release: 8,\n"
"        cutoff: 100, amp: 1.5\n"
"    end\n"
"    16.times do\n"
"      tick\n"
"      play bizet_bass.look, release: 0.1\n"
"      play bizet_bass.look - 12, release: 0.3\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end\n"
" \n"
"live_loop :ind do\n"
"  sample :loop_industrial, beat_stretch: 1,\n"
"    cutoff: 100, rate: 1\n"
"  sleep 1\n"
"end\n"
" \n"
"live_loop :drums do\n"
"  sample :bd_haus, cutoff: 110\n"
"  synth :beep, note: 49, attack: 0,\n"
"    release: 0.1\n"
"  sleep 0.5\n"
"end"

#: A.08-minecraft-vj.md:1
msgid "A.8 Become a Minecraft VJ"
msgstr "A.8 Minecraft VJになる"

#: A.08-minecraft-vj.md:3
msgid "Become a Minecraft VJ"
msgstr "Minecraft VJになる"

#: A.08-minecraft-vj.md:5
#, fuzzy
msgid ""
"![Screen 0](../../../etc/doc/images/tutorial/articles/A.08-minecraft-vj/minecr"
"aft-vj-0-small.png)"
msgstr ""
"![Screen 0](../../../etc/doc/images/tutorial/articles/A.08-minecraft-vj/minecr"
"aft-vj-0-small.png)"

#: A.08-minecraft-vj.md:7
msgid ""
"Everyone has played Minecraft. You will all have built amazing structures, des"
"igned cunning traps and even created elaborate cart lines controlled by redsto"
"ne switches. How many of you have performed with Minecraft? We bet you didn't "
"know that you could use Minecraft to create amazing visuals just like a profes"
"sional VJ."
msgstr ""
"みなさんはMinecraftで遊んだことがあると思います。そして、凄い構造物を建てたり、巧妙なトラップを設計したり、レッドストーンのスイッチで制御された精巧"
"なトロッコの路線を作ったりしたことがあるかもしれません。しかし、Minecraftでパフォーマンスをしたことがある人はどのくらい居るでしょうか？ Minec"
"raftを使ってまさにプロフェッショナルなVJのように凄いビジュアルを作れることを知っている人は少ないと思います。"

#: A.08-minecraft-vj.md:13
msgid ""
"If your only way of modifying Minecraft was with the mouse, you'd have a tough"
" time changing things fast enough. Luckily for you your Raspberry Pi comes wit"
"h a version of Minecraft that can be controlled with code. It also comes with "
"an app called Sonic Pi which makes coding Minecraft not only easy but also inc"
"redibly fun."
msgstr ""
"あなたにとって、Minecraftを操作する唯一の方法がマウスだったら、十分に速くそれを実行できるようになるまで苦労するに違いありません。幸運にも、あなたの"
"持っているRaspberry Piには、コードで制御可能なMinecraftが搭載されています。そして、Raspberry Piには、Sonic Piという"
"アプリケーションも搭載されていて、ただ簡単なだけでなく、信じられないほど楽しくMinecraftをコーディングすることが可能です。"

#: A.08-minecraft-vj.md:19
msgid ""
"In today's article we'll be showing you some of the tips and tricks that we've"
" used to create performances in night clubs and music venues around the world."
msgstr "今回の記事では、我々が世界中のクラブやホールでパフォーマンスしたヒントとコツをお教えしたいと思います。"

#: A.08-minecraft-vj.md:23
msgid "Let's get started..."
msgstr "では始めましょう…"

#: A.08-minecraft-vj.md:25
msgid "Getting Started"
msgstr "入門"

#: A.08-minecraft-vj.md:27
msgid ""
"Let's start with a simple warm up exercise to refresh ourselves with the basic"
"s. First up, crack open your Raspberry Pi and then fire up both Minecraft and "
"Sonic Pi. In Minecraft, create a new world, and in Sonic Pi choose a fresh buf"
"fer and write in this code:"
msgstr ""
"基本を習得するために、ウォームアップの練習から始めましょう。最初にRaspberry Piを起動し、続いてMinecraftとSonic Piの両方を起動し"
"てください。Minecraftでは、新しいワールドを作成し、Sonic Piでは新しいBufferを選択して、以下のコードを書いてください。"

#: A.08-minecraft-vj.md:32
#, no-wrap
msgid "mc_message \"Let's get started...\""
msgstr "mc_message \"Let's get started...\""

#: A.08-minecraft-vj.md:36
msgid ""
"Hit the Run button and you'll see the message over in the Minecraft window. OK"
", we're ready to start, let's have some fun......"
msgstr "`Run`ボタンを叩いて、Minecraftのウィンドウ内にメッセージを見ることができたでしょう。大丈夫ですね。では準備ができました。楽しんでください……"

#: A.08-minecraft-vj.md:39
msgid "Sand Storms"
msgstr "砂嵐"

#: A.08-minecraft-vj.md:41
msgid ""
"When we're using Minecraft to create visuals we try and think about what will "
"both look interesting and also be easy to generate from code. One nice trick i"
"s to create a sand storm by dropping sand blocks from the sky. For that all we"
" need are a few basic fns:"
msgstr ""
"Minecraftを使ってビジュアルを生成する際に、どのようなものが見た目が面白そうで、またコードから生成するのに簡単なのか試行錯誤しました。良さそうなテク"
"ニックの1つは、砂のブロックを空から落として砂嵐を作るというものです。これを実現するのに必要なものは、以下の基本的な関数です。"

#: A.08-minecraft-vj.md:46
msgid "`sleep` - for inserting a delay between actions"
msgstr "`sleep` - アクションの間の遅延を挿入するのに使います"

#: A.08-minecraft-vj.md:47
msgid "`mc_location` - to find our current location"
msgstr "`mc_location` - 現在の位置を取得するのに使います"

#: A.08-minecraft-vj.md:48
msgid "`mc_set_block`- to place sand blocks at a specific location"
msgstr "`mc_set_block`- 砂のブロックを指定した位置に設置するのに使います"

#: A.08-minecraft-vj.md:49
msgid "`rrand` - to allow us to generate random values within a range"
msgstr "`rrand` - ある範囲の乱数を生成するのに使います"

#: A.08-minecraft-vj.md:50
msgid "`live_loop` - to allow us to continually make it rain sand"
msgstr "`live_loop` - 砂嵐が起こったままにするのに使います"

#: A.08-minecraft-vj.md:52
msgid ""
"If you're unfamiliar with any of the built-in fns such as `rrand`, just type t"
"he word into your buffer, click on it and then hit the keyboard combo `Control"
"-i` to bring up the built-in documentation. Alternatively you can navigate to "
"the *lang* tab in the Help system and then look up the fns directly along with"
" all the other exciting things you can do."
msgstr ""
"もしあなたが`rrand`といったSonic Piが内蔵する関数に親しくなかったら、その関数名をBufferにタイプし、クリックして選択した後、`Contr"
"ol-i`のキーの組合せを叩いて、内蔵のドキュメントを開いてみてください。あるいは、ヘルプシステムの*命令*タブを開いて、他にも面白そうな項目がある中から、"
"対象の関数名を直接探すこともできます。"

#: A.08-minecraft-vj.md:58
msgid ""
"Let's make it rain a little first before unleashing the full power of the stor"
"m. Grab your current location and use it to create a few sand blocks up in the"
" sky nearby:"
msgstr "砂嵐のフルパワーを開放する前に少し砂を降らせてみましょう。現在の位置を取得し、近くの空中にいくつか砂のブロックを作ってください。"

#: A.08-minecraft-vj.md:62
#, no-wrap
msgid ""
"x, y, z = mc_location\n"
"mc_set_block :sand, x, y + 20, z + 5\n"
"sleep 2\n"
"mc_set_block :sand, x, y + 20, z + 6\n"
"sleep 2\n"
"mc_set_block :sand, x, y + 20, z + 7\n"
"sleep 2\n"
"mc_set_block :sand, x, y + 20, z + 8"
msgstr ""
"x, y, z = mc_location\n"
"mc_set_block :sand, x, y + 20, z + 5\n"
"sleep 2\n"
"mc_set_block :sand, x, y + 20, z + 6\n"
"sleep 2\n"
"mc_set_block :sand, x, y + 20, z + 7\n"
"sleep 2\n"
"mc_set_block :sand, x, y + 20, z + 8"

#: A.08-minecraft-vj.md:73
msgid ""
"When you hit Run, you might have to look around a little as the blocks may sta"
"rt falling down behind you depending on which direction you're currently facin"
"g. Don't worry, if you missed them just hit Run again for another batch of san"
"d rain - just make sure you're looking the right way!"
msgstr ""
"`Run`を叩いたとき、辺りを見回す必要があるかもしれません。プレイヤーがどの方向を向いているかにもよりますが、プレイヤーの後ろに砂が降っているかもしれませ"
"ん。でも心配しないでください。砂が降るのを見逃したとしても、`Run`をもう一度叩いて砂を降らせて、プレイヤーが正しい方向を向くようにすればよいのです！"

#: A.08-minecraft-vj.md:79
msgid ""
"Let's quickly review what's going on here. On the first line we grabbed Steve'"
"s location as coordinates with the fn `mc_location` and placed them into the v"
"ars `x`, `y`, and `z`. Then on the next lines we used the `mc_set_block` fn to"
" place some sand at the same coordinates as Steve but with some modifications."
" We chose the same x coordinate, a y coordinate 20 blocks higher and then succ"
"essively larger z coordinates so the sand dropped in a line away from Steve."
msgstr ""
"では上のコードで何が起きているか手短に見ていきましょう。1行目では、`mc_location`関数を使って、プレイヤーの位置を座標として取得し、`x`, `"
"y`, `z`に設定しています。次の数行では、`mc_set_block`関数を使って、プレイヤーの座標から少し変更を加えたところに砂を置いています。x座標"
"は同じで、y座標は20ブロック高く、z座標は順に大きくして、プレイヤーからまっすぐ離れるように砂を落としています。"

#: A.08-minecraft-vj.md:87
msgid ""
"Why don't you take that code and start playing around with it yourself? Try ad"
"ding more lines, changing the sleep times, try mixing `:sand` with `:gravel` a"
"nd choose different coordinates. Just experiment and have fun!"
msgstr ""
"このコードであなた自身で遊んでみてはどうでしょう。コードを追加したり、sleepの時間を変更したり、:sand`と`:gravel`を組合せたり、違う座標を"
"選んでみたりしましょう。色々実験して楽しんでみてください！"

#: A.08-minecraft-vj.md:91
msgid "Live Loops Unleashed"
msgstr "ライブループ解放"

#: A.08-minecraft-vj.md:93
msgid ""
"OK, it's time to get the storm raging by unleashing the full power of the `liv"
"e_loop` - Sonic Pi's magical ability which unleashes the full power of live co"
"ding - changing code on-the-fly whilst it's running!"
msgstr ""
"では、`live_loop`のフルパワーを解放して、嵐を激しくする時が来ました。`live_loop`はライブコーディングのフルパワーを開放するSonic "
"Piの特別な機能で、コードを実行したまま変更できてしまうのです！"

#: A.08-minecraft-vj.md:97
#, no-wrap
msgid ""
"live_loop :sand_storm do\n"
"  x, y, z = mc_location\n"
"  xd = rrand(-10, 10)\n"
"  zd = rrand(-10, 10)\n"
"  co = rrand(70, 130)\n"
"  synth :cnoise, attack: 0, release: 0.125, cutoff: co\n"
"  mc_set_block :sand, x + xd, y+20, z+zd\n"
"  sleep 0.125\n"
"end"
msgstr ""
"live_loop :sand_storm do\n"
"  x, y, z = mc_location\n"
"  xd = rrand(-10, 10)\n"
"  zd = rrand(-10, 10)\n"
"  co = rrand(70, 130)\n"
"  synth :cnoise, attack: 0, release: 0.125, cutoff: co\n"
"  mc_set_block :sand, x + xd, y+20, z+zd\n"
"  sleep 0.125\n"
"end"

#: A.08-minecraft-vj.md:109
msgid ""
"What fun! We're looping round pretty quickly (8 times a second) and during eac"
"h loop we're finding Steve's location like before but then generating 3 random"
" values:"
msgstr ""
"なんと楽しいのでしょう！ このコードは、とても速く（毎秒8回）ループしていて、それぞれのループではプレイヤーの位置を前と同じように取得していますが、次の3つ"
"のランダムな値を生成しています。"

#: A.08-minecraft-vj.md:113
msgid "`xd` - the difference for x which will be between -10 and 10"
msgstr "`xd` - x座標の差で、-10と10の間の値を取ります"

#: A.08-minecraft-vj.md:114
msgid "`zd` - the difference for z also between -10 and 10"
msgstr "`zd` - z座標の差で、同じく-10と10の間の値を取ります"

#: A.08-minecraft-vj.md:115
msgid "`co` - a cutoff value for the low pass filter between 70 and 130"
msgstr "`co` - ローパスフィルタのカットオフの値で、70と130の間の値を取ります"

#: A.08-minecraft-vj.md:117
msgid ""
"We then use those random values in the fns `synth` and `mc_set_block` giving u"
"s sand falling in random locations around Steve along with a percussive rain-l"
"ike sound from the `:cnoise` synth."
msgstr ""
"そしてこれらのランダムな値を`synth`と`mc_set_block`関数で使用して、砂をプレイヤーの周りのランダムな位置に落とし、それに合わせて`:cn"
"oise`シンセでパーカッシブな雨のような音を鳴らしています。"

#: A.08-minecraft-vj.md:121
msgid ""
"For those of you new to live loops - this is where the fun really starts with "
"Sonic Pi. Whilst the code is running and the sand is pouring down, try changin"
"g one of the values, perhaps the sleep time to `0.25` or the `:sand` block typ"
"e to `:gravel`. Now hit run *again*. Hey Presto! Things changed without the co"
"de stopping. This is your gateway to performing like a real VJ. Keep practisin"
"g and changing things around. How different can you make the visuals without s"
"topping the code?"
msgstr ""
"ライブループに慣れていない人にお話すると、ここからがSonic Piで本当に面白くなるところです。コードが実行されていて砂が吹き出している最中に、コード内の"
"どれかの値、たとえばsleepの時間を`0.25`に変えたり、ブロックタイプを`:sand`から`:gravel`に変えてみてみましょう。そして`Run`を"
"*もう一度*叩いてみてください。あら不思議！ コードが止まらずに変更されました。これが、本物のVJと同じようにパフォーマンスする入り口です。練習してコードを"
"変更し続けてください。あなたはコードを止めずにどれだけビジュアルを変えることができるかな？"

#: A.08-minecraft-vj.md:129
msgid "Epic Block Patterns"
msgstr "壮大なブロックのパターン"

#: A.08-minecraft-vj.md:131
#, fuzzy
msgid ""
"![Screensman 1](../../../etc/doc/images/tutorial/articles/A.08-minecraft-vj/mi"
"necraft-vj-1-small.png)"
msgstr ""
"![Screen 1](../../../etc/doc/images/tutorial/articles/A.08-minecraft-vj/minecr"
"aft-vj-1-small.png)"

#: A.08-minecraft-vj.md:133
msgid ""
"Finally, another great way of generating interesting visuals is to generate hu"
"ge patterned walls to fly towards and close by. For this effect we'll need to "
"move from placing the blocks randomly to placing them in an ordered manner. We"
" can do this by nesting two sets of iteration (hit the Help button and navigat"
"e to section 5.2 of the tutorial \"Iteration and Loops\" for more background on "
"iteration). The funny `|xd|` after the do means that `xd` will be set for each"
" value of the iteration. So the first time it will be 0, then 1, then 2... etc"
". By nesting two lots of iteration together like this we can generate all the "
"coordinates for a square. We can then randomly choose block types from a ring "
"of blocks for an interesting effect:"
msgstr ""
"最後に、興味深いビジュアルを生成するためのもう1つの素晴らしい方法は、巨大な模様付きの壁を生成して、そこを行き来することです。この効果のためには、ブロックを"
"ランダムに配置することから、規則的に配置することに移る必要があります。これを行うには、2つのイテレーション（反復）を入れ子にします（イテレーションの詳細につ"
"いては、ヘルプボタンをクリックして、チュートリアルのセクション5.2\"イテレーション（反復）とループ\"に移動してください）。doの後の面白い `| xd |"
"`は、イテレーションの各値に対して`xd`が設定されることを意味します。 したがって、最初は0, 1, 2…などとなります。このように2回のイテレーションを"
"入れ子にすることで、すべての座標を正方形に生成することができます。また、ブロックのリングからブロックタイプをランダムに選択して、興味深い効果を得ることもでき"
"ます。"

#: A.08-minecraft-vj.md:145
#, no-wrap
msgid ""
"x, y, z = mc_location\n"
"bs = (ring :gold, :diamond, :glass)\n"
"10.times do |xd|\n"
"  10.times do |yd|\n"
"    mc_set_block bs.choose, x + xd, y + yd, z\n"
"  end\n"
"end"
msgstr ""
"x, y, z = mc_location\n"
"bs = (ring :gold, :diamond, :glass)\n"
"10.times do |xd|\n"
"  10.times do |yd|\n"
"    mc_set_block bs.choose, x + xd, y + yd, z\n"
"  end\n"
"end"

#: A.08-minecraft-vj.md:155
msgid ""
"Pretty neat. Whilst we're having fun here, try changing `bs.choose` to `bs.tic"
"k` to move from a random pattern to a more regular one. Try changing the block"
" types and the more adventurous of you might want to try sticking this within "
"a `live_loop` so that the patterns keep changing automatically."
msgstr ""
"かなりかっこいいね。このコードで楽しんでいる最中に、`bs.choose`を`bs.tick`に変更して、ランダムなパターンからより規則的なものにしてみまし"
"ょう。ブロックタイプの変更やより冒険的な変更は、`live_loop`の中でやってみましょう。そうすればパターンは自動的に変更し続けるでしょう。"

#: A.08-minecraft-vj.md:161
#, fuzzy
msgid ""
"Now, for the VJ finale - change the two `10.times` to `100.times` and hit Run."
" Kaboom! A Huge gigantic wall of randomly placed bricks. Imagine how long it w"
"ould take you to build that manually with your mouse! Double-tap space to ente"
"r fly-mode and start swooping by for some great visual effects. Don't stop her"
"e though - use your imagination to conjure up some cool ideas and then use the"
" coding power of Sonic Pi to make it real. When you've practised enough dim th"
"e lights and put on a VJ show for your friends!"
msgstr ""
"では、VJの最後に2つの`10.times`を`100.times`に変更して`Run`を叩いてみましょう。Kaboom! ランダムに配置されたレンガの巨大"
"な巨大な壁。あなたがマウスで手動で構築するのにどれくらいの時間がかかるか想像してみてください！ スペースをダブルタップして飛行モードに入り、素晴らしいビジュ"
"アルエフェクトを得るために降下してみましょう。しかしここで止まらないでください。あなたの想像力を使ってクールなアイデアを思いついたら、Sonic Piのコー"
"ディングの力でそれを形にしましょう。十分に練習したら、明かりを暗くし、友達のためにVJショーを始めましょう！"

#: A.09-randomisation.md:1
msgid "A.9 Randomisation"
msgstr "A.9 ランダム化"

#: A.09-randomisation.md:3
msgid "Surfing Random Streams"
msgstr "ランダムストリームに乗る"

#: A.09-randomisation.md:5
msgid ""
"Back in episode 4 of this tutorial series we took a brief look at randomisatio"
"n whilst coding up some sizzling synth riffs. Given that randomisation is such"
" an important part of my live coding DJ sets I thought it would be useful to c"
"over the fundamentals in much greater detail. So, get your lucky hat on and le"
"t's surf some random streams!"
msgstr ""
"このチュートリアルの第4話では、いくつかのシンセ・リフをコーディングしながら、ランダム化を簡単に見ました。ランダム化は私のライブコーディングDJセットの重要"
"な部分であることを考えると、その基礎をより詳細に取り上げることが有用であると考えました。では、幸運の帽子を被って、ランダムストリームをサーフィンしましょう！"

#: A.09-randomisation.md:11
msgid "There is no random"
msgstr "ランダムは存在しない"

#: A.09-randomisation.md:13
msgid ""
"The first thing to learn which might really surprise you when playing with Son"
"ic Pi's randomisation functions is that they're not actually really random. Wh"
"at does this actually mean? Well, let's try a couple of tests. First, imagine "
"a number in your head between 0 and 1. Keep it there and don't tell me. Now le"
"t me guess... was it `0.321567`? No? Bah, I'm clearly no good at this. Let me "
"have another go, but let's ask Sonic Pi to choose a number this time. Fire up "
"Sonic Pi v2.7+ and ask it for a random number but again don't tell me:"
msgstr ""
"これはあなたを本当に驚かせるかもしれませんが、Sonic Piのランダム化関数で遊ぶときに最初に学ぶことは、これらの関数が実際にはランダムではないということ"
"です。これは実際にはどのような意味でしょう？ では、いくつかのテストを試してみましょう。まず、0と1の間の数字をあなたの頭の中で想像してください。そのまま私"
"に教えないでください。私が当ててみましょう…それは`0.321567`ですか？ 違いましたか？ ブー、当然ながら私はこれを上手く当てることができません。では"
"もう一度やりましょう。今度はSonic Piに番号を選んでもらいましょう。v2.7以降のSonic Piを起動して、乱数を要求してみてください。そして先程と"
"同じように私には教えないでください："

#: A.09-randomisation.md:22
#, no-wrap
msgid "print rand"
msgstr "print rand"

#: A.09-randomisation.md:26
msgid ""
"Now for the reveal... was it `0.75006103515625`? Yes! Ha, I can see you're a l"
"ittle sceptical. Perhaps it was just a lucky guess. Let's try again. Press the"
" Run button again and see what we get... What? `0.75006103515625` again? This "
"clearly can't be random! You're right, it's not."
msgstr ""
"では当ててみましょう… それは`0.75006103515625`ですか？ 合ってましたか！ でも、あなたが少し疑っているのが分かります。それは多分ただのま"
"ぐれ当たりでしょう。もう1度やってみましょう。もう1度実行ボタンを押して、出たものを見て… 何？ `0.75006103515625`？ これは明らかにラン"
"ダムではありません！ あなたは正しい、ランダムではないですね。"

#: A.09-randomisation.md:32
msgid ""
"What's going on here? The fancy computer science word here is determinism. Thi"
"s just means that nothing is by chance and everything is destined to be. Your "
"version of Sonic Pi is destined to always return `0.75006103515625` in the pro"
"gram above. This might sound pretty useless, but let me assure you that it's o"
"ne of the most powerful parts of Sonic Pi. If you stick at it you'll learn how"
" to rely on the deterministic nature of Sonic Pi's randomisation as a fundamen"
"tal building block for your compositions and live coded DJ sets."
msgstr ""
"ここでは何が起きてるでしょうか？ ここで登場するコンピュータ科学の用語は決定論です。これは、偶然によるものは何も無く、すべてが運命づけられていることを意味し"
"ます。あなたのバージョンのSonic Piは、上記のプログラムで常に `0.75006103515625`を返すようになっています。これはかなり役に立たない"
"かもしれませんが、Sonic Piの最も強力な部分の1つであることを断言させてください。もしあなたがそれを追求すれば、作曲やライブコーディングDJセットの基"
"本的なビルディング・ブロックとして、Sonic Piのランダム化の決定論的な性質に依存する方法を学ぶことになるでしょう。"

#: A.09-randomisation.md:41
msgid "A Random Melody"
msgstr "ランダムメロディ"

#: A.09-randomisation.md:43
msgid ""
"When Sonic Pi boots it actually loads into memory a sequence of 441,000 pre-ge"
"nerated random values. When you call a random function such as `rand` or `rran"
"d`, this random stream is used to generate your result. Each call to a random "
"function consumes a value from this stream. Therefore the 10th call to a rando"
"m function will use the 10th value from the stream. Also, every time you press"
" the Run button, the stream is reset for that run. This is why I could predict"
" the result to `rand` and why the 'random' melody was the same every time. Eve"
"rybody's version of Sonic Pi uses the exact same random stream which is very i"
"mportant when we start sharing our pieces with each other."
msgstr ""
"Sonic Piが起動すると、441,000の事前に生成された乱数のシーケンスが実際にメモリにロードされます。`rand`や` rrand`のようなランダム"
"関数を呼び出すと、このランダムストリームが関数の結果を生成するために使われます。ランダム関数の呼び出しする度に、このストリームから値を消費します。したがって"
"、ランダム関数への10回目の呼び出しはストリームからの10番目の値を使用します。また、Runボタンを押すたびに、その実行のためにストリームがリセットされます"
"。これが、私が`rand`の結果を予測できたり、'random'なメロディーがいつも同じである理由です。皆さんのSonic Piは、まったく同じランダムスト"
"リームを使用しています。これは、私たちの作品をお互いに共有するときに非常に重要です。"

#: A.09-randomisation.md:54
msgid "Let's use this knowledge to generate a repeatable random melody:"
msgstr "繰り返し可能なランダムメロディを作るために、この知識を使ってみましょう。"

#: A.09-randomisation.md:56
#, no-wrap
msgid ""
"8.times do\n"
" play rrand_i(50, 95)\n"
" sleep 0.125\n"
"end"
msgstr ""
"8.times do\n"
" play rrand_i(50, 95)\n"
" sleep 0.125\n"
"end"

#: A.09-randomisation.md:63
msgid ""
"Type this into a spare buffer and hit Run. You'll hear a melody consisting of "
"'random' notes between 50 and 95. When it's finished, hit Run again to hear ex"
"actly the same melody again."
msgstr ""
"これを空いたBufferに入力して`Run`を叩いてください。50から95の'ランダムな'音符で構成されるメロディーを聞くことができるでしょう。メロディーが"
"終わったら、もう一度`Run`を叩いてみてください。先ほどと全く同じメロディーを聞くことができるでしょう。"

#: A.09-randomisation.md:67
msgid "Handy Randomisation Functions"
msgstr "便利なランダム化関数"

#: A.09-randomisation.md:69
msgid ""
"Sonic Pi comes with a number of useful functions for working with the random s"
"tream. Here's a list of some of the most useful:"
msgstr "Sonic Piにはランダムストリームを扱う便利な関数がたくさんあります。その中でも有用な関数のリストです。"

#: A.09-randomisation.md:72
msgid "`rand` - Simply returns the next value in the random stream"
msgstr "`rand` - ランダムストリームの次の値を返します"

#: A.09-randomisation.md:73
msgid "`rrand` - Returns a random value within a range"
msgstr "`rrand` - 範囲内のランダムな値を返します"

#: A.09-randomisation.md:74
msgid "`rrand_i` - Returns a random whole number within a range"
msgstr "`rrand_i` - 範囲内のランダムな整数を返します"

#: A.09-randomisation.md:75
msgid "`one_in` - Returns true or false with the given probability"
msgstr "`one_in` - 与えられた確率でtrueまたはfalseを返します"

#: A.09-randomisation.md:76
msgid "`dice` - Imitates rolling a dice and returns a value between 1 and 6"
msgstr "`dice` - サイコロを転がして、1から6までの値をランダムで返します"

#: A.09-randomisation.md:77
msgid "`choose` - Chooses a random value from a list"
msgstr "`choose` - リストからランダムに値を1つ選択します"

#: A.09-randomisation.md:79
msgid ""
"Check out their documentation in the Help system for detailed information and "
"examples."
msgstr "詳細情報や例については、ヘルプにあるそれぞれの関数のドキュメントを参照してください。"

#: A.09-randomisation.md:82
msgid "Resetting the Stream"
msgstr "ランダムストリームのリセット"

#: A.09-randomisation.md:84
msgid ""
"Whilst the ability to repeat a sequence of chosen notes is essential to allow "
"you to replay a riff on the dance floor, it might not be exactly the riff you "
"want. Wouldn't it be great if we could try a number of different riffs and cho"
"ose the one we liked best? This is where the real magic starts."
msgstr ""
"選択した音符のシーケンスを繰り返す機能は、リフをダンスフロアで再現するためには不可欠ですが、あなたが望んだリフではないかもしれません。もし、いくつかの異なる"
"リフを試して、一番好きなリフを選ぶことができれば、素晴らしいことではないでしょうか？ これが本当のマジックの始まりです。"

#: A.09-randomisation.md:90
msgid ""
"We can manually set the stream with the fn `use_random_seed`. In Computer Scie"
"nce, a random seed is the starting point from which a new stream of random val"
"ues can sprout out and blossom. Let's try it:"
msgstr ""
"ランダムストリームを`use_random_seed`関数で手動で設定することができます。コンピュータサイエンスでは、ランダムシードとは、ランダムな値の新し"
"いストリームが芽吹き、開花する出発点です。試してみましょう："

#: A.09-randomisation.md:94
#, no-wrap
msgid ""
"use_random_seed 0\n"
"3.times do\n"
"  play rrand_i(50, 95)\n"
"  sleep 0.125\n"
"end"
msgstr ""
"use_random_seed 0\n"
"3.times do\n"
"  play rrand_i(50, 95)\n"
"  sleep 0.125\n"
"end"

#: A.09-randomisation.md:102
msgid ""
"Great, we get the first three notes of our random melody above: `84`, `83` and"
" `71`. However, we can now change the seed to something else. How about this:"
msgstr ""
"いいね。上のコードのランダムメロディーの先頭から`84`, `83`, `71`の3つの音符が得られました。ここで、シードを別な値に変更できます。これはどう"
"でしょう："

#: A.09-randomisation.md:106
#, no-wrap
msgid ""
"use_random_seed 1\n"
"3.times do\n"
"  play rrand_i(50, 95)\n"
"  sleep 0.125\n"
"end"
msgstr ""
"use_random_seed 1\n"
"3.times do\n"
"  play rrand_i(50, 95)\n"
"  sleep 0.125\n"
"end"

#: A.09-randomisation.md:114
msgid ""
"Interesting, we get `83`, `71` and `61` . You might notice that the first two "
"numbers here are the same as the last two numbers before - this isn't a coinci"
"dence."
msgstr ""
"興味深いことに、ここで`83`, ` 71`, `61`を取得します。ここの最初の2つの数字は、先程の後ろ2つの数字と同じです - これは偶然ではありません"
"。"

#: A.09-randomisation.md:118
msgid ""
"Remember that the random stream is just a giant list of 'pre-rolled' values. U"
"sing a random seed simply jumps us to a point in that list. Another way of thi"
"nking about it is to imagine a huge deck of pre-shuffled cards. Using a random"
" seed is cutting the deck at a particular point. The fabulous part of this is "
"that it's precisely this ability to jump around the random stream which gives "
"us huge power when making music."
msgstr ""
"ランダムストリームは「あらかじめ準備された」値の巨大なリストに過ぎないことを思い出してください。ランダムシードの使用は、そのリスト内の特定の位置に単にジャン"
"プするだけです。それについて考えるもう1つの方法は、あらかじめシャッフルされたトランプカードの巨大なデッキを想像することです。ランダムシードを使用することは"
"、デッキの特定の位置でカードを分けることです。このことの素晴らしい点の1つは、ランダムストリームを行ったり来たりするこの機能こそ、音楽を作るときに私たちに大"
"きな力を与えるということです。"

#: A.09-randomisation.md:126
msgid ""
"Let's revisit our random melody of 8 notes with this new stream resetting powe"
"r, but let's also throw in a live loop so we can experiment live whilst it's p"
"laying:"
msgstr ""
"ランダムメロディーに戻りましょう。今度は新しいランダムストリームのリセットで得られた8つの音符だけでなく、ライブループに入れて演奏中に実験できるようにしてい"
"ます："

#: A.09-randomisation.md:130
#, no-wrap
msgid ""
"live_loop :random_riff do    \n"
"  use_random_seed 0\n"
"  8.times do\n"
"    play rrand_i(50, 95), release: 0.1\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"live_loop :random_riff do    \n"
"  use_random_seed 0\n"
"  8.times do\n"
"    play rrand_i(50, 95), release: 0.1\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: A.09-randomisation.md:140
msgid ""
"Now, whilst it's still playing, change the seed value from `0` to something el"
"se. Try `100`, what about `999`. Try your own values, experiment and play arou"
"nd - see which seed generates the riff you like best."
msgstr ""
"では、上のコードが動いている間に、シードの値を`0`から別な何かに変えてみましょう。`100`、`999`はどうでしょう。それからあなたの好きな値を試して、"
"実験して遊んでみましょう。そして、どのシードが一番好きなリフを生成するか見てみましょう。"

#: A.09-randomisation.md:147
msgid ""
"This month's tutorial has been quite a technical dive into the workings of Son"
"ic Pi's randomisation functionality. Hopefully it has given you some insight i"
"nto how it works and how you can start using randomisation in a reliable way t"
"o create repeatable patterns within your music. It's important to stress that "
"you can use repeatable randomisation *anywhere* you want. For example, you can"
" randomise the amplitude of notes, the timing of the rhythm, the amount of rev"
"erb, the current synth, the mix of an FX, etc. etc. In the future we'll take a"
" close look at some of these applications, but for now let me leave you with a"
" short example."
msgstr ""
"今月のチュートリアルでは、Sonic Piのランダム化機能の動作を技術的に詳しく説明しました。信頼性の高い方法でランダム化を使用して音楽内で繰り返し可能なパ"
"ターンを作成する方法と、それがどのように動作するのかについて、何らかの示唆を与えられたことを願っています。そして、繰り返し可能なランダム化を*どこでも*使用"
"できることを強調しておきます。例えば、音符の音量、リズムのタイミング、リバーブの量、現在のシンセ、エフェクトの掛かり具合などをランダム化することができます。"
"これらについて、将来いくつかの応用を詳しく見たいですが、ここでは簡単な例を挙げておきます。"

#: A.09-randomisation.md:157
msgid ""
"Type the following into a spare buffer, hit Run, and then start changing the s"
"eeds around, hit Run again (whilst it's still playing) and explore the differe"
"nt sounds, rhythms and melodies you can make. When you find a nice one, rememb"
"er the seed number so you can get back to it. Finally, when you've found a few"
" seeds you like, put on a live coded performance for your friends by simply sw"
"itching between your favourite seeds to create a full piece."
msgstr ""
"空いたBufferに以下のように入力し、`Run`を叩いてみてください。そして、シードを変更してみて、（演奏された状態のまま）もう1度`Run`を叩いてみて"
"ください。それによって作り出されるさまざまなサウンド、リズム、メロディを探索してみてください。もし素敵なものを見つけたら、シードの数字を覚えておいてください"
"。最後に、あなたが好きなシードがいくつか見つかったら、お気に入りのシードを切り替えて曲にするだけで、ライブコーディングのパフォーマンスを提供できます。"

#: A.09-randomisation.md:165
#, no-wrap
msgid ""
"live_loop :random_riff do\n"
"  use_random_seed 10300\n"
"  use_synth :prophet\n"
"  s = [0.125, 0.25, 0.5].choose\n"
"  8.times do\n"
"    r = [0.125, 0.25, 1, 2].choose\n"
"    n = (scale :e3, :minor).choose\n"
"    co = rrand(30, 100)\n"
"    play n, release: r, cutoff: co\n"
"    sleep s\n"
"  end\n"
"end\n"
"live_loop :drums do\n"
"  use_random_seed 2001\n"
"  16.times do\n"
"    r = rrand(0.5, 10)\n"
"    sample :drum_bass_hard, rate: r, amp: rand\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"live_loop :random_riff do\n"
"  use_random_seed 10300\n"
"  use_synth :prophet\n"
"  s = [0.125, 0.25, 0.5].choose\n"
"  8.times do\n"
"    r = [0.125, 0.25, 1, 2].choose\n"
"    n = (scale :e3, :minor).choose\n"
"    co = rrand(30, 100)\n"
"    play n, release: r, cutoff: co\n"
"    sleep s\n"
"  end\n"
"end\n"
"live_loop :drums do\n"
"  use_random_seed 2001\n"
"  16.times do\n"
"    r = rrand(0.5, 10)\n"
"    sample :drum_bass_hard, rate: r, amp: rand\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: A.10-controlling-your-sound.md:1
msgid "A.10 Control"
msgstr "A.10 コントロール"

#: A.10-controlling-your-sound.md:3
msgid "Controlling Your Sound"
msgstr "音をコントロールする"

#: A.10-controlling-your-sound.md:5
msgid ""
"So far during this series we've focussed on triggering sounds. We've discovere"
"d that we can trigger the many synths built into Sonic Pi with `play` or `synt"
"h` and how to trigger pre-recorded samples with `sample`. We've also looked at"
" how we can wrap these triggered sounds within studio FX such as reverb and di"
"stortion using the `with_fx` command. Combine this with Sonic Pi's incredibly "
"accurate timing system and you can produce a vast array of sounds, beats and r"
"iffs. However, once you've carefully selected a particular sound's options and"
" triggered it, there's no ability to mess with it whilst it's playing right? W"
"rong! Today you're going to learn something very powerful - how to control run"
"ning synths."
msgstr ""
"ここまでで、このシリーズではサウンドをトリガーすることに焦点を当ててきました。我々は、`play`や`synth`でSonic Piに組み込まれた多くのシン"
"セサイザーを起動させることができ、`sample`であらかじめ録音されたサンプルをトリガーする方法を見てきました。また、トリガーされたサウンドを、`with"
"_fx`コマンドを使ってリバーブやディストーションなどのスタジオ・エフェクト内にどのようにラップできるかを見てきました。これをSonic Piの信じられない"
"ほど正確なタイミングシステムと組み合わせると、広大なサウンド、ビート、リフを生成することができます。しかし、特定のサウンドのオプションを慎重に選択してトリガ"
"ーすると、再生されている間にそのサウンドを変更することはできないでしょうか？ それができるのです！ 今日は、実行中のシンセをコントロールするとてもパワフルな"
"方法を学びます。"

#: A.10-controlling-your-sound.md:17
msgid "A Basic Sound"
msgstr "基本的なサウンド"

#: A.10-controlling-your-sound.md:19
msgid ""
"Let's create a nice simple sound. Fire up Sonic Pi and in a fresh buffer type "
"the following:"
msgstr "はじめに、良い感じの簡単な音を作ってみましょう。Sonic Piを起動し、新しいBufferに以下のコードを打ち込んでください："

#: A.10-controlling-your-sound.md:22
#, no-wrap
msgid "synth :prophet, note: :e1, release: 8, cutoff: 100"
msgstr "synth :prophet, note: :e1, release: 8, cutoff: 100"

#: A.10-controlling-your-sound.md:26
msgid ""
"Now press the Run button at the top left to hear a lovely rumbling synth sound"
". Go ahead, press it again a few times to get a feel for it. OK, done? Let's s"
"tart controlling it!"
msgstr ""
"では、左上にある`Run`ボタンを押して、素敵な響きのシンセサウンドを聞きましょう。続いて、`Run`ボタンを何度か押して、その音の感覚を掴みましょう。でき"
"ましたか？ では制御してみましょう！"

#: A.10-controlling-your-sound.md:30
msgid "Synth Nodes"
msgstr "シンセ・ノード"

#: A.10-controlling-your-sound.md:32
msgid ""
"A little known feature in Sonic Pi is that the fns `play`, `synth` and `sample"
"`, return something called a `SynthNode` which represents a running sound. You"
" can capture one of these `SynthNode`s using a standard variable and then **co"
"ntrol** it at a later point in time. For example, let's change the value of th"
"e `cutoff:` opt after 1 beat:"
msgstr ""
"`play`, `synth`, `sample`といった関数が、実行中のサウンドを表象する`SynthNode`と呼ばれるものを返却することは、Sonic"
" Piで少し知られている機能かもしれません。これらの`SynthNode`は標準的な変数に入れることができ、後で**制御**することができます。例えば、`c"
"utoff:`のオプションを1拍後に変更してみましょう。"

#: A.10-controlling-your-sound.md:38
#, no-wrap
msgid ""
"sn = synth :prophet, note: :e1, release: 8, cutoff: 100\n"
"sleep 1\n"
"control sn, cutoff: 130"
msgstr ""
"sn = synth :prophet, note: :e1, release: 8, cutoff: 100\n"
"sleep 1\n"
"control sn, cutoff: 130"

#: A.10-controlling-your-sound.md:44
msgid "Let's look at each line in turn:"
msgstr "各行を順番に見ていきましょう。"

#: A.10-controlling-your-sound.md:46
msgid ""
"Firstly we trigger the `:prophet` synth using the `synth` fn as normal. Howeve"
"r we also capture the result in a variable called `sn`. We could have called t"
"his variable something completely different such as `synth_node` or `jane` - t"
"he name doesn't matter. However, it's important to choose a name that's meanin"
"gful to you for your performances and for people reading your code. I chose `s"
"n` as it's a nice short mnemonic for synth node."
msgstr ""
"最初に、`:prophet`シンセを`synth`関数でいつものようにトリガーしています。しかし、その結果を`sn`という変数に入れています。この変数は`s"
"ynth_node`や`jane`といった何か全く異なるものでも構いません。しかし、何か意味のある名前を選ぶことがあなたのパフォーマンスや後でこのコードを読"
"む人々にとって重要でしょう。私は、シンセ・ノードのニーモニック（略名）が良かったので、`sn`を選びました。"

#: A.10-controlling-your-sound.md:54
msgid ""
"On line 2 we have a standard `sleep` command. This does nothing special - it j"
"ust asks the computer to wait for 1 beat before moving onto the next line."
msgstr "2行目では、標準的な`sleep`コマンドを呼んでいます。これは何も特別なことはありません。次の行に進む前に1拍待つようコンピュータに指示しているだけです。"

#: A.10-controlling-your-sound.md:58
msgid ""
"Line 3 is where the control fun starts. Here, we use the `control` fn to tell "
"our running `SynthNode` to change the cutoff value to `130`. If you hit the **"
"Run** button, you'll hear the `:prophet` synth start playing as before, but af"
"ter 1 beat it will shift to sound a lot brighter."
msgstr ""
"3行目はコントロールによって楽しくなるところです。ここでは、`control`関数を使って実行中の`SynthNode`にカットオフの値を`130`に変更す"
"るよう指示しています。**Run**ボタンを叩くと、`:prophet`シンセが前と同じように演奏され、1拍後にそのサウンドが明るくなるのを聞くことができる"
"でしょう。"

#: A.10-controlling-your-sound.md:63
msgid "Modulatable Options"
msgstr "調整可能なオプション"

#: A.10-controlling-your-sound.md:65
msgid ""
"Most of Sonic Pi's synths and FX opts may be changed after being triggered. Ho"
"wever, this isn't the case for all of them. For example, the envelope opts `at"
"tack:`, `decay:`, `sustain:` and `release:` can only be set when triggering th"
"e synth. Figuring out which opts can and can't be changed is simple - just hea"
"d to the documentation for a given synth or FX and then scroll down to the ind"
"ividual option documentation and look for the phrases \"May be changed whilst p"
"laying\" or \"Can not be changed once set\". For example, the documentation for t"
"he `:beep` synth's `attack:` opt makes it clear that it's not possible to chan"
"ge it:"
msgstr ""
"Sonic Piのシンセやエフェクトのオプションのほとんどは、トリガーされた後に変更できるかもしれません。しかし、これはすべてに当てはまるという訳ではないの"
"です。例えば、エンベロープのオプション `attack:`, `decay:`, `sustain:`と`release:`は、シンセをトリガーするときだけ"
"設定できます。オプションを変更できるどうかは簡単です。特定のシンセまたはエフェクトのドキュメントに進み、個々のオプションのドキュメントまでスクロールして、\""
"May be changed whilst playing\"（演奏中に変更可能です）か\"Can not be changed once set\"（一度設定さ"
"れると変更できません）というフレーズを探すだけです。例えば、`:beep`シンセの`attack:`オプションのドキュメントは、それを変更できないことを明確"
"にしています："

#: A.10-controlling-your-sound.md:76
msgid "Default: 0"
msgstr "Default: 0"

#: A.10-controlling-your-sound.md:77
msgid "Must be zero or greater"
msgstr "Must be zero or greater"

#: A.10-controlling-your-sound.md:78
msgid "Can not be changed once set"
msgstr "Can not be changed once set"

#: A.10-controlling-your-sound.md:79
msgid "Scaled with current BPM value"
msgstr "Scaled with current BPM value"

#: A.10-controlling-your-sound.md:81
msgid "Multiple Changes"
msgstr "複数の変更"

#: A.10-controlling-your-sound.md:83
msgid ""
"Whilst a synth is running you're not limited to changing it only once - you're"
" free to change it as many times as you like. For example, we can turn our `:p"
"rophet` into a mini arpeggiator with the following:"
msgstr ""
"シンセが動作している間は、一度だけ変更することに限らず、何度でも自由に変更することができます。例えば、次のように`:prophet`をミニ・アルペジエーター"
"にすることができます："

#: A.10-controlling-your-sound.md:87
#, no-wrap
msgid ""
"notes = (scale :e3, :minor_pentatonic)\n"
"sn = synth :prophet, note: :e1, release: 8, cutoff: 100\n"
"sleep 1\n"
"16.times do\n"
"  control sn, note: notes.tick\n"
"  sleep 0.125\n"
"end"
msgstr ""
"notes = (scale :e3, :minor_pentatonic)\n"
"sn = synth :prophet, note: :e1, release: 8, cutoff: 100\n"
"sleep 1\n"
"16.times do\n"
"  control sn, note: notes.tick\n"
"  sleep 0.125\n"
"end"

#: A.10-controlling-your-sound.md:97
msgid ""
"In this snippet of code we just added a couple of extra things. First we defin"
"ed a new variable called `notes` which contains the notes we'd like to cycle t"
"hrough (an arpeggiator is just a fancy name for something that cycles through "
"a list of notes in order). Secondly we replaced our single call to `control` w"
"ith an iteration calling it 16 times. In each call to `control` we `.tick` thr"
"ough our ring of `notes` which will automatically repeat once we get to the en"
"d (thanks to the fabulous power of Sonic Pi's rings). For a bit of variety try"
" replacing `.tick` with `.choose` and see if you can hear the difference."
msgstr ""
"このコードスニペットでは、いくつか余分なものを追加しました。最初に、`notes`という新しい変数を定義しました。この変数には、循環させたい音符が含まれてい"
"ます（アルペジエーターは音符のリストを順番に循環する何かに名前を付けたものです）。第二に、私たちは単一の呼び出しを`control`に置き換え、それを16回"
"呼び出す反復で置き換えました。`control`の呼び出しの度に、`notes`のリングを順に`.tick`していきます（Sonic Piのリングの素晴らし"
"いパワーのおかげで、リングは末尾に達すると先頭に戻ります）。ちょっとした変化として、`.tick`を`.choose`で置き換えて、その違いを聞くことができ"
"るかどうか確認してください。"

#: A.10-controlling-your-sound.md:107
msgid ""
"Note that we can change multiple opts simultaneously. Try changing the control"
" line to the following and listen for the difference:"
msgstr "複数のオプションを同時に変更することもできます。コントロールの行を次のように変更して、その違いを聞いてみてください："

#: A.10-controlling-your-sound.md:110
#, no-wrap
msgid "control sn, note: notes.tick, cutoff: rrand(70, 130)"
msgstr "control sn, note: notes.tick, cutoff: rrand(70, 130)"

#: A.10-controlling-your-sound.md:114
msgid "Sliding"
msgstr "スライド"

#: A.10-controlling-your-sound.md:116
msgid ""
"When we control a `SynthNode`, it responds exactly on time and instantly chang"
"es the value of the opt to the new one as if you'd pressed a button or flicked"
" a switch requesting the change. This can sound rhythmical and percussive - es"
"pecially if the opt controls an aspect of the timbre such as `cutoff:`. Howeve"
"r, sometimes you don't want the change to happen instantaneously. Instead, you"
" might want to smoothly move from the current value to the new one as if you'd"
" moved a slider or dial. Of course, Sonic Pi can also do this too using the `_"
"slide:` opts."
msgstr ""
"`SynthNode`をコントロールすると、正確に時間通りに応答し、ボタンを押したり、変更を要求するスイッチをフリックしたかのように、オプションの値を新しい"
"ものに即座に変更します。これは、特にオプションがの`cutoff:`ような音色の1つをコントロールしている場合に、リズミカルでパーカッシブに聞こえることがあ"
"ります。しかし、瞬間的に変更が発生することを望まないこともあります。その代わりに、スライダーやダイヤルを移動した場合のように、現在の値から新しい値にスムーズ"
"に移動したい場合があります。もちろん、Sonic Piでも`_slide:`オプションを使うことで、これを行うことができます。"

#: A.10-controlling-your-sound.md:125
msgid ""
"Each opt that can be modified also has a special corresponding `_slide:` opt t"
"hat allows you to specify a slide time. For example, `amp:` has `amp_slide:` a"
"nd `cutoff:` has `cutoff_slide:`. These slide opts work slightly differently t"
"han all the other opts in that they tell the synth note how to behave **next t"
"ime they are controlled**. Let's take a look:"
msgstr ""
"変更可能なオプションには、それぞれ対応する`_slide:`という特別なオプションがあり、スライドの時間を指定できます。例えば、`amp:`は`amp_sl"
"ide:`を、`cutoff:`は`cutoff_slide:`を持っています。これらのスライド・オプションは、**次にそれらがコントロールされたときに**"
"どのように動作するかをシンセの音符に指示するという点で、他のすべてのオプションとは少し異なります。次のコードを見てみましょう："

#: A.10-controlling-your-sound.md:131
#, no-wrap
msgid ""
"sn = synth :prophet, note: :e1, release: 8, cutoff: 70, cutoff_slide: 2\n"
"sleep 1\n"
"control sn, cutoff: 130"
msgstr ""
"sn = synth :prophet, note: :e1, release: 8, cutoff: 70, cutoff_slide: 2\n"
"sleep 1\n"
"control sn, cutoff: 130"

#: A.10-controlling-your-sound.md:137
msgid ""
"Notice how this example is exactly the same as before except with the addition"
" of `cutoff_slide:`. This is saying that next time this synth has its `cutoff:"
"` opt controlled, it will take 2 beats to slide from the current value to the "
"new one. Therefore, when we use `control` you can hear the cutoff slide from 7"
"0 to 130. It creates an interesting dynamic feel to the sound. Now, try changi"
"ng the `cutoff_slide:` time to a shorter value such as 0.5 or a longer value s"
"uch as 4 to see how it changes the sound. Remember, you can slide any of the m"
"odifiable opts in exactly this way and each `_slide:` value can be totally dif"
"ferent so you can have the cutoff sliding slowly, the amp sliding fast and the"
" pan sliding somewhere in between if that's what you're looking to create..."
msgstr ""
"この例が`cutoff_slide:`を除いて先の例と全く同じであることに注目してください。これは、このシンセで次に`cutoff:`をコントロールすると、"
"現在の値から新しい値にスライドするのに2拍かかることを示しています。したがって、`control`を使用したとき、カットオフが70から130までスライドする"
"のを聞くことができるでしょう。これは、音に興味深いダイナミックな感触を作り出します。次に、 `cutoff_slide:`の時間を0.5などの短い値や4など"
"のより長い値に変更して、音の変化を確認してください。変更可能なオプションであれば、これと同じようにスライドできることを覚えておいてください。それぞれの`_s"
"lide:`の値は完全に異なるので、あなたがやろうとすれば、カットオフをゆっくりとスライドしつつ、アンプは速くスライドし、パンをどこかの間をスライドさせるこ"
"とも可能です…"

#: A.10-controlling-your-sound.md:151
msgid ""
"Let's look at a short example which demonstrates the power of controlling synt"
"hs after they've been triggered. Notice that you can also slide FX just like s"
"ynths although with a slightly different syntax. Check out section 7.2 of the "
"built-in tutorial for more information on controlling FX."
msgstr ""
"シンセがトリガーされた後にコントロールする力を実証する短い例を見てみましょう。エフェクトもシンセと同じようにスライドできますが、少し文法が異なることに注目し"
"てください。エフェクトのコントロールについての情報は、チュートリアルのセクション7.2をチェックしてみてください。"

#: A.10-controlling-your-sound.md:157
msgid ""
"Copy the code into a spare buffer and take a listen. Don't stop there though -"
" play around with the code. Change the slide times, change the notes, the synt"
"h, the FX and the sleep times and see if you can turn it into something comple"
"tely different!"
msgstr ""
"以下のコードを使用可能なBufferにコピーして聞いてみてください。そこで止めずに、そのコードで遊んでみてください。スライドの時間や音符、シンセ、エフェクト"
"やスリープの時間を変更して、全く異なるものに変更できたことを確認してください！"

#: A.10-controlling-your-sound.md:162
#, no-wrap
msgid ""
"live_loop :moon_rise do\n"
"  with_fx :echo, mix: 0, mix_slide: 8 do |fx|\n"
"    control fx, mix: 1\n"
"    notes = (scale :e3, :minor_pentatonic, num_octaves: 2).shuffle\n"
"    sn = synth :prophet , sustain: 8, note: :e1, cutoff: 70, cutoff_slide: 8\n"
"    control sn, cutoff: 130\n"
"    sleep 2\n"
"    32.times do\n"
"      control sn, note: notes.tick, pan: rrand(-1, 1)\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end"
msgstr ""
"live_loop :moon_rise do\n"
"  with_fx :echo, mix: 0, mix_slide: 8 do |fx|\n"
"    control fx, mix: 1\n"
"    notes = (scale :e3, :minor_pentatonic, num_octaves: 2).shuffle\n"
"    sn = synth :prophet , sustain: 8, note: :e1, cutoff: 70, cutoff_slide: 8\n"
"    control sn, cutoff: 130\n"
"    sleep 2\n"
"    32.times do\n"
"      control sn, note: notes.tick, pan: rrand(-1, 1)\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end"

#: A.11-beat-tracking.md:1
msgid "A.11 Tick Tock"
msgstr "A.11 チック・タック"

#: A.11-beat-tracking.md:3
msgid "Tracking the Beat"
msgstr "ビートを追跡する"

#: A.11-beat-tracking.md:5
msgid ""
"Last month in this series we took a deep technical dive into the randomisation"
" system underpinning Sonic Pi. We explored how we can use it to deterministica"
"lly add new levels of dynamic control over our code. This month we're going to"
" continue our technical dive and turn our attention to Sonic Pi's unique tick "
"system. By the end of this article you'll be ticking your way through rhythms "
"and riffs on your way to being a live coding DJ."
msgstr ""
"このシリーズでは先月、Sonic Piを支えるランダム化のシステムについて技術的に詳しく見ました。そして、コードを動的に制御する新しい基準を、どのように決定"
"論的に追加できるか探索しました。今月は、引続きSonic Piのユニークなチック（tick）システムに焦点を当て、技術的に詳しく見てみたいと思います。この記"
"事の終わりまでに、あなた自身のやり方で、ライブコーディングDJに必要なリズムやリフのチックができるようになるでしょう。"

#: A.11-beat-tracking.md:13
msgid "Beat Counting"
msgstr "ビートをカウントする"

#: A.11-beat-tracking.md:15
msgid ""
"When making music we often want to do a different thing depending on which bea"
"t it is. Sonic Pi has a special beat counting system called `tick` to give you"
" precise control over when a beat actually occurs and even supports multiple b"
"eats with their own tempos."
msgstr ""
"音楽を作るときに、何ビート目であるかによって何か異なることをしたいことがよくあるでしょう。Sonic Piには、`tick`と呼ばれるビートをカウントする特"
"別なシステムがあって、ビートが実際にいつ起こるかを正確に制御でき、またそれぞれ独自のテンポを持った複数のビートにも対応しています。"

#: A.11-beat-tracking.md:20
msgid ""
"Let's have a play - to advance the beat we just need to call `tick`. Open up a"
" fresh buffer, type in the following and hit Run:"
msgstr ""
"早速遊んでみましょう。ビートを進めるのに必要なことは、単に`tick`を呼ぶだけです。新しいBufferを開いて、次のコードを入力して`Run`を叩いてみて"
"ください："

#: A.11-beat-tracking.md:23
#, no-wrap
msgid "puts tick #=> 0"
msgstr "puts tick #=> 0"

#: A.11-beat-tracking.md:27
msgid ""
"This will return the current beat: `0`. Notice that even if you press the Run "
"button a few times it will always return `0`. This is because each run starts "
"a fresh beat counting from 0. However, whilst the run is still active, we can "
"advance the beat as many times as we want:"
msgstr ""
"これは現在のビートの`0`を返すでしょう。`Run`ボタンを数回押しているにも関わらず、これが常に`0`を返すことに注意してください。これは、それぞれの実行"
"で新しいビートのカウントが0から開始するためです。しかし、実行がアクティブのままであれば、ビートを好きなだけ進めることができます："

#: A.11-beat-tracking.md:32
#, no-wrap
msgid ""
"puts tick #=> 0\n"
"puts tick #=> 1\n"
"puts tick #=> 2"
msgstr ""
"puts tick #=> 0\n"
"puts tick #=> 1\n"
"puts tick #=> 2"

#: A.11-beat-tracking.md:38
msgid ""
"Whenever you see the symbol `#=>` at the end of a line of code it means that t"
"hat line will log the text on the right-hand-side. For example, `puts foo #=> "
"0` means the code `puts foo` prints `0` to the log at that point in the progra"
"m."
msgstr ""
"コードの行の末尾に`#=>`シンボルがあるときは、そのコードが右側のテキストをログ出力することを意味しています。例えば、`puts foo #=> 0`は`"
"puts foo`がプログラムのその場所で`0`をログ出力することを意味します。"

#: A.11-beat-tracking.md:43
msgid "Checking the Beat"
msgstr "ビートを確認する"

#: A.11-beat-tracking.md:45
msgid ""
"We've seen that `tick` does two things. It increments (adds one) and returns t"
"he current beat. Sometimes we just want to look at the current beat without ha"
"ving to increment it which we can do via `look`:"
msgstr ""
"ここまでで、`tick`が2つのことをしているのを見てきました。それは、ビートを増やし（1を加算し）、ビートの値を返しています。場合によっては、ビートを増や"
"さずにただ値を見たいことがあるかもしれませんが、それは`look`で実現できます："

#: A.11-beat-tracking.md:49
#, no-wrap
msgid ""
"puts tick #=> 0\n"
"puts tick #=> 1\n"
"puts look #=> 1\n"
"puts look #=> 1"
msgstr ""
"puts tick #=> 0\n"
"puts tick #=> 1\n"
"puts look #=> 1\n"
"puts look #=> 1"

#: A.11-beat-tracking.md:56
msgid ""
"In this code we tick the beat up twice and then call `look` twice. We'll see t"
"he following values in the log: `0`, `1`, `1`, `1`. The first two `tick`s retu"
"rned `0`, then `1` as expected, then the two `look`s just returned the last be"
"at value twice which was `1`."
msgstr ""
"このコードでは`tick`でビートを2回増加させ、その後`look`を2回呼んでいます。実行すると、ログに`0`, `1`, `1`, `1`の値が表示され"
"るでしょう。最初の2つの`tick`で`0`と`1`を返し、次の2つの`look`はビートの最新の値である`1`を単純に返しています。"

#: A.11-beat-tracking.md:64
msgid ""
"So now we can advance the beat with `tick` and check the beat with `look`. Wha"
"t next? We need something to tick over. Sonic Pi uses rings for representing r"
"iffs, melodies and rhythms and the tick system has been specifically designed "
"to work very closely with them. In fact, rings have their own dot version of `"
"tick` which does two things. Firstly, it acts like a regular tick and incremen"
"ts the beat. Secondly it looks up the ring value using the beat as the index. "
"Let's take a look:"
msgstr ""
"`tick`でビートを進め、`look`でビートを確認できるようになりました。次は何でしょう？ `tick`で何かを進める必要がありそうですね。Sonic "
"Piはリフやメロディーやリズムを表すのにリングを使っていて、`tick`システムはこれと密接に連携するよう設計されています。実際に、リングは`.`の付いた`"
"tick`の独自のバージョンを持っていて、それは2つのことをします。最初に、それは通常の`tick`と同じようにビートを増加させます。次に、ビートをインデッ"
"クスとして使用して、リングの値にアクセスします。次を見てみましょう："

#: A.11-beat-tracking.md:72
#, no-wrap
msgid "puts (ring :a, :b, :c).tick #=> :a"
msgstr "puts (ring :a, :b, :c).tick #=> :a"

#: A.11-beat-tracking.md:76
msgid ""
"`.tick` is a special dot version of `tick` which will return the first value o"
"f the ring `:a`. We can grab each of the values in the ring by calling `.tick`"
" multiple times:"
msgstr ""
"`.tick`は`tick`の`.`付きの特別なバージョンで、これはリングの最初の値である`:a`を返します。次のように、`.tick`を複数回呼ぶことで、"
"リングの値をそれぞれ掴むことができます："

#: A.11-beat-tracking.md:80
#, no-wrap
msgid ""
"puts (ring :a, :b, :c).tick #=> :a\n"
"puts (ring :a, :b, :c).tick #=> :b\n"
"puts (ring :a, :b, :c).tick #=> :c\n"
"puts (ring :a, :b, :c).tick #=> :a\n"
"puts look                   #=> 3"
msgstr ""
"puts (ring :a, :b, :c).tick #=> :a\n"
"puts (ring :a, :b, :c).tick #=> :b\n"
"puts (ring :a, :b, :c).tick #=> :c\n"
"puts (ring :a, :b, :c).tick #=> :a\n"
"puts look                   #=> 3"

#: A.11-beat-tracking.md:88
msgid ""
"Take a look at the log and you'll see `:a`, `:b`, `:c` and then `:a` again. No"
"tice that `look` returns `3`. Calls to `.tick` act just like they are regular "
"calls to `tick` - they increment the local beat."
msgstr ""
"ログを見ると、`:a`, `:b`, `:c`が表示され、その後再び`:a`が表示されているでしょう。`look`が`3`を返しているのに注目してください。"
"`.tick`の呼び出しは、`tick`の通常の呼び出しとちょうど似た振る舞いをしていますが、それは独自のビートを増加させているのです。"

#: A.11-beat-tracking.md:93
msgid "A Live Loop Arpeggiator"
msgstr "ライブループ・アルペジエーター"

#: A.11-beat-tracking.md:95
msgid ""
"The real power comes when you mix `tick` with rings and `live_loop`s. When com"
"bined we have all the tools we need to both build and understand a simple arpe"
"giator. We need just four things:"
msgstr ""
"'tick'は、リングと`live_loop`と組み合わせることによって、本当の力が発揮されます。それらを組み合せると、シンプルなアルペジエーターを構築して"
"理解するために必要な全ての道具を手に入れたことになります。必要なものは、次の4つです："

#: A.11-beat-tracking.md:99
msgid "A ring containing the notes we want to loop over."
msgstr "ループしたい音符を保持するリング"

#: A.11-beat-tracking.md:100
msgid "A means of incrementing and obtaining the beat."
msgstr "ビートを増加したり保持したりする手段"

#: A.11-beat-tracking.md:101
msgid "The ability to play a note based on the current beat."
msgstr "ビートに応じて音符を演奏する機能"

#: A.11-beat-tracking.md:102
msgid "A loop structure to keep the arpegiator repeating."
msgstr "アルペジエーターを繰り返し続けるループ構造"

#: A.11-beat-tracking.md:104
msgid "These concepts can all be found in the following code:"
msgstr "これらの概念のすべてを、次のコードで見つけることができます："

#: A.11-beat-tracking.md:106
#, no-wrap
msgid ""
"notes = (ring 57, 62, 55, 59, 64)\n"
"live_loop :arp do\n"
"  use_synth :dpulse\n"
"  play notes.tick, release: 0.2\n"
"  sleep 0.125\n"
"end"
msgstr ""
"notes = (ring 57, 62, 55, 59, 64)\n"
"live_loop :arp do\n"
"  use_synth :dpulse\n"
"  play notes.tick, release: 0.2\n"
"  sleep 0.125\n"
"end"

#: A.11-beat-tracking.md:116
msgid ""
"Let's look at each of these lines. First we define our ring of notes which we'"
"ll continually play. We then create a `live_loop` called `:arp` which loops ro"
"und for us. Each time round the `live_loop` we set our synth to `:dpulse` and "
"then play the next note in our ring using `.tick`. Remember that this will inc"
"rement our beat counter and use the latest beat value as an index into our not"
"es ring. Finally, we wait for an eighth of a beat before looping round again."
msgstr ""
"各行を順に見ていきましょう。最初に、繰り返し演奏される音符のリングを定義しています。次に、`:arp`と名付けられた`live_loop`を作ってループさせ"
"ています。`live_loop`を繰り返す度に、シンセを`:dpulse`に設定し、`.tick`と使ってリング内の次の音符を演奏しています。これにより、ビ"
"ートのカウンタを増加させ、最新のビートの値を音符のリングのインデックスとして使っている点に注意してください。最後に、1/8拍待ってループしています。"

#: A.11-beat-tracking.md:124
msgid "Multiple Simultaneous Beats"
msgstr "複数の同時ビート"

#: A.11-beat-tracking.md:126
msgid ""
"A really important thing to know is that `tick`s are local to the `live_loop`."
" This means that each `live_loop` has its own independent beat counter. This i"
"s much more powerful than having a global metronome and beat. Let's take a loo"
"k at this in action:"
msgstr ""
"本当に知っておいて欲しい大切なことは、`tick`は`live_loop`でローカルなことです。これは、それぞれの`live_loop`がそれ自身の独立した"
"ビートのカウンタを持っていることを意味します。これは、グローバルなメトロノームとビートよりもはるかに強力です。実際に動いているところを見てみましょう："

#: A.11-beat-tracking.md:131
#, no-wrap
msgid ""
"notes = (ring 57, 62, 55, 59, 64)\n"
"with_fx :reverb do\n"
"  live_loop :arp do\n"
"    use_synth :dpulse\n"
"    play notes.tick + 12, release: 0.1\n"
"    sleep 0.125\n"
"  end\n"
"end\n"
"live_loop :arp2 do\n"
"  use_synth :dsaw\n"
"  play notes.tick - 12, release: 0.2\n"
"  sleep 0.75\n"
"end"
msgstr ""
"notes = (ring 57, 62, 55, 59, 64)\n"
"with_fx :reverb do\n"
"  live_loop :arp do\n"
"    use_synth :dpulse\n"
"    play notes.tick + 12, release: 0.1\n"
"    sleep 0.125\n"
"  end\n"
"end\n"
"live_loop :arp2 do\n"
"  use_synth :dsaw\n"
"  play notes.tick - 12, release: 0.2\n"
"  sleep 0.75\n"
"end"

#: A.11-beat-tracking.md:149
msgid "Clashing Beats"
msgstr "ビートを壊す"

#: A.11-beat-tracking.md:151
msgid ""
"A big cause of confusion with Sonic Pi's tick system is when people want to ti"
"ck over multiple rings in the same `live_loop`:"
msgstr "Sonic Piの`tick`システムに関する混乱の大きな原因は、`live_loop`に複数のリングで`tick`をしようとする際に生じるものです："

#: A.11-beat-tracking.md:154
#, no-wrap
msgid ""
"use_bpm 300\n"
"use_synth :blade\n"
"live_loop :foo do\n"
"  play (ring :e1, :e2, :e3).tick\n"
"  play (scale :e3, :minor_pentatonic).tick\n"
"  sleep 1\n"
"end"
msgstr ""
"use_bpm 300\n"
"use_synth :blade\n"
"live_loop :foo do\n"
"  play (ring :e1, :e2, :e3).tick\n"
"  play (scale :e3, :minor_pentatonic).tick\n"
"  sleep 1\n"
"end"

#: A.11-beat-tracking.md:164
msgid ""
"Even though each `live_loop` has its own independent beat counter, we're calli"
"ng `.tick` twice within the same `live_loop`. This means that the beat will be"
" incremented twice every time round. This can produce some interesting polyrhy"
"thms but is often not what you want. There are two solutions to this problem. "
"One option is to manually call `tick` at the start of the `live_loop` and then"
" use `.look` to look up the current beat in each `live_loop`. The second solut"
"ion is to pass a unique name to each call to `.tick` such as `.tick(:foo)`. So"
"nic Pi will then create and track a separate beat counter for each named tick "
"you use. That way you can work with as many beats as you need! See the section"
" on named ticks in 9.4 of the built-in tutorial for more information."
msgstr ""
"`live_loop`には独自のビートのカウンタがありますが、ここでは同じ`live_loop`内で`.tick`を2回呼び出しています。これは、ループする"
"毎にビートが2回増加されることを意味しています。これは何か面白いポリリズムを生み出すことができるかもしれませんが、多くの場合あなたが望むものではないでしょう"
"。この問題には2つの解決策があります。1つめは、`live_loop`の開始時に手動で`tick`を呼び出し、`.look`を使って各`live_loop`"
"の現在のビートを確認することです。2つめは、`.tick(:foo)`のように、`.tick`の呼び出しにユニークな名前を渡すことです。Sonic Piは、"
"名前付きチック毎に別々のビートのカウンタを作成し、追跡します。そうすれば、必要なだけ多くのビートで作業できます！ 詳細については、チュートリアルの9.4の名"
"前付きチックに関するセクションを参照してください。"

#: A.11-beat-tracking.md:178
msgid ""
"Let's bring all this knowledge of `tick`s, `ring`s and `live_loop`s together f"
"or a final fun example. As usual, don't treat this as a finished piece. Start "
"changing things and play around with it and see what you can turn it into. See"
" you next time..."
msgstr ""
"`tick`, `ring`, `live_loop`の知識を使って、最後に楽しい例を紹介しましょう。いつものように、これを完成された曲として扱わないように"
"してください。これで遊びながら色々と変更して、どこまで変えることができるか見てみてください。ではまた次回お会いしましょう…"

#: A.11-beat-tracking.md:183
#, no-wrap
msgid ""
"use_bpm 240\n"
"notes = (scale :e3, :minor_pentatonic).shuffle\n"
"live_loop :foo do\n"
"  use_synth :blade\n"
"  with_fx :reverb, reps: 8, room: 1 do\n"
"    tick\n"
"    co = (line 70, 130, steps: 32).tick(:cutoff)\n"
"    play (octs :e3, 3).look, cutoff: co, amp: 2\n"
"    play notes.look, amp: 4\n"
"    sleep 1\n"
"  end\n"
"end\n"
"live_loop :bar do\n"
"  tick\n"
"  sample :bd_ada if (spread 1, 4).look\n"
"  use_synth :tb303\n"
"  co = (line 70, 130, steps: 16).look\n"
"  r = (line 0.1, 0.5, steps: 64).mirror.look\n"
"  play notes.look, release: r, cutoff: co\n"
"  sleep 0.5\n"
"end"
msgstr ""
"use_bpm 240\n"
"notes = (scale :e3, :minor_pentatonic).shuffle\n"
"live_loop :foo do\n"
"  use_synth :blade\n"
"  with_fx :reverb, reps: 8, room: 1 do\n"
"    tick\n"
"    co = (line 70, 130, steps: 32).tick(:cutoff)\n"
"    play (octs :e3, 3).look, cutoff: co, amp: 2\n"
"    play notes.look, amp: 4\n"
"    sleep 1\n"
"  end\n"
"end\n"
"live_loop :bar do\n"
"  tick\n"
"  sample :bd_ada if (spread 1, 4).look\n"
"  use_synth :tb303\n"
"  co = (line 70, 130, steps: 16).look\n"
"  r = (line 0.1, 0.5, steps: 64).mirror.look\n"
"  play notes.look, release: r, cutoff: co\n"
"  sleep 0.5\n"
"end"

#: A.12-sample-slicing.md:1
msgid "A.12 Sample Slicing"
msgstr "A.12 サンプルをスライスする"

#: A.12-sample-slicing.md:3
msgid "Sample Slicing"
msgstr "サンプルをスライスする"

#: A.12-sample-slicing.md:5
msgid ""
"Way back in episode 3 of this Sonic Pi series we looked at how to loop, stretc"
"h and filter one of the most famous drum breaks of all time - the Amen Break. "
"In this tutorial we're going to take this one step further and learn how to sl"
"ice it up, shuffle the slices and glue it back together in a completely new or"
"der. If that sounds a bit crazy to you, don't worry, it will all become clear "
"and you'll soon master a powerful new tool for your live coded sets."
msgstr ""
"このSonic Piのシリーズの3回目の記事では、最も有名なドラム・ブレイクの1つであるアーメン・ブレイクをループ、ストレッチ、フィルタする方法を見ました。"
"今回の記事では、これをさらに一歩進めて、スライスし、スライスをシャッフルし、まったく新しい順序で一緒に戻す方法を学習します。それは少しクレイジーな話に聞こえ"
"るかもしれませんが、心配する必要はありません。それはすべて明らかになり、あなたはライブコーディングのセットのための強力な新しいツールをすぐに習得するでしょう"
"。"

#: A.12-sample-slicing.md:13
msgid "Sound as Data"
msgstr "データとしてのサウンド"

#: A.12-sample-slicing.md:15
msgid ""
"Before we get started let's just take a brief moment to understand how to work"
" with samples. By now, you've all hopefully played with Sonic Pi's powerful sa"
"mpler. If not, there's no time like the present! Boot up your Raspberry Pi, la"
"unch Sonic Pi from the Programming menu, type the following into a fresh buffe"
"r and then hit the Run button to hear a pre-recorded drum beat:"
msgstr ""
"始める前に、少し時間を取って、サンプルで作業する方法を理解しましょう。ここまでで、みなさんはSonic Piの強力なサンプラーで遊んだことがあると思います。"
"もし試したことがなかったら、今やってみましょう！ Raspberry Piを起動し、Sonic Piを`Programming`のメニューから起動し、新しい"
"Bufferに次のように入力して、`Run`ボタンを押すと、あらかじめ録音されたドラムビートを聞くことができます："

#: A.12-sample-slicing.md:26
msgid ""
"A recording of a sound is simply represented as data - lots of numbers between"
" -1 and 1 which represent the peaks and troughs of the sound wave. If we play "
"those numbers back in order, we get the original sound. However, what's to sto"
"p us from playing them back in a different order and creating a new sound?"
msgstr ""
"音の記録は、音の波形の山と谷を表す-1から1のたくさんの数値のデータとして単純に表現されます。これらの数値を順番に再生すると、元の音が得られます。しかし、そ"
"れらを別の順序で再生して新しい音を作り出すことに、何か問題があるしょうか？"

#: A.12-sample-slicing.md:32
msgid ""
"How are samples actually recorded? It's actually pretty simple once you unders"
"tand the basic physics of sound. When you make a sound - for example by hittin"
"g a drum, the noise travels through the air in a similar fashion to how the su"
"rface of a lake ripples when you throw a pebble into it. When those ripples re"
"ach your ears, your eardrum moves sympathetically and converts those movements"
" into the sound you hear. If we wish to record and play back the sound, we the"
"refore need a way of capturing, storing and reproducing those ripples. One way"
" is to use a microphone which acts like an eardrum and moves back and forth as"
" the sound ripples hit it. The microphone then converts its position into a ti"
"ny electric signal which is then measured many times a second. These measureme"
"nts are then represented as a series of numbers between -1 and 1."
msgstr ""
"実際にサンプルはどのように記録されるのでしょうか？ 音の基本的な物理を一度理解すれば、実際のところかなり簡単です。例えばドラムを叩くなどして音を出すと、小石"
"を投げ込んだときに湖の表面が波打つのと同じように、空気中を音が移動します。これらの波紋があなたの耳に届くと、あなたの鼓膜が共振するよう動いて、その動きを聞こ"
"える音に変換します。したがって、音を記録して再生したい場合、これらの波紋をキャプチャし、保存し、再生する方法が必要です。1つの方法は、鼓膜のように音の波紋が"
"届いたときに前後に振動するマイクロフォンを使用することです。マイクロフォンはその位置を小さな電気信号に変換します。そして、それを1秒間に何度も測定します。こ"
"れらの測定値は、-1と1の間の一連の数値として表されます。"

#: A.12-sample-slicing.md:46
msgid ""
"If we were to plot a visualisation of the sound it would be a simple graph of "
"data with time on the x axis and microphone/speaker position as a value betwee"
"n -1 and 1 on the y axis. You can see an example of such a graph at the top of"
" the diagram."
msgstr ""
"音を視覚化してプロットしようとすると、x軸に時間を、y軸にマイクロフォン/スピーカーの位置を-1と1の間の値として持つデータの単純なグラフになるでしょう。こ"
"のようなグラフの例は、図表の上部に見ることができるでしょう。"

#: A.12-sample-slicing.md:51
msgid "Playing Part of a Sample"
msgstr "サンプルを部分的に再生する"

#: A.12-sample-slicing.md:53
msgid ""
"So, how do we code Sonic Pi to play a sample back in a different order? To ans"
"wer this question we need to take a look at the `start:` and `finish:` opts fo"
"r `sample`. These let us control the start and finish positions of our playbac"
"k of the numbers which represent the sound. The values for both of these opts "
"are represented as a number between `0` and `1` where `0` represents the start"
" of the sample and `1` is the end. So, to play the first half of the Amen Brea"
"k, we just need to specify a `finish:` of `0.5`:"
msgstr ""
"では、サンプルを別の順序で再生するためには、Sonic Piでどのようにコーディングすれば良いでしょうか？ この質問に答えるには、`sample`の`sta"
"rt:`と`finish:`オプションを見てみる必要があります。これらは、サウンドを表す数字の再生の開始位置と終了位置を制御します。これらのオプションのどち"
"らの値も`0`と`1`の間の数字として表され、`0`はサンプルの開始を、`1`は終了を表しています。したがって、アーメン・ブレイクの前半部分を再生するに必要"
"なことは、次のように`finish:`に`0.5`を指定するだけです："

#: A.12-sample-slicing.md:66
msgid "We can add in a `start:` value to play an even smaller section of the sample:"
msgstr "また、`start:`の値を追加することもでき、先ほどの例より更に短い区間のサンプルを演奏することも可能です："

#: A.12-sample-slicing.md:68
#, no-wrap
msgid "sample :loop_amen, start: 0.25, finish: 0.5"
msgstr "sample :loop_amen, start: 0.25, finish: 0.5"

#: A.12-sample-slicing.md:72
msgid ""
"For fun, you can even have the `finish:` opt's value be *before* `start:` and "
"it will play the section backwards:"
msgstr "更に面白いのは、`finish:`オプションの値を`start:`より*前に*設定することができます。その場合には、その区間が逆再生されます："

#: A.12-sample-slicing.md:75
#, no-wrap
msgid "sample :loop_amen, start: 0.5, finish: 0.25"
msgstr "sample :loop_amen, start: 0.5, finish: 0.25"

#: A.12-sample-slicing.md:79
msgid "Re-ordering Sample Playback"
msgstr "サンプル再生の順序並び替え"

#: A.12-sample-slicing.md:81
msgid ""
"Now that we know that a sample is simply a list of numbers that can be played "
"back in any order and also how to play a specific part of a sample we can now "
"start having fun playing a sample back in the 'wrong' order."
msgstr ""
"サンプルが単純にどの順序でも再生可能な数字のリストであることと、特定の位置から再生する方法を習得したので、サンプルを'誤った'順序で楽しく再生することができ"
"るようになりました。"

#: A.12-sample-slicing.md:86
#, fuzzy
msgid ""
"![Amen Slices](../../../etc/doc/images/tutorial/articles/A.12-sample-slicing/a"
"men_slice.png)"
msgstr ""
"![Amen Slices](../../../etc/doc/images/tutorial/articles/A.12-sample-slicing/a"
"men_slice.png)"

#: A.12-sample-slicing.md:88
msgid ""
"Let's take our Amen Break and chop it up into 8 equally-sized slices and then "
"shuffle the pieces around. Take a look at the diagram: at the top A) represent"
"s the graph of our original sample data. Chopping it into 8 slices gives us B)"
" - notice that we've given each slice a different colour to help distinguish t"
"hem. You can see each slice's start and finish values at the top. Finally C) i"
"s one possible re-ordering of the slices. We can then play this back to create"
" a new beat. Take a look at the code to do this:"
msgstr ""
"アーメン・ブレイクを8つの同じサイズのスライスにぶつ切りにして、それをシャッフルしてみましょう。図を見てください：上のAはサンプルのオリジナルのデータです。"
"それを8つのスライスにぶつ切りにしたのがBです。それぞれのスライスを異なる色にして区別しやすくしていることに注意してください。また、各スライスの開始と終了の"
"値が上にあるのを見ることができるでしょう。最後にCは、スライスの並び替えの1例です。これを再生して新しいビートを作ることができます。これを実現するためのコー"
"ドを見てみましょう："

#: A.12-sample-slicing.md:97
#, no-wrap
msgid ""
"live_loop :beat_slicer do\n"
"  slice_idx = rand_i(8)\n"
"  slice_size = 0.125\n"
"  s = slice_idx * slice_size\n"
"  f = s + slice_size\n"
"  sample :loop_amen, start: s, finish: f\n"
"  sleep sample_duration :loop_amen, start: s, finish: f\n"
"end"
msgstr ""
"live_loop :beat_slicer do\n"
"  slice_idx = rand_i(8)\n"
"  slice_size = 0.125\n"
"  s = slice_idx * slice_size\n"
"  f = s + slice_size\n"
"  sample :loop_amen, start: s, finish: f\n"
"  sleep sample_duration :loop_amen, start: s, finish: f\n"
"end"

#: A.12-sample-slicing.md:108
msgid ""
"we choose a random slice to play which should be a random number between 0 and"
" 7 (remember that we start counting at 0). Sonic Pi has a handy function for e"
"xactly this: `rand_i(8)`. We then store this random slice index in the variabl"
"e `slice_idx`."
msgstr ""
"0から7のランダムな数字（0から数え始めることを忘れないでください）のいずれかのスライスを選択しています。Sonic Piは正にこれを行うための便利な関数と"
"して、`rand_i(8)`を使うことができます。次に、このランダムなスライスのインデックスを`slice_idx`変数に格納しています。"

#: A.12-sample-slicing.md:113
msgid ""
"We define our `slice_size` which is 1/8 or 0.125. The `slice_size` is necessar"
"y for us to convert our `slice_idx` into a value between 0 and 1 so we can use"
" it as our `start:` opt."
msgstr ""
"`slice_size`を1/8または0.125に定義しています。`slice_size`は、`slice_idx`を`start:`オプションで使用する0"
"から1の値に変更するために必要です。"

#: A.12-sample-slicing.md:117
msgid ""
"We calculate the start position `s` by multiplying the `slice_idx` by the `sli"
"ce_size`."
msgstr "開始地点である`s`は、`slice_idx`と`slice_size`を掛け算して求めます。"

#: A.12-sample-slicing.md:120
msgid ""
"We calculate the finish position `f` by adding the `slice_size` to the start p"
"osition `s`."
msgstr "終了地点である`f`は、開始地点である`s`と`slice_size`を足し算して求めます。"

#: A.12-sample-slicing.md:123
msgid ""
"We can now play the sample slice by plugging in the `s` and `f` values into th"
"e `start:` and `finish:` opts for `sample`."
msgstr "変数`s`と`f`を`sample`関数の`start:`と`finish:`にそれぞれ繋げて、サンプルのスライスを再生することができるようになりました。"

#: A.12-sample-slicing.md:126
msgid ""
"Before we play the next slice we need to know how long to `sleep` which should"
" be the duration of the sample slice. Luckily, Sonic Pi has us covered with `s"
"ample_duration` which accepts all the same opts as `sample` and simply returns"
" the duration. Therefore, by passing `sample_duration` our `start:` and `finis"
"h:` opts, we can find out the duration of a single slice."
msgstr ""
"次のスライスを再生する前に、どれだけの時間`sleep`するか、すなわちスライスされたサンプルの長さを知る必要があります。幸いにも、Sonic Piには単に"
"サンプルの長さを返す`sample_duration`関数があり、それは`sample`と全く同じオプションを受け入れます。したがって、`sample_du"
"ration`に`start:`と`finish:`オプションを渡してあげれば、スライスの長さを知ることができるのです。"

#: A.12-sample-slicing.md:133
msgid ""
"We wrap all of this code in a `live_loop` so that we continue to pick new rand"
"om slices to play."
msgstr "そして、新しいランダムなスライスを選んで再生し続けるように、このコードの全てを`live_loop`で包みます。"

#: A.12-sample-slicing.md:139
msgid ""
"Let's combine everything we've seen so far into a final example which demonstr"
"ates how we can take a similar approach to combine randomly sliced beats with "
"some bass to create the start of an interesting track. Now it's your turn - ta"
"ke the code below as a starting point and see if you can take it in your own d"
"irection and create something new..."
msgstr ""
"ここまで見てきた全てを組み合わせて最後の例にしましょう。興味深いトラックの作り始めるのに、ランダムにスライスされたビートとベースを組み合せた同じようなアプロ"
"ーチが可能であることを示していると思います。次は、あなたの番です。このコードを開始地点として、自分自身で進めて何か新しいものを作れるか見てみてください…"

#: A.12-sample-slicing.md:145
#, no-wrap
msgid ""
"live_loop :sliced_amen do\n"
"  n = 8\n"
"  s =  line(0, 1, steps: n).choose\n"
"  f = s + (1.0 / n)\n"
"  sample :loop_amen, beat_stretch: 2, start: s, finish: f\n"
"  sleep 2.0  / n\n"
"end\n"
"live_loop :acid_bass do\n"
"  with_fx :reverb, room: 1, reps: 32, amp: 0.6 do\n"
"    tick\n"
"    n = (octs :e0, 3).look - (knit 0, 3 * 8, -4, 3 * 8).look\n"
"    co = rrand(70, 110)\n"
"    synth :beep, note: n + 36, release: 0.1, wave: 0, cutoff: co\n"
"    synth :tb303, note: n, release: 0.2, wave: 0, cutoff: co\n"
"    sleep (ring 0.125, 0.25).look\n"
"  end\n"
"end"
msgstr ""
"live_loop :sliced_amen do\n"
"  n = 8\n"
"  s =  line(0, 1, steps: n).choose\n"
"  f = s + (1.0 / n)\n"
"  sample :loop_amen, beat_stretch: 2, start: s, finish: f\n"
"  sleep 2.0  / n\n"
"end\n"
"live_loop :acid_bass do\n"
"  with_fx :reverb, room: 1, reps: 32, amp: 0.6 do\n"
"    tick\n"
"    n = (octs :e0, 3).look - (knit 0, 3 * 8, -4, 3 * 8).look\n"
"    co = rrand(70, 110)\n"
"    synth :beep, note: n + 36, release: 0.1, wave: 0, cutoff: co\n"
"    synth :tb303, note: n, release: 0.2, wave: 0, cutoff: co\n"
"    sleep (ring 0.125, 0.25).look\n"
"  end\n"
"end"

#: A.13-probabilistic-sequencer.md:1
msgid "A.13 Code a Probabilistic Sequencer"
msgstr "A.13 確率的シーケンサーをコーディングする"

#: A.13-probabilistic-sequencer.md:3
msgid "Code a Probabilistic Sequencer"
msgstr "確率的シーケンサーをコーディングする"

#: A.13-probabilistic-sequencer.md:5
msgid ""
"In a previous episode of this Sonic Pi series we explored the power of randomi"
"sation to introduce variety, surprise and change into our live coded tracks an"
"d performances. For example, we randomly picked notes from a scale to create n"
"ever-ending melodies. Today we're going to learn a new technique which uses ra"
"ndomisation for rhythm - probabilistic beats!"
msgstr ""
"このシリーズの前回の記事では、ランダム化の力を探求し、それがライブコーディングされたトラックやパフォーマンスに多様性や驚きや変化をもたらすのを示しました。例"
"えば、ある音階からランダムにピックアップした音符で、終わりのないメロディーを作りました。今日は、ランダム化をリズムに適用した新しいテクニック、確率的ビートに"
"ついて学びます。"

#: A.13-probabilistic-sequencer.md:12
msgid "Probability"
msgstr "確率"

#: A.13-probabilistic-sequencer.md:14
msgid ""
"Before we can start making new beats and synth rhythms we need to take a quick"
" dive into the basics of probability. This might sound daunting and complicate"
"d, but really it's just as simple as rolling a dice - honestly! When you take "
"a regular 6 sided board game dice and roll it what's actually happening? Well,"
" firstly you'll roll either a 1, 2, 3, 4, 5 or 6 with exactly the same chance "
"of getting any of the numbers. In fact, given that it's a 6 sided dice, on ave"
"rage (if you roll lots and lots of times) you'll throw a 1 every 6 throws. Thi"
"s means you have a 1 in 6 chance of throwing a 1. We can emulate dice rolls in"
" Sonic Pi with the fn `dice`. Let's roll one 8 times:"
msgstr ""
"新しいビートやシンセのリズムを作り始める前に、確率に関する基本についてざっと見てみる必要があります。これは複雑で骨の折れるように聞こえるかもしれませんが、実"
"際のところ、サイコロを振るのと同じくらい簡単です！ 普通の6面のサイコロを振ると何が起きるでしょうか？ そうですね。1, 2, 3, 4, 5, 6のいずれ"
"かが同じチャンスで得られるでしょう。実際、6面のサイコロであれば、（もしあなたが何度も何度も振れば）平均して6回に1回1の目が出るでしょう。これが1の目を出"
"すのに1/6のチャンスがあることを示しています。Sonic Piでは、サイコロを振るのを`dice`関数でエミュレートできます。では8回サイコロを振ってみま"
"しょう："

#: A.13-probabilistic-sequencer.md:25
#, no-wrap
msgid ""
"8.times do\n"
"  puts dice\n"
"  sleep 1\n"
"end"
msgstr ""
"8.times do\n"
"  puts dice\n"
"  sleep 1\n"
"end"

#: A.13-probabilistic-sequencer.md:32
msgid ""
"Notice how the log prints values between 1 and 6 just as if we'd rolled a real"
" dice ourselves."
msgstr "ちょうど実物のサイコロを振ったのと同じように、1から6の間の値をログに表示していることに注目してください。"

#: A.13-probabilistic-sequencer.md:35
msgid "Random Beats"
msgstr "ランダム・ビート"

#: A.13-probabilistic-sequencer.md:37
msgid ""
"Now imagine you had a drum and every time you were about to hit it you rolled "
"a dice. If you rolled a 1, you hit the drum and if you rolled any other number"
" you didn't. You now have a probabilistic drum machine working with a probabil"
"ity of 1/6! Let's hear what that sounds like:"
msgstr ""
"では、あなたの目の前にドラムがあって、それを叩こうとするときにいつもサイコロを振るのを想像してみてください。もしあなたが1の目を出したらドラムを叩き、それ以"
"外の目を出したら叩かないとしましょう。これであなたは、1/6の確率で動作する確率的なドラムマシーンを手に入れたことになります！ どんな音がするか聞いてみまし"
"ょう："

#: A.13-probabilistic-sequencer.md:42
#, no-wrap
msgid ""
"live_loop :random_beat do\n"
"  sample :drum_snare_hard if dice == 1\n"
"  sleep 0.125\n"
"end"
msgstr ""
"live_loop :random_beat do\n"
"  sample :drum_snare_hard if dice == 1\n"
"  sleep 0.125\n"
"end"

#: A.13-probabilistic-sequencer.md:50
msgid ""
"Let's quickly go over each line to make sure everything is very clear. First w"
"e create a new `live_loop` called `:random_beat` which will continually repeat"
" the two lines between `do` and `end`. The first of these lines is a call to `"
"sample` which will play a pre-recorded sound (the `:drum_snare_hard` sound in "
"this case). However, this line has a special conditional `if` ending. This mea"
"ns that the line will only be executed if the statement on the right hand side"
" of the `if` is `true`. The statement in this case is `dice == 1`. This calls "
"our `dice` function which, as we have seen, returns a value between 1 and 6. W"
"e then use the equality operator `==` to check to see if this value is `1`. If"
" it is `1`, then the statement resolves to `true` and our snare drum sounds, i"
"f it isn't `1` then the statement resolves to `false` and the snare is skipped"
". The second line simply waits for `0.125` seconds before rolling the dice aga"
"in."
msgstr ""
"全てが明確になるよう、各行をざっと見ていきましょう。最初に、`:random_beat`という名前を付けた`live_loop`を作って、`do`から`en"
"d`までの2行を繰り返しています。ループ内の最初の行は、`sample`を呼んであらかじめ録音された音（この場合は`:drum_snare_hard`の音）"
"を再生しています。しかし、この行には特別な`if`の条件が末尾に付いています。これは、この行が`if`の右側の条件式が`true`であるときだけ実行されるこ"
"とを意味しています。この場合、条件式は`dice == 1`です。`dice`関数の呼び出しは、我々が既に見てきたように、1から6の値を返します。つづいて、"
"等価演算子の`==`を使って、この値が`1`かどうかチェックしています。もし`1`であれば、この条件式は`true`となり、スネアドラムの音が再生され、`1"
"`でなければ、この条件式は`false`となり、スネアドラムはスキップされます。ループ内の2行目は、次にサイコロを振る前に、単に`0.125`秒間待っている"
"だけです。"

#: A.13-probabilistic-sequencer.md:65
msgid "Changing Probabilities"
msgstr "確率を変更する"

#: A.13-probabilistic-sequencer.md:67
msgid ""
"Those of you that have played role play games will be familiar with lots of st"
"rangely shaped dice with different ranges. For example there is the tetrahedro"
"n shaped dice which has 4 sides and even a 20 sided dice in the shape of a ico"
"sahedron. The number of sides on the dice changes the chance, or probability o"
"f rolling a 1. The fewer sides, the more likely you are to roll a 1 and the mo"
"re sides the less likely. For example, with a 4 sided dice, there's a one in 4"
" chance of rolling a 1 and with a 20 sided dice there's a one in 20 chance. Lu"
"ckily, Sonic Pi has the handy `one_in` fn for describing exactly this. Let's p"
"lay:"
msgstr ""
"ロールプレイングゲームをプレイしたことがある人の中には、さまざまな範囲を持つ不思議なな形をしたサイコロに馴染みがあるかもしれません。たとえば、三角錐（正四面"
"体）の形をした4面のサイコロや、正二十面体の形をした20面のサイコロがあります。サイコロの面の数はも1の目を出すチャンスや確率を変えます。面が少なければ、よ"
"り1の目を出しやすくなり、面が多くなれば、より1の目を出しにくくなります。たとえば、4面のサイコロでは、1の目をだすのに1/4のチャンスがありますが、20面"
"のサイコロでは、1の目をだすのに1/20のチャンスがあります。幸いにも、Sonic Piにはちょうどこれと同じことができる便利な`one_in`関数がありま"
"す。次をやってみましょう："

#: A.13-probabilistic-sequencer.md:77
#, no-wrap
msgid ""
"live_loop :different_probabilities do\n"
"  sample :drum_snare_hard if one_in(6)\n"
"  sleep 0.125\n"
"end"
msgstr ""
"live_loop :different_probabilities do\n"
"  sample :drum_snare_hard if one_in(6)\n"
"  sleep 0.125\n"
"end"

#: A.13-probabilistic-sequencer.md:84
msgid ""
"Start the live loop above and you'll hear the familiar random rhythm. However,"
" don't stop the code running. Instead, change the `6` to a different value suc"
"h as `2` or `20` and hit the `Run` button again. Notice that lower numbers mea"
"n the snare drum sounds more frequently and higher numbers mean the snare trig"
"gers fewer times. You're making music with probabilities!"
msgstr ""
"上のライブループを開始すると、馴染みのあるランダムリズムを聞くことができるでしょう。しかし、実行されているコードを止めないでください。そのかわり、`6`を異"
"なる値、たとえば`2`とか`20`に変更して、`Run`ボタンを叩いてみてください。小さい数字はスネアドラムがより頻繁に再生され、大きい数字はスネアドラムが"
"あまり頻繁に再生されないということを意味しているのに注目してください。これであなたは確率で音楽を作っていることになるのです！"

#: A.13-probabilistic-sequencer.md:91
msgid "Combining Probabilities"
msgstr "確率を組み合せる"

#: A.13-probabilistic-sequencer.md:93
msgid ""
"Things get really exciting when you combine multiple samples being triggered w"
"ith different probabilities. For example:"
msgstr "複数のサンプルが異なる確率でトリガーされるのを組み合せると、本当に刺激的になります。例えば："

#: A.13-probabilistic-sequencer.md:96
#, no-wrap
msgid ""
"live_loop :multi_beat do\n"
"  sample :elec_hi_snare if one_in(6)\n"
"  sample :drum_cymbal_closed if one_in(2)\n"
"  sample :drum_cymbal_pedal if one_in(3)\n"
"  sample :bd_haus if one_in(4)\n"
"  sleep 0.125\n"
"end"
msgstr ""
"live_loop :multi_beat do\n"
"  sample :elec_hi_snare if one_in(6)\n"
"  sample :drum_cymbal_closed if one_in(2)\n"
"  sample :drum_cymbal_pedal if one_in(3)\n"
"  sample :bd_haus if one_in(4)\n"
"  sleep 0.125\n"
"end"

#: A.13-probabilistic-sequencer.md:106
msgid ""
"Again, run the code above and then start changing the probabilities to modify "
"the rhythm. Also, try changing the samples to create an entirely new feel. For"
" example try changing `:drum_cymbal_closed` to `:bass_hit_c` for extra bass!"
msgstr ""
"もう一度、上のコードを実行して、リズムを変更するために確率を変更してみてください。また、試しにサンプルを変更してみると、全く新しい感覚を生み出すでしょう。例"
"えば、低音を追加するために、試しに`:drum_cymbal_closed`を`:bass_hit_c`に変更してみてください！"

#: A.13-probabilistic-sequencer.md:112
msgid "Repeatable Rhythms"
msgstr "再現可能なリズム"

#: A.13-probabilistic-sequencer.md:114
msgid ""
"Next, we can use our old friend `use_random_seed` to reset the random stream a"
"fter 8 iterations to create a regular beat. Type the following code to hear a "
"much more regular and repeating rhythm. Once you hear the beat, try changing t"
"he seed value from `1000` to another number. Notice how different numbers gene"
"rate different beats."
msgstr ""
"次に、我々にはすっかりお馴染みの`use_random_seed`を使って、8回の繰り返しの後に、ランダム・ストリームをリセットすると、規則的なビートを作る"
"ことができます。次のコードをタイプして、より規則的で再現可能なリズムを聞いてみましょう。一度ビートを聞いたら、シードの値を`1000`から別なものにしてみま"
"しょう。異なる数字が異なるビートを生成することに注目してください。"

#: A.13-probabilistic-sequencer.md:120
#, no-wrap
msgid ""
"live_loop :multi_beat do\n"
"  use_random_seed 1000\n"
"  8.times do\n"
"    sample :elec_hi_snare if one_in(6)\n"
"    sample :drum_cymbal_closed if one_in(2)\n"
"    sample :drum_cymbal_pedal if one_in(3)\n"
"    sample :bd_haus if one_in(4)\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"live_loop :multi_beat do\n"
"  use_random_seed 1000\n"
"  8.times do\n"
"    sample :elec_hi_snare if one_in(6)\n"
"    sample :drum_cymbal_closed if one_in(2)\n"
"    sample :drum_cymbal_pedal if one_in(3)\n"
"    sample :bd_haus if one_in(4)\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: A.13-probabilistic-sequencer.md:133
msgid ""
"One thing I tend to do with this kind of structure is to remember which seeds "
"sound good and make a note of them. That way I can easily re-create my rhythms"
" in future practice sessions or performances."
msgstr ""
"この種の構造で私がよくやるのは、よい感じの音がしたらシードを記録しておくことです。それにより、後で練習したりパフォーマンスしたりするときに、簡単にそのリズム"
"を再生成することができます。"

#: A.13-probabilistic-sequencer.md:139
msgid ""
"Finally, we can throw in some random bass to give it some nice melodic content"
". Notice that we can also use our newly discovered probabilistic sequencing me"
"thod on synths just as well as samples. Don't leave it at that though - tweak "
"the numbers and make your own track with the power of probabilities!"
msgstr ""
"最後に、よい感じのメロディーを提供するランダムなベースを入れることができます。我々が新しく発見した確率的なシーケンスの方法は、サンプルと同じようにシンセに対"
"しても同様に使用可能です。このコードをそのままにせずに、数字を操作して、確率の力であなた自身のトラックを是非作ってください！"

#: A.13-probabilistic-sequencer.md:145
#, no-wrap
msgid ""
"live_loop :multi_beat do\n"
"  use_random_seed 2000\n"
"  8.times do\n"
"    c = rrand(70, 130)\n"
"    n = (scale :e1, :minor_pentatonic).take(3).choose\n"
"    synth :tb303, note: n, release: 0.1, cutoff: c if rand < 0.9\n"
"    sample :elec_hi_snare if one_in(6)\n"
"    sample :drum_cymbal_closed if one_in(2)\n"
"    sample :drum_cymbal_pedal if one_in(3)\n"
"    sample :bd_haus, amp: 1.5 if one_in(4)\n"
"    sleep 0.125\n"
"  end\n"
"end"
msgstr ""
"live_loop :multi_beat do\n"
"  use_random_seed 2000\n"
"  8.times do\n"
"    c = rrand(70, 130)\n"
"    n = (scale :e1, :minor_pentatonic).take(3).choose\n"
"    synth :tb303, note: n, release: 0.1, cutoff: c if rand < 0.9\n"
"    sample :elec_hi_snare if one_in(6)\n"
"    sample :drum_cymbal_closed if one_in(2)\n"
"    sample :drum_cymbal_pedal if one_in(3)\n"
"    sample :bd_haus, amp: 1.5 if one_in(4)\n"
"    sleep 0.125\n"
"  end\n"
"end"

#: A.14-amplitude-modulation.md:1
#, fuzzy
msgid "A.14 Amplitude Modulation"
msgstr "A.14 振幅変調"

#: A.14-amplitude-modulation.md:3
#, fuzzy
msgid "Amplitude Modulation"
msgstr "振幅変調"

#: A.14-amplitude-modulation.md:5
msgid ""
"This month we're going to take a deep dive into one of Sonic Pi's most powerfu"
"l and flexible audio FX - the `:slicer`. By the end of this article you will h"
"ave learned how to manipulate the overall volume of parts of our live coded so"
"und in powerful new ways. This will allow you to create new rhythmic and timbr"
"al structures and broaden your sonic possibilities."
msgstr ""
"今月は、Sonic Piで最もパワフルでフレキシブルなエフェクトの1つである、`:slicer`を深く見ていきたいと思います。この記事の終わりまでに、ライブ"
"コーディングされたサウンドの全体的な音量を操作する、新しいパワフルな方法を習得できるでしょう。これは、新しいリズム的・音色的な構造を生成することができ、また"
"音響的な可能性を広げることができるでしょう。"

#: A.14-amplitude-modulation.md:12
msgid "Slice that Amp"
msgstr "あの音量をスライスしよう"

#: A.14-amplitude-modulation.md:14
msgid ""
"So, what does the `:slicer` FX actually do? One way to think about it is that "
"it's just like having someone play around with the volume control on your TV o"
"r home hi-fi. Let's take a look but first, listen to the deep growl of the fol"
"lowing code which triggers the `:prophet` synth:"
msgstr ""
"実際のところ、`:slicer`エフェクトは何をやってるのでしょうか？ 誰かがテレビやオーディオ製品のボリュームコントロールで遊んでいるのと同じようなものと"
"考えてみるのも、1つの方法かもしれません。早速見ていきたいところですが、最初に`:prophet`をトリガーする次のコードの深い唸り声を聞いてみてください："

#: A.14-amplitude-modulation.md:20
#, no-wrap
msgid ""
"synth :prophet, note: :e1, release: 8, cutoff: 70\n"
"synth :prophet, note: :e1 + 4, release: 8, cutoff: 80"
msgstr ""
"synth :prophet, note: :e1, release: 8, cutoff: 70\n"
"synth :prophet, note: :e1 + 4, release: 8, cutoff: 80"

#: A.14-amplitude-modulation.md:25
msgid "Now, let's pipe it through the `:slicer` FX:"
msgstr "では、これを`:slicer`エフェクトに通してみましょう："

#: A.14-amplitude-modulation.md:27
#, no-wrap
msgid ""
"\n"
"with_fx :slicer do\n"
"  synth :prophet, note: :e1, release: 8, cutoff: 70\n"
"  synth :prophet, note: :e1 + 4, release: 8, cutoff: 80\n"
"end"
msgstr ""
"\n"
"with_fx :slicer do\n"
"  synth :prophet, note: :e1, release: 8, cutoff: 70\n"
"  synth :prophet, note: :e1 + 4, release: 8, cutoff: 80\n"
"end"

#: A.14-amplitude-modulation.md:35
msgid ""
"Hear how the slicer acts like it's muting and unmuting the audio with a regula"
"r beat. Also, notice how the `:slicer` affects all the audio generated between"
" the `do`/`end` blocks. You can control the speed at which it turns the audio "
"on and off with the `phase:` opt which is short for phase duration. Its defaul"
"t value is `0.25` which means 4 times a second at the default BPM of 60. Let's"
" make it faster:"
msgstr ""
"`:slicer`が規則的なビートで音をミュートしたりしなかったりするのを聞いてみてください。また、`:slicer`が`do`/`end`ブロックの中で生"
"成された全ての音に影響していることに注目してください。音のオン・オフの速さは、`phase duration`の短縮語である`phase:`オプションを使っ"
"てコントロールできます。`phase:`オプションのデフォルト値は`0.25`で、デフォルトのBPM60だと、1秒間に4回という意味になります。もっと速くし"
"てみましょう："

#: A.14-amplitude-modulation.md:42
#, no-wrap
msgid ""
"with_fx :slicer, phase: 0.125 do\n"
"  synth :prophet, note: :e1, release: 8, cutoff: 70\n"
"  synth :prophet, note: :e1 + 4, release: 8, cutoff: 80\n"
"end"
msgstr ""
"with_fx :slicer, phase: 0.125 do\n"
"  synth :prophet, note: :e1, release: 8, cutoff: 70\n"
"  synth :prophet, note: :e1 + 4, release: 8, cutoff: 80\n"
"end"

#: A.14-amplitude-modulation.md:49
msgid ""
"Now, play with different `phase:` durations yourself. Try longer and shorter v"
"alues. See what happens when you choose a really short value. Also, try differ"
"ent synths such as `:beep` or `:dsaw` and different notes. Take a look at the "
"following diagram to see how different `phase:` values change the number of am"
"plitude changes per beat."
msgstr ""
"では、異なる`phase:`の長さで遊んでみましょう。長い値や短い値を試してみましょう。本当に短い値を選んだら何が起こるか見てみてください。また、`:bee"
"p`や`:dsaw`といった異なるシンセや、異なる音符も試してみましょう。次の図で、異なる`phase:`の値が、1拍の間に音の大きさを変更する回数をどのよ"
"うに変化させるか見てみましょう。"

#: A.14-amplitude-modulation.md:56
#, fuzzy
msgid ""
"![Phase Durations](../../../etc/doc/images/tutorial/articles/A.14-amplitude-mo"
"dulation/slicer_phase_durations.png)"
msgstr ""
"![Phase Durations](../../../etc/doc/images/tutorial/articles/A.14-amplitude-mo"
"dulation/slicer_phase_durations.png)"

#: A.14-amplitude-modulation.md:58
msgid ""
"Phase duration is the length of time for one on/off cycle. Therefore smaller v"
"alues will make the FX switch on and off much faster than larger values. Good "
"values to start playing with are `0.125`, `0.25`, `0.5` and `1`."
msgstr ""
"`phase duration`は、オン・オフの周期の時間の長さを示してします。したがって、より小さい値はエフェクトのオン・オフをより早く切り替えます。はじ"
"めに試してみるのに良さそうな値は、`0.125`, `0.25`, `0.5`, `1`でしょう。"

#: A.14-amplitude-modulation.md:64
msgid "Control Waves"
msgstr "波形を操作する"

#: A.14-amplitude-modulation.md:66
msgid ""
"By default, the `:slicer` FX uses a square wave to manipulate the amplitude th"
"rough time. This is why we hear the amplitude on for a period, then immediatel"
"y off for a period, then back on again. It turns out that the square wave is j"
"ust one of 4 different control waves that are supported by `:slicer`. The othe"
"rs are saw, triangle and (co)sine. Take a look at the diagram below to see wha"
"t these look like. We can also hear what they sound like. For example, the fol"
"lowing code uses (co)sine as the control wave. Hear how the sound doesn't turn"
" on and off abruptly but instead smoothly fades in and out:"
msgstr ""
"デフォルトでは、`:slicer`エフェクトは音の大きさを操作するのに矩形波を使っています。一定時間音量がオンで聞こえてその後急にオフになるのは、これが理由"
"です。矩形波は、`:slicer`がサポートしている4つの制御波形の1つであることが分かるでしょう。それ以外のものは、ノコギリ波、三角波、正弦波（または余弦"
"波）です。下の図はそれぞれがどのような形をしているか示しています。また、それがどのような音がするのか聴くこともできます。例えば、次のコードは正弦波（または余"
"弦波）を制御波形として使用しています。音が急にオン・オフせずにスムーズにフェードイン・フェードアウトするのを聴いてみてください。"

#: A.14-amplitude-modulation.md:76
#, no-wrap
msgid ""
"with_fx :slicer, phase: 0.5, wave: 3 do\n"
"  synth :dsaw, note: :e3, release: 8, cutoff: 120\n"
"  synth :dsaw, note: :e2, release: 8, cutoff: 100\n"
"end"
msgstr ""
"with_fx :slicer, phase: 0.5, wave: 3 do\n"
"  synth :dsaw, note: :e3, release: 8, cutoff: 120\n"
"  synth :dsaw, note: :e2, release: 8, cutoff: 100\n"
"end"

#: A.14-amplitude-modulation.md:83
msgid ""
"Have a play with the different wave forms by changing the `wave:` opt to `0` f"
"or saw, `1` for square, `2` for triangle and `3` for sine. See how different w"
"aves sound with different `phase:` opts too."
msgstr ""
"`wave:`オプションを変更することで、異なる波形で演奏してみましょう。`0`がノコギリ波、`1`が矩形波、`2`が三角波で、`3`が正弦波です。 また、"
"異なる`phase:`オプションを組み合わせて、それぞれの波形がどのような音がするか試してみましょう。"

#: A.14-amplitude-modulation.md:87
msgid ""
"Each of these waves can be inverted with the `invert_wave:` opt which flips it"
" on the y axis. For example, in a single phase the saw wave typically starts h"
"igh, and slowly goes down before jumping back to the top. With `invert_wave: 1"
"` it will start low and slowly go up before jumping back down again. Additiona"
"lly, the control wave can be started at different points with the `phase_offse"
"t:` opt which should be a value between `0` and `1`. By playing around with `p"
"hase:`, `wave:`, `invert_wave:` and `phase_offset` opts you can dramatically c"
"hange how the amplitude is modified through time."
msgstr ""
"これらの波形は、`invert_wave:`オプションでy軸方向に反転させることができます。例えば、典型的なノコギリ波は、高い値から始まり、徐々に値が下がっ"
"ていって、ある時点で元の高い値に戻ります。`invert_wave: 1`を指定することで、低い値から始まり、徐々に値が上がっていって、ある時点で元の低い値"
"に戻るようになります。また、波形操作は、`phase_offset:`オプションに`0`から`1`の値を指定することにより、波形の任意の位相から開始すること"
"ができます。`phase:`, `wave:`, `invert_wave:`と`phase_offset`オプションを変更することで、時間に沿って音量をど"
"れだけ変化させるかを、劇的に変更することができます。"

#: A.14-amplitude-modulation.md:97
#, fuzzy
msgid ""
"![Phase Durations](../../../etc/doc/images/tutorial/articles/A.14-amplitude-mo"
"dulation/slicer_control_waves.png)"
msgstr ""
"![Phase Durations](../../../etc/doc/images/tutorial/articles/A.14-amplitude-mo"
"dulation/slicer_control_waves.png)"

#: A.14-amplitude-modulation.md:100
msgid "Setting your levels"
msgstr "音量を設定する"

#: A.14-amplitude-modulation.md:102
msgid ""
"By default, `:slicer` switches between amplitude values `1` (fully loud) and `"
"0` (silent). This can be changed with the `amp_min:` and `amp_max:` opts. You "
"can use this alongside the sine wave setting to create a simple tremolo effect"
":"
msgstr ""
"デフォルトでは、`:slicer`エフェクトは`1`（最大）と`0`（無音）の間の音量を切り替えます。これは、`amp_min:`と`amp_max:`オプ"
"ションで変更できます。これを正弦波の設定に適用することで、シンプルなトレモロ効果を作ることができます："

#: A.14-amplitude-modulation.md:107
#, no-wrap
msgid ""
"with_fx :slicer, amp_min: 0.25, amp_max: 0.75, wave: 3, phase: 0.25 do\n"
"  synth :saw, release: 8\n"
"end"
msgstr ""
"with_fx :slicer, amp_min: 0.25, amp_max: 0.75, wave: 3, phase: 0.25 do\n"
"  synth :saw, release: 8\n"
"end"

#: A.14-amplitude-modulation.md:113
msgid ""
"This is just like grabbing the volume knob on your hi-fi and moving it up and "
"down just a little so the sound 'wobbles' in and out."
msgstr "これはちょうど、オーディオ機器のボリュームつまみをひねって、音を`グラグラ`させるのに似ています。"

#: A.14-amplitude-modulation.md:117
msgid "Probabilities"
msgstr "確率"

#: A.14-amplitude-modulation.md:119
msgid ""
"One of `:slicer`'s powerful features is its ability to use probability to choo"
"se whether or not to turn the slicer on or off. Before the `:slicer` FX starts"
" a new phase it rolls a dice and based on the result either uses the selected "
"control wave or keeps the amplitude off. Let's take a listen:"
msgstr ""
"`:slicer`エフェクトのパワフルな特長の1つは、スライサーをオン・オフするかしないかを選択するのに、確率を使用可能なことでしょう。`:slicer`エ"
"フェクトが次の位相を開始する前にサイコロを振って、その結果をもとに選択した波形を使うかもしくは音量をオフにしたままにするかします。聞いてみましょう："

#: A.14-amplitude-modulation.md:125
#, no-wrap
msgid ""
"with_fx :slicer, phase: 0.125, probability: 0.6  do\n"
"  synth :tb303, note: :e1, cutoff_attack: 8, release: 8\n"
"  synth :tb303, note: :e2, cutoff_attack: 4, release: 8\n"
"  synth :tb303, note: :e3, cutoff_attack: 2, release: 8\n"
"end"
msgstr ""
"with_fx :slicer, phase: 0.125, probability: 0.6  do\n"
"  synth :tb303, note: :e1, cutoff_attack: 8, release: 8\n"
"  synth :tb303, note: :e2, cutoff_attack: 4, release: 8\n"
"  synth :tb303, note: :e3, cutoff_attack: 2, release: 8\n"
"end"

#: A.14-amplitude-modulation.md:133
msgid ""
"Hear how we now have an interesting rhythm of pulses. Try changing the `probab"
"ility:` opt to a different value between `0` and `1`. Values closer to `0` wil"
"l have more space between each sound due to the likelihood of the sound being "
"triggered being much lower."
msgstr ""
"興味深いパルスのリズムを生成できたのを聞くことができるでしょう。試しに、`probability:`オプションを`0`から`1`の間の値に変更してみましょう"
"。`0`に近い値にすると、音がトリガーされる確率がより低くなるため、それぞれの音の間が広がるでしょう。"

#: A.14-amplitude-modulation.md:138
msgid ""
"Another thing to notice is that the probability system in the FX is just like "
"the randomisation system accessible via fns such as `rand` and `shuffle`. They"
" are both completely deterministic. This means that each time you hit Run you'"
"ll hear exactly the same rhythm of pulses for a given probability. If you woul"
"d like to change things around you can use the `seed:` opt to select a differe"
"nt starting seed. This works exactly the same as `use_random_seed` but only af"
"fects that particular FX."
msgstr ""
"他にお伝えしたいのは、`:slice`エフェクトにおけるランダム化システムは、`rand`や`shuffle`といった関数経由でアクセス可能なランダム化シス"
"テムとちょうど同じであるということです。これらはどちらも完全に決定的です。これは`Run`を叩いたときに、指定された確率に対応して毎回同じパルスのリズムを聞"
"くことになることを意味しています。これらを変更したい場合には、`seed:`オプションを使って異なるシードを選択することが可能です。これは`use_rand"
"om_seed`と全く同じように動作しますが、特定のエフェクトにのみ影響します。"

#: A.14-amplitude-modulation.md:146
msgid ""
"Finally, you can change the 'resting' position of the control wave when the pr"
"obability test fails from `0` to any other position with the `prob_pos:` opt:"
msgstr "最後に、確率的にオフになった場合に制御波形内の'休止する'位置を、`prob_pos:`オプションを使って`0`から他の値に変更できます："

#: A.14-amplitude-modulation.md:150
#, no-wrap
msgid ""
"with_fx :slicer, phase: 0.125, probability: 0.6, prob_pos: 1  do\n"
"  synth :tb303, note: :e1, cutoff_attack: 8, release: 8\n"
"  synth :tb303, note: :e2, cutoff_attack: 4, release: 8\n"
"  synth :tb303, note: :e3, cutoff_attack: 2, release: 8\n"
"end"
msgstr ""
"with_fx :slicer, phase: 0.125, probability: 0.6, prob_pos: 1  do\n"
"  synth :tb303, note: :e1, cutoff_attack: 8, release: 8\n"
"  synth :tb303, note: :e2, cutoff_attack: 4, release: 8\n"
"  synth :tb303, note: :e3, cutoff_attack: 2, release: 8\n"
"end"

#: A.14-amplitude-modulation.md:158
msgid "Slicing Beats"
msgstr "ビートをスライスする"

#: A.14-amplitude-modulation.md:160
msgid "One really fun thing to do is to use `:slicer` to chop a drum beat in and out:"
msgstr "`:slicer`エフェクトでドラムビートをブツ切りするのは、やってみると本当に楽しいことの1つです："

#: A.14-amplitude-modulation.md:163
#, no-wrap
msgid ""
"with_fx :slicer, phase: 0.125 do\n"
"  sample :loop_mika\n"
"end"
msgstr ""
"with_fx :slicer, phase: 0.125 do\n"
"  sample :loop_mika\n"
"end"

#: A.14-amplitude-modulation.md:169
msgid ""
"This allows us to take any sample and create new rhythmical possibilites which"
" is a lot of fun. However, one thing to be careful about is to make sure that "
"the tempo of the sample matches the current BPM in Sonic Pi otherwise the slic"
"ing will sound totally off. For example, try swapping `:loop_mika` with the `l"
"oop_amen` sample to hear how bad this can sound when the tempos don't align."
msgstr ""
"これにより、任意のサンプル音源から新しいリズムの可能性を作り出すことができ、とても楽しいでしょう。しかしながら、1つ注意すべきことは、サンプルのテンポがSo"
"nic PiのカレントのBPMに合うようにすることです。そうでないと、スライスは全くの無音にしてしまうかもしれません。たとえば、`:loop_mika`を`"
"loop_amen`サンプルに変更してみて、テンポが揃ってない場合にどれだけひどい音になるか聞いてみましょう。"

#: A.14-amplitude-modulation.md:176
msgid "Changing tempo"
msgstr "テンポを変更する"

#: A.14-amplitude-modulation.md:178
msgid ""
"As we have already seen, changing the default BPM with `use_bpm` will make all"
" the sleep times and synth envelope durations grow or shrink to match the beat"
". The `:slicer` FX honours this too, as the `phase:` opt is actually measured "
"in beats not seconds. We can therefore fix the issue with `loop_amen` above by"
" changing the BPM to match the sample:"
msgstr ""
"既に見てきたように、`use_bpm`でデフォルトのBPMを変更すると、全てのsleepの長さとシンセのエンベロープの長さがビートに一致するように伸縮されま"
"す。`:slicer`エフェクトの`phase:`オプションな実際には秒単位でなく拍単位なので、同じようにこれを受け入れることができます。したがって、BPM"
"を変更してサンプルに一致させることで、上の`loop_amen`の問題を解決できます。"

#: A.14-amplitude-modulation.md:184
#, no-wrap
msgid ""
"use_sample_bpm :loop_amen\n"
"with_fx :slicer, phase: 0.125 do\n"
"  sample :loop_amen\n"
"end"
msgstr ""
"use_sample_bpm :loop_amen\n"
"with_fx :slicer, phase: 0.125 do\n"
"  sample :loop_amen\n"
"end"

#: A.14-amplitude-modulation.md:194
msgid ""
"Let's apply all these ideas into a final example that only uses the `:slicer` "
"FX to create an interesting combination. Go ahead, start changing it and make "
"it into your own piece!"
msgstr ""
"最後に、これらのアイデアを全て適用して1つの例にしましょう。`:slicer`エフェクトのみを使って、興味深い組み合わせを作り出してみましょう。ここから変更"
"して自分自身の作品にしてみましょう！"

#: A.14-amplitude-modulation.md:198
#, no-wrap
msgid ""
"live_loop :dark_mist do\n"
"  co = (line 70, 130, steps: 8).tick\n"
"  with_fx :slicer, probability: 0.7, prob_pos: 1 do\n"
"    synth :prophet, note: :e1, release: 8, cutoff: co\n"
"  end\n"
"  \n"
"  with_fx :slicer, phase: [0.125, 0.25].choose do\n"
"    sample :guit_em9, rate: 0.5\n"
"  end\n"
"  sleep 8\n"
"end\n"
"live_loop :crashing_waves do\n"
"  with_fx :slicer, wave: 0, phase: 0.25 do\n"
"    sample :loop_mika, rate: 0.5\n"
"  end\n"
"  sleep 16\n"
"end"
msgstr ""
"live_loop :dark_mist do\n"
"  co = (line 70, 130, steps: 8).tick\n"
"  with_fx :slicer, probability: 0.7, prob_pos: 1 do\n"
"    synth :prophet, note: :e1, release: 8, cutoff: co\n"
"  end\n"
"  \n"
"  with_fx :slicer, phase: [0.125, 0.25].choose do\n"
"    sample :guit_em9, rate: 0.5\n"
"  end\n"
"  sleep 8\n"
"end\n"
"live_loop :crashing_waves do\n"
"  with_fx :slicer, wave: 0, phase: 0.25 do\n"
"    sample :loop_mika, rate: 0.5\n"
"  end\n"
"  sleep 16\n"
"end"

#: A.15-performance.md:1
msgid "A.15 Five Live Coding Techniques"
msgstr "A.15 ライブコーディング5つのテクニック"

#: A.15-performance.md:3
msgid "Five Live Coding Techniques"
msgstr "ライブコーディング5つのテクニック"

#: A.15-performance.md:5
msgid ""
"In this month's Sonic Pi tutorial we're going to take a look at how you can st"
"art treating Sonic Pi like a real instrument. We therefore need to start think"
"ing of code in a completely different way. Live coders think of code in a simi"
"lar way to how violinists think of their bow. In fact, just like a violinist c"
"an apply various bowing techniques to create different sounds (long slow motio"
"ns vs short fast hits) we will explore five of the basic live coding technique"
"s that Sonic Pi enables. By the end of this article you'll be able to start pr"
"acticing for your own live coded performances."
msgstr ""
"今月のチュートリアルでは、Sonic Piを本物の楽器と同じように扱う方法を見ていきたいと思います。そのため、コードについて今までと全く異なる見方で考える必"
"要があります。ライブコーダーはコードを、バイオリニストにとっての弓と同じように考えています。実際、バイオリニストが異なる音を作るのに様々な弓のテクニックを適"
"用する（長くゆっくりとした動きと短く速い打弦）のとちょうど同じように、Sonic Piで可能な基本的なライブコーディングのテクニックを5つ見ていきます。この"
"記事の終わりまでに、あなたはライブコーディングのパフォーマンスの練習を始めることが出来ているでしょう。"

#: A.15-performance.md:15
msgid "1. Memorise the Shortcuts"
msgstr "1. ショートカットを覚える"

#: A.15-performance.md:17
msgid ""
"The first tip to live coding with Sonic Pi is to start using the shortcuts. Fo"
"r example, instead of wasting valuable time reaching for the mouse, moving it "
"over to the Run button and clicking, you can simply press `alt` and `r` at the"
" same time which is much faster and keeps your fingers at the keyboard ready f"
"or the next edit. You can find out the shortcuts for the main buttons at the t"
"op by hovering the mouse over them. See section 10.2 of the built-in tutorial "
"for the full list of shortcuts."
msgstr ""
"Sonic Piでライブコーディングする際の最初のヒントは、ショートカットを使うことです。例えば、マウスに手を伸ばして`Run`ボタンに合わせてクリックする"
"のに貴重な時間を無駄にするよりも、単に`alt`と`r`を同時に押すことが可能です。これは速いし、指がキーボードに置かれたままなので、次の編集のための準備が"
"整っています。ショートカットを探すには、画面上部のボタンにそれぞれマウスを乗せると表示されます。ショートカットの一覧を見るには、チュートリアルの10.2を参"
"照してください。"

#: A.15-performance.md:26
msgid ""
"When performing, one fun thing to do is to add a bit of flair with your arm mo"
"tion when hitting shortcuts. For example, it's often good to communicate to th"
"e audience when you're about to make a change - so embellish your movement whe"
"n hitting `alt-r` just like a guitarist would do when hitting a big power chor"
"d."
msgstr ""
"パフォーマンスの際、1つやってみると面白いのは、ショートカットを叩くときの動作に少し装飾を追加してみることです。例えば、あなたが音を変更しようとするときにそ"
"れを観客に伝えるのは良いことです。したがって、`alt-r`を叩く際の動作を飾るのはギタリストがパワーコードを掻き鳴らすのとちょうど同じことなのです。"

#: A.15-performance.md:32
msgid "2. Manually Layer your Sounds"
msgstr "2. 手動で音を重ねる"

#: A.15-performance.md:34
msgid ""
"Now you can trigger code instantly with the keyboard, you can instantly apply "
"this skill for our second technique which is to layer your sounds manually. In"
"stead of 'composing' using lots of calls to `play`, and `sample` separated by "
"calls to `sleep` we will have one call to `play` which we will manually trigge"
"r using `alt-r`. Let's try it. Type the following code into a fresh buffer:"
msgstr ""
"コードをキーボードから素早く実行できるようになったら、そのスキルは、手動で音を重ねる2つめのテクニックに適用できます。たくさんの`play`と`sample"
"`の呼び出しを`sleep`で挟んで'作曲'する代わりに、1つの`play`の呼び出しを`alt-r`で手動で実行してみたいと思います。では試してみましょう"
"。次のコードを新しいBufferにタイプしてみてください："

#: A.15-performance.md:41
#, no-wrap
msgid "synth :tb303, note: :e2 - 0, release: 12, cutoff: 90"
msgstr "synth :tb303, note: :e2 - 0, release: 12, cutoff: 90"

#: A.15-performance.md:46
msgid ""
"Now, hit `Run` and whilst the sound is playing, modify the code in order to dr"
"op down four notes by changing it to the following:"
msgstr "タイプしたら、`Run`を叩いて音を出してみてください。音が出ている間に、次のコードのように、4音下げるためにコードを変更してください："

#: A.15-performance.md:50
#, no-wrap
msgid "synth :tb303, note: :e2 - 4, release: 12, cutoff: 90"
msgstr "synth :tb303, note: :e2 - 4, release: 12, cutoff: 90"

#: A.15-performance.md:55
msgid ""
"Now, hit `Run` again, to hear both sounds playing at the same time. This is be"
"cause Sonic Pi's `Run` button doesn't wait for any previous code to finish, bu"
"t instead starts the code running at the same time. This means you can easily "
"layer lots of sounds manually with minor or major modifications between each t"
"rigger. For example, try changing both the `note:` and the `cutoff:` opts and "
"then re-trigger."
msgstr ""
"では、再度`Run`を叩いてみてください。両方の音がそのまま再生されているが聞こえると思います。これは、Sonic Piの`Run`が前回実行したコードが終"
"わるのを待つたずに、新しいコードを開始するためです。これは、実行の度に多少の変更を加えることで、簡単にたくさんの音を重ねることが可能ということです。例えば、"
"`note:`と`cutoff:`オプションの両方を変更して、再度実行してみてください。"

#: A.15-performance.md:63
msgid "You can also try this technique with long abstract samples. For example:"
msgstr "また、このテクニックは長いアブストラクトなサンプルでも試すことができます。例えば、次のコードです："

#: A.15-performance.md:65
#, no-wrap
msgid "sample :ambi_lunar_land, rate: 1"
msgstr "sample :ambi_lunar_land, rate: 1"

#: A.15-performance.md:69
msgid ""
"Try starting the sample off, and then progressively halving the `rate:` opt be"
"tween hitting `Run` from `1` to `0.5` to `0.25` to `0.125` and then even try s"
"ome negative values such as `-0.5`. Layer the sounds together and see where yo"
"u can take it. Finally, try adding some FX."
msgstr ""
"最初はサンプル無しで始めて、`Run`を叩く度に、`rate:`オプションを`1`から`0.5`, `0.25`, `0.125`に変更し、さらに`-0.5"
"`のような負の値も試してみましょう。音を重ね合わせてどう聞こえるか試してみてください。最後に何かエフェクトを追加してみてください。"

#: A.15-performance.md:74
msgid ""
"When performing, working with simple lines of code in this way means that an a"
"udience new to Sonic Pi has a good chance to follow what you're doing and rela"
"te the code that they can read to the sounds they are hearing."
msgstr ""
"パフォーマンスの際にこのようなシンプルなコードを使用すると、Sonic Piにあまり馴染みのない観客にとっては、あなたが何をしているのかを追ったり、コードと"
"音を関連付けたりするのに良い機会になると言えるでしょう。"

#: A.15-performance.md:80
msgid "3. Master Live Loops"
msgstr "3. ライブループをマスターする"

#: A.15-performance.md:82
msgid ""
"When working with more rhythmic music, it can often be hard to manually trigge"
"r everything and keep good time. Instead, it is often better to use a `live_lo"
"op`. This provides repetition for your code whilst also giving the ability to "
"edit the code for the next time round the loop. They also will run at the same"
" time as other `live_loop`s which means you can layer them together both with "
"each other and manual code triggers. Take a look at section 9.2 of the built-i"
"n tutorial for more information about working with live loops."
msgstr ""
"もっとリズミカルな音楽の場合、全てを手動で実行しながら良いタイミングを保つのは難しいでしょう。その場合は、`live_loop`を使うのが良いでしょう。これ"
"はコードを繰り返しつつ、次にループが先頭に戻ったときに実行されるように、コードを編集できる機能を提供しています。また、ライブループは他の`live_loop"
"`と同時に実行でき、それはすなわち、ライブループ同士を重ねたり、他に手動で実行したコードと重ねたりすることが可能ということです。ライブループに関するより詳細"
"な情報については、チュートリアルの9.2を参照してください。"

#: A.15-performance.md:91
msgid ""
"When performing, remember to make use of `live_loop`'s `sync:` opt to allow yo"
"u to recover from accidental runtime mistakes which stop the live loop running"
" due to an error. If you already have the `sync:` opt pointing to another vali"
"d `live_loop`, then you can quickly fix the error and re-run the code to re-st"
"art things without missing a beat."
msgstr ""
"パフォーマンスの際には、`live_loop`の`sync:`を使うことを覚えておくと良いでしょう。これは、エラーによってライブループの実行が止まってしまっ"
"た場合の回復手段として役に立ちます。もし既に`sync:`が他の正常に動作している`live_loop`を指しているのであれば、エラーをすぐに修正してコード"
"を再実行することで、ビートが欠いた状態を解消して再起動できるでしょう。"

#: A.15-performance.md:97
#, fuzzy
msgid "4. Use the Main Mixer"
msgstr "4. マスターミキサーを使う"

#: A.15-performance.md:99
#, fuzzy
msgid ""
"One of Sonic Pi's best kept secrets is that it has a main mixer through which "
"all sound flows. This mixer has both a low pass filter and a high pass filter "
"built-in, so you can easily perform global modifications to the sound. The mai"
"n mixer's functionality can be accessed via the fn `set_mixer_control!`. For e"
"xample, whilst some code is running and making sound, enter this into a spare "
"buffer and hit `Run`:"
msgstr ""
"Sonic Piの最高の秘密の1つは、全ての音が流れるマスターミキサーを持っていることです。そしてこのミキサーはローパスフィルタとハイパスフィルタを内蔵して"
"いるので、簡単に音全体を変更できます。マスターミキサーの機能は、`set_mixer_control!`関数によりアクセス可能です。例えば、何かコードが実行"
"中で音を出している最中に、次のコードを空いたBufferに入力して`Run`を叩いてみてください："

#: A.15-performance.md:107
msgid "` set_mixer_control! lpf: 50 `"
msgstr "` set_mixer_control! lpf: 50 `"

#: A.15-performance.md:111
msgid ""
"After you run this code, all existing and new sounds will have a low pass filt"
"er applied to them and will therefore sound more muffled. Note that this means"
" that the new mixer values stick until they are changed again. However, if you"
" want, you can always reset the mixer back to its default state with `reset_mi"
"xer!`. Some of the currently supported opts are: `pre_amp:`, `lpf:` `hpf:`, an"
"d `amp:`. For the full list, see the built-in docs for `set_mixer_control!`."
msgstr ""
"このコードの実行後、既に出ている音とこれから出てくる音の全てにローパスフィルタが適用されるので、ぼんやりとした音になります。これは、先程のコードで設定された"
"ミキサーの値が、再び変更されるまで保持されることを意味しています。しかし、もし値をリセットしたい場合には、`reset_mixer!`でいつでもデフォルトの"
"状態に戻すことができます。現在対応しているオプションには、`pre_amp:`, `lpf:`, `hpf:`,`amp:`があります。全てのオプションの一"
"覧については、`set_mixer_control!`のドキュメントを参照してください。"

#: A.15-performance.md:119
msgid ""
"Use the mixer's `*_slide` opts to slide one or many opts values over time. For"
" example, to slowly slide the mixer's low pass filter down from the current va"
"lue to 30, use the following:"
msgstr ""
"オプションの値を時間に沿ってスライドさせるために、ミキサーの`*_slide`オプションを使ってみましょう。例えば、ミキサーのローパスフィルタを現在の値から"
"30にゆっくりスライドさせるには、次のコードを使ってみてください："

#: A.15-performance.md:123
#, no-wrap
msgid "set_mixer_control! lpf_slide: 16, lpf: 30"
msgstr "set_mixer_control! lpf_slide: 16, lpf: 30"

#: A.15-performance.md:127
msgid "You can then slide quickly back to a high value with:"
msgstr "次に、高い値に素早くスライドして戻すこともできます："

#: A.15-performance.md:129
#, no-wrap
msgid "set_mixer_control! lpf_slide: 1, lpf: 130"
msgstr "set_mixer_control! lpf_slide: 1, lpf: 130"

#: A.15-performance.md:133
msgid ""
"When performing, it's often useful to keep a buffer free for working with the "
"mixer like this."
msgstr "パフォーマンスの際には、ここでやったようにミキサーのためのBufferを空けておくと便利でしょう。"

#: A.15-performance.md:136
msgid "5. Practice"
msgstr "5. 練習"

#: A.15-performance.md:138
msgid ""
"The most important technique for live coding is practice. The most common attr"
"ibute across professional musicians of all kinds is that they practice playing"
" with their instruments - often for many hours a day. Practice is just as impo"
"rtant for a live coder as a guitarist. Practice allows your fingers to memoris"
"e certain patterns and common edits so you can type and work with them more fl"
"uently. Practice also gives you opportunities to explore new sounds and code c"
"onstructs."
msgstr ""
"ライブコーディングの最も重要なテクニックは練習です。すべてのプロのミュージシャンに共通する点は、自分の楽器を練習することです。多くの場合、1日に何時間も練習"
"しています。ギタリストと同じようにライブコーダーにとっても練習は重要です。練習によってあなたの指は特定のパターンや一般的な編集内容を覚えるので、入力や作業が"
"よりスムーズに行えます。練習はまた、新しい音やコード構成を探求する機会をあなたに提供します。"

#: A.15-performance.md:146
msgid ""
"When performing, you'll find the more practice you do, the easier it will be f"
"or you to relax into the gig. Practice will also give you a wealth of experien"
"ce to draw from. This can help you understand which kinds of modifications wil"
"l be interesting and also work well with the current sounds."
msgstr ""
"パフォーマンスの際には、やってきた練習が多ければ多いほど、緊張せずにライブに入ることが簡単になると気づくでしょう。練習はまたそこから豊富な経験を提供するでし"
"ょう。それにより、どんな種類の変更が面白く、また現在の音に上手く作用するか分かるようになるでしょう。"

#: A.15-performance.md:154
#, fuzzy
msgid ""
"This month, instead of giving you a final example that combines all the things"
" discussed, let's part by setting down a challenge. See if you can spend a wee"
"k practicing one of these ideas every day. For example, one day practice manua"
"l triggers, the next do some basic `live_loop` work and the following day play"
" around with the main mixer. Then repeat. Don't worry if things feel slow and "
"clunky at first - just keep practicing and before you know it you'll be live c"
"oding for a real audience."
msgstr ""
"今月は、全てを組み合わせた例を示す代わりに、課題を設定してお別れにしましょう。今回紹介したアイデアを毎日1つ選んで練習して1週間を過ごせるか試してみてくださ"
"い。例えば、ある日は手動の実行を練習し、その次の日は`live_loop`の基本的な作業をやってみて、その次の日はマスターミキサーで遊んでみます。そしてそれ"
"を繰り返します。最初は、全てがゆっくりで不器用に感じられるかもしれませんが、心配しないでください。ただ練習を継続すれば、あなたの知らないうちに実際の聴衆の前"
"でライブコーディングできるようになっているでしょう。"

#: A.16-practice.md:1
msgid "A.16 How to Practice Live Coding"
msgstr "A.16 ライブコーディングの練習方法"

#: A.16-practice.md:3
msgid "8 Tips for Live Coding Practice"
msgstr "ライブコーディング練習の8つのヒント"

#: A.16-practice.md:5
msgid ""
"Last month we took a look at five important techniques for mastering live codi"
"ng - in other words, we explored how we could use Sonic Pi to approach code in"
" the same way we would approach a musical instrument. One of the important con"
"cepts that we discussed was practice. This month we're going to take a deeper "
"dive into understanding why live coding practice is important and how you migh"
"t start."
msgstr ""
"先月は、ライブコーディングをマスターするための5つの重要なテクニックを見ました。言い換えると、楽器と同じようなやり方でコードに接するために、どのようにSon"
"ic Piを使うことができるか探求しました。そして、我々が議論した重要なコンセプトの1つに、練習がありました。今月は、なぜライブコーディングの練習が重要で、"
"それをどのように始めるかについて、理解を深めて行きたいと思います。"

#: A.16-practice.md:13
msgid "Practice regularly"
msgstr "定期的に練習しよう"

#: A.16-practice.md:15
msgid ""
"The most important piece of advice is to make sure you practice regularly. As "
"a rule I typically practice for 1-2 hours a day, but 20 mins is just fine when"
" you're starting out. Little but often is what you're aiming for - so if you c"
"an only manage 10 minutes, that's a great start."
msgstr ""
"最も重要なアドバイスとしては、必ず定期的に練習することです。私自身は1日1-2時間練習するようにしていますが、最初は20分でもよいでしょう。少しの時間でも頻"
"繁に練習することを目標にしましょう。もし10分しか捻出できなかったとしても、良いスタートになります。"

#: A.16-practice.md:21
msgid ""
"Practice tip #1 - start to develop a practice routine. Find a nice time in the"
" day that works for you and try and practice at that time as many days of the "
"week as you can. Before long you'll be looking forward to your regular session"
"."
msgstr ""
"練習のヒント #1 - 練習ルーチンを開発する。あなたにとって都合の良い時間を見つけて、週のうち可能な限り多くの日にその時間で練習するようにしてみましょう。"
"いずれ定期的なセッションが楽しみになると思います。"

#: A.16-practice.md:27
msgid "Learn to Touch Type"
msgstr "ブラインドタッチを習得する"

#: A.16-practice.md:29
msgid ""
"If you watch a professional musician performing on stage you'll likely notice "
"a few things. Firstly, when they play they don't stare at their instrument. Th"
"eir fingers, arms and bodies know which keys to press, strings to pluck or dru"
"ms to hit without them having to think about it too much. This is known as \"mu"
"scle memory\" and although it might sound like something only professionals can"
" do - it's just the same as when you first learned to walk or ride a bike - pr"
"acticing through repetition. Live coders use muscle memory to free their minds"
" from having to think about where to move their fingers so they can focus on t"
"he music. This is called touch-typing - typing without having to look at the k"
"eyboard."
msgstr ""
"ステージで演奏するプロのミュージシャンを見ると、いくつか気が付くことがあると思います。最初に、彼らが演奏するとき楽器を凝視することはないでしょう。指と腕と体"
"が、どのキーを押すか、どの弦を弾くか、どのドラムを叩くかを、深く考えること無く覚えていると思います。これは\"運動記憶\"として知られているもので、プロの人達だ"
"けが出来ることのように聞こえるかもしれませんが、あなたが繰り返し練習して歩いたり自転車に乗ったりできるようになったことと同じです。ライブコーダーはどこに指を"
"動かせば良いか考えずに済むように運動記憶を使い、それによって音楽に集中するのです。これはブラインドタッチと呼ばれるもので、キーボードを見ることなくタイプする"
"ことです。"

#: A.16-practice.md:41
msgid ""
"Practice tip #2 - learn how to touch type. There are many apps, websites and e"
"ven games which can help you achieve this. Find one you like the look of and s"
"tick at it until you can code without looking down."
msgstr ""
"練習のヒント #2 - ブラインドタッチを習得する。ブラインドタッチを習得するためのアプリケション、ウェブサイト、さらにはゲームが数多くあります。どれか好き"
"なものを探して、キーボードを見ずにコーディングできるまで続けてみましょう。"

#: A.16-practice.md:46
msgid "Code whilst standing"
msgstr "立ったままコーディングする"

#: A.16-practice.md:48
msgid ""
"The body of a musician is conditioned for playing their instrument. For exampl"
"e, a trumpet player needs to be able to blow hard, a guitar player needs to be"
" able to grip the fretboard with strength and a drummer needs to be able to co"
"ntinually hit the drums for long periods of time. So, what's physical about li"
"ve coding? Just like DJs, live coders typically perform whilst standing up and"
" some even dance whilst they code! If you practice live coding whilst sitting "
"at a desk and then have to get up and stand at a gig, you'll likely find the d"
"ifference very difficult and frustrating."
msgstr ""
"ミュージシャンの体は、それぞれの楽器を演奏するように調整されています。例えば、トランペット奏者は強く吹ける必要がありますし、ギタープレイヤーはフレットを強く"
"握れる必要がありますし、ドラマーは長い時間繰り返し叩くことができる必要があります。では、ライブコーディングではどうでしょうか？ ライブコーダーは典型的にはD"
"Jのように立ちながらパフォーマンスします。さらには踊りながらということさえあります。ライブコーディングを座ったままで練習して、ライブの際に立たなければならな"
"い場合、その違いがとても難しくイライラさせるでしょう。"

#: A.16-practice.md:58
msgid ""
"Practice tip #3 - stand whilst you practice. The easiest way to do this is to "
"use a standing height desk. However, if like me you don't have one at home, th"
"ere's a couple of low-fi options. The approach I take is to use an ironing boa"
"rd which happens to work rather well. Another is to stack some boxes or large "
"books on a normal desk and place your keyboard on top of that. Also, make sure"
" you stretch before you start practicing and try and dance a little during the"
" session. Remember, nobody is watching you, so have fun and you'll feel much m"
"ore natural on stage."
msgstr ""
"練習のヒント #3 - 立って練習する。これを実現するのに最も簡単な方法は、スタンディングデスクを使うことです。しかし、もしスタンディングデスクが家に無い場"
"合にも、いくつかローファイな選択肢があります。私はアイロン台を使っていますが、意外に使いやすいです。他にも何かの箱や大きい本を普通の机に置いて、その上にキー"
"ボードを置くこともできます。また、練習前にストレッチしておいたり、セッション中に少し踊ってみたりするのもよいでしょう。誰も見ていないので、楽しんでやってみま"
"しょう。そうすれば、ステージで緊張しなくなるでしょう。"

#: A.16-practice.md:68
msgid "Practice setting up"
msgstr "準備の練習"

#: A.16-practice.md:70
msgid ""
"Most instruments require some assembly and tuning before they can be played. U"
"nless you're a rockstar with a bus full of roadies, you'll have to set up your"
" own instrument before your gig. This is often a stressful time and it is easy"
" for problems to occur. One way to help with this is to incorporate the setup "
"process into your practice sessions."
msgstr ""
"多くの楽器は、演奏する前にそれを組み立てたりチューニングしたりする必要があります。あなたがバスいっぱいの会場設営スタッフを抱えるロックスターでも無い限り、ラ"
"イブの前に自分の楽器を準備しなければなりません。これはしばしばストレスの掛かる作業で、問題が発生しやすいです。これに対処する1つの方法は、練習セッションの際"
"に準備のプロセスを組み込んでしまうことです。"

#: A.16-practice.md:76
msgid ""
"Practice tip #4 - treat setting up as an important part of your practice. For "
"example, have a box or bag that you can keep your Raspberry Pi and keyboard in"
" etc. Before each practice session, take out all the parts, connect everything"
", and work through the boot process until you have Sonic Pi running and can ma"
"ke sounds. Once you've finished practicing, take the time to carefully pack ev"
"erything away afterwards. This may take some time at first, but before long yo"
"u'll be able to setup and pack everything away incredibly quickly without havi"
"ng to think about it."
msgstr ""
"練習のヒント #4 - 準備を練習の重要な部分として扱う。例えば、Raspberry Piやキーボードを入れておく箱やバッグを用意します。練習セッションの前"
"に、毎回全ての部品を取り出して接続し、Sonic Piが実行されて音が出るまでの起動プロセスを一通り作業してください。練習が終わったら、時間を取って慎重に全"
"てを詰め直してください。これは最初は時間が掛かるかもしれませんが、あなたはすぐに何も考えずに非常に素早く準備と片付けが出来るようになるでしょう。"

#: A.16-practice.md:87
msgid "Experiment Musically"
msgstr "音楽的に実験する"

#: A.16-practice.md:89
msgid ""
"Once you've set up and are ready to start making music, you might find yoursel"
"f struggling to know where to start. One problem many people face is that they"
" might have a good idea of the kinds of sounds they want to make, but are frus"
"trated that they can't produce them. Some people don't even know what kind of "
"sounds they want to make! The first thing to do is not to worry - this is very"
" common and happens to every musician - even if they've been practicing for a "
"long time. It is much more important to be making sounds you don't like than n"
"ot making any sounds at all."
msgstr ""
"音楽を作り始める準備ができたとき、どこから初めて良いか分からないかもしれません。多くの人々が直面する問題の1つは、作りたい音楽がどのようなものであるかは良い"
"アイデアを持っていても、それを作り出すことができずにフラストレーションがたまることではないでしょうか。さらに、自分がどのような音がを作りたいか分かっていない"
"人々さえ居ます！ これらに対して第一にやることは、心配しないことです。これはミュージシャンにはよくあることで、長年練習を積み重ねたミュージシャンも例外ではあ"
"りません。全く何も音を出さないよりも、好みではなくとも何か音を出すことが重要です。"

#: A.16-practice.md:99
msgid ""
"Practice tip #5 - spend time making sounds and music you don't like. Try to ma"
"ke time to explore new sounds and ideas. Don't worry that it might sound terri"
"ble if it's not the style you're looking for. When you're experimenting like t"
"his you increase the chance of stumbling over a sound or combination of sounds"
" which you love! Even if 99% of the sounds you make are bad, that 1% might be "
"the riff or intro to your new track. Forget the things you don't like and reme"
"mber the parts you do. This is even easier when you're making music with code "
"- just hit save!"
msgstr ""
"練習のヒント #5 - 好みでない音を作るのに時間を使う。新しい音やアイデアの探求に時間を使いましょう。それがあなたの探しているスタイルでなくひどい音がして"
"も気にしないようにしましょう。実験すると、あなたの好きな音や音の組み合わせに出会う機会を増えるのです。99％の音が悪くても1％があなたの新しい曲のリフやイン"
"トロになるかもしれないのです。好みでないものは忘れ、好みのものを覚えておくようにしましょう。これは、コードで音楽を作っていれば全く簡単でしょう。保存を押すだ"
"けです！"

#: A.16-practice.md:110
msgid "Hear the Code"
msgstr "コードを聞く"

#: A.16-practice.md:112
#, fuzzy
msgid ""
"Many musicians can look at a musical score and hear the music in their head wi"
"thout having to play it. This is a very useful skill and it's well worth incor"
"porating into your live coding practice sessions. The important point is to be"
" able to have some understanding of what the code is going to sound like. You "
"don't need to be able to hear it exactly in your head, but instead it's useful"
" to know if the code is going to be fast, slow, loud, rhythmic, melodic, rando"
"m, etc. The final goal is then to be able to reverse this process - to be able"
" to hear music in your head and know what code to write to make it. It may tak"
"e you a long time to master this, but once you do, you'll be able to improvise"
" on stage and express your ideas fluently."
msgstr ""
"多くのミュージシャンは、演奏することなしに、楽譜だけを見て彼らの頭の中で音楽を聞くことができます。これは、ライブコーディングの練習セッションに取り入れる価値"
"のある、とても有用なスキルです。重要なポイントは、あるコードがどのような音がするかについて、何らかの理解が得られることです。その際に、必ずしも音そのものを聞"
"こえるようになる必要はなく、その代わりに、そのコードによって、音楽が速くなるのか、遅くなるのか、うるさくなるのか、リズミカルになるのか、メロディアスになるの"
"か、ランダムになるのか、といったことが分かることが有用です。最終的な目標は、このプロセスを逆にしたものです。つまり、頭の中で音楽を聞き、それを作るのにどのよ"
"うなコードを書くべきか分かるかということです。これをマスターするのには長い時間が掛かるかもしれませんが、一度マスターすれば、ステージ上で即興演奏でき、あなた"
"のアイデアをスムーズに表現できます。"

#: A.16-practice.md:124
msgid ""
"Practice tip #6 - write some code into Sonic Pi but don't hit the Run button. "
"Instead, try to imagine what sound it is going to produce. Then, hit Run, list"
"en, and think about what you got right and what you didn't. Keep repeating thi"
"s until it become a natural part of your coding process. When I practice I nor"
"mally have a good idea of what the code will sound like. However, I still am o"
"ccasionally surprised, and then I'll stop and spend some time thinking about w"
"hy I was wrong. Each time this happens, I learn new tricks which allow me to e"
"xpress myself in new ways."
msgstr ""
"練習のヒント #6 - Sonic Piにコードを書いても`Run`を押さない。その代わり、それがどのような音を作り出すか想像してみてください。次に、`Ru"
"n`を叩いて聞いてみましょう。何が想像した音と合っていて何が合っていなかったか考えましょう。これを、あなたのコーディングのプロセスの一部になるまで繰り返して"
"ください。私が練習するとき、普通はコードがどのような音がするか想像できています。しかし、想像していなかった音が未だに出ることがあって驚くことがあります。その"
"ときは、そこで止まって、時間を取ってなぜ私が間違っていたか考えるようにしています。このようなことが起こる度に、私は新しい方法で自分を表現できる新しい技を学ん"
"でいます。"

#: A.16-practice.md:134
msgid "Remove all distractions"
msgstr "気が散るものを全て取り除く"

#: A.16-practice.md:136
msgid ""
"A common problem when practicing is to become distracted with other things. Pr"
"acticing is hard and requires real discipline regardless of the kind of music "
"you're making - from jazz to classical to EDM. If you're struggling to get sta"
"rted or make progress, it's often too easy to hop on social media, or look som"
"ething up on the internet etc. If you've set yourself a target of 20 minutes o"
"f practice, it's important to try and spend all that time being as productive "
"as possible."
msgstr ""
"練習の際の一般的な問題は、他のことに邪魔されることです。練習は、それがどのような種類の音楽（ジャズからクラシック、ダンス・ミュージック）であれ、過酷で本当の"
"訓練を必要とします。もしあなたが練習を始めたり、進めるのに苦労しているのであれば、それはしばしばソーシャルメディアにアクセスしたり、インターネット上の何かを"
"見るのが簡単すぎることが原因でしょう。仮にあなたが20分間の練習を目標とした場合、その20分間の間可能な限り生産的であるようにすることが重要です。"

#: A.16-practice.md:144
msgid ""
"Practice tip #7 - before you start practicing remove as many distractions as p"
"ossible. For example, disconnect from the internet, put your phone in another "
"room and try to practice in a quiet place where you're unlikely to be disturbe"
"d. Try to focus on coding music and you can return to your distractions when y"
"ou've finished."
msgstr ""
"練習のヒント #7 - 練習を始める前に可能な限り気が散るものを取り除く。例えば、インターネットを切断したり、電話を他の部屋に置いたりして、不意に気をそらさ"
"れない静かな場所で練習するようにしましょう。練習が終われば、またそれらの気をそらすものに戻れるので、それまでは音楽のコーディングに集中するようにしましょう。"

#: A.16-practice.md:151
msgid "Keep a practice diary"
msgstr "練習日記をつける"

#: A.16-practice.md:153
msgid ""
"When you are practicing, you'll often find your mind is full of new exciting i"
"deas - new musical directions, new sounds to try out, new functions to write, "
"etc. These ideas are often so interesting that you might stop what you're doin"
"g and start working on the idea. This is another form of distraction!"
msgstr ""
"あなたが練習している最中、気がつくと、音楽の方向、試してみたい音、書いてみたい関数など、新しい刺激的なアイデアで頭がいっぱいになることがあるかもしれません。"
"これらのアイデアはしばしばとても面白そうなので、練習をやめてそのアイデアを作業してしまうかもしれません。これは、別な形の'気が散るもの'と言えるでしょう！"

#: A.16-practice.md:159
msgid ""
"Practice tip #8 - keep a practice diary by your keyboard. When you get an exci"
"ting new idea, temporarily pause your practice session, quickly jot the idea d"
"own, then forget about it and carry on practicing. You can then spend some qua"
"lity time thinking about and working on your ideas after you've finished pract"
"icing."
msgstr ""
"練習のヒント #8 - 練習日記をつける。刺激的な新しいアイデアが浮かんだら、一時的に練習セッションを停止し、素早くアイデアを書き留めてください。そして、そ"
"のアイデアのことは忘れて、練習を続けてください。そうすれば、練習が終わった後、そのアイデアを集中して検討したり作業できるのです。"

#: A.16-practice.md:168
msgid ""
"Try to establish a practice routine which incorporates as many of these ideas "
"as possible. Try to keep the sessions as fun as possible but be aware that som"
"e practice sessions will be hard and feel a little like work. However, it will"
" all be worth it once you've created your first piece or given your first perf"
"ormance. Remember, practice is the key to success!"
msgstr ""
"ここで紹介したアイデアを可能な限り取り込んだ練習ルーチンを確立するようにしてください。練習セッションは可能な限り楽しくしておくべきですが、ときには練習セッシ"
"ョンは過酷で仕事のように感じることもあるでしょう。しかしながら、一度初めての作品を完成させたり、初めてのパフォーマンスを成功させたりしたら、練習はその価値が"
"あったと言えるでしょう。覚えておいてください、練習は成功の鍵なのです！"

#: A.17-sample-stretching.md:1
#, fuzzy
msgid "A.17 Sample Stretching"
msgstr "A.12 サンプルをスライスする"

#: A.17-sample-stretching.md:3
#, fuzzy
msgid "Sample Stretching"
msgstr "サンプルをスライスする"

#: A.17-sample-stretching.md:5
msgid ""
"When people discover Sonic Pi, one of the first things they learn is how simpl"
"e it is to play pre-recorded sounds using the `sample` function. For example, "
"you can play an industrial drum loop, hear the sound of a choir or even listen"
" to a vinyl scratch all via a single line of code. However, many people don't "
"realise that you can actually vary the speed that the sample is played back at"
" for some powerful effects and a whole new level of control over your recorded"
" sounds. So, fire up a copy of Sonic Pi and let's get started stretching some "
"samples!"
msgstr ""

#: A.17-sample-stretching.md:14
#, fuzzy
msgid "Slowing Samples Down"
msgstr "サンプル"

#: A.17-sample-stretching.md:16
msgid "To modify the playback rate of a sample we need to use the `rate:` opt:"
msgstr ""

#: A.17-sample-stretching.md:18
#, no-wrap
msgid "sample :guit_em9, rate: 1"
msgstr "sample :guit_em9, rate: 1"

#: A.17-sample-stretching.md:20
msgid ""
"If we specify a `rate:` of `1` then the sample is played back at the normal ra"
"te. If we want to play it back at half speed we simply use a `rate:` of `0.5`:"
msgstr ""

#: A.17-sample-stretching.md:27
#, fuzzy
msgid ""
"Notice that this has two effects on the audio. Firstly the sample sounds lower"
" in pitch and secondly it takes twice as long to play back (see the sidebar fo"
"r an explanation of why this is the case). We can even choose lower and lower "
"rates moving towards `0`, so a `rate:` of `0.25` is a quarter speed, `0.1` is "
"a tenth of the speed, etc. Try playing with some low rates and see if you can "
"turn the sound into a low rumble."
msgstr "choose：選択"

#: A.17-sample-stretching.md:34
#, fuzzy
msgid "Speeding Samples Up"
msgstr "サンプル"

#: A.17-sample-stretching.md:36
msgid ""
"In addition to making the sound longer and lower using a small rate, we can us"
"e higher rates to make the sound shorter and higher. Let's play with a drum lo"
"op this time. First, take a listen to how it sounds at the default rate of `1`"
":"
msgstr ""

#: A.17-sample-stretching.md:41
#, no-wrap
msgid "sample :loop_amen, rate: 1"
msgstr "sample :loop_amen, rate: -1"

#: A.17-sample-stretching.md:44
msgid "Now, let's speed it up a little:"
msgstr ""

#: A.17-sample-stretching.md:48
msgid ""
"Ha! We just moved musical genres from old-skool techno to jungle. Notice how t"
"he pitch of each drum hit is higher as well as how the whole rhythm speeds up."
" Now, try even higher rates and see how high and short you can make the drum l"
"oop. For example, if you use a rate of `100`, the drum loop turns into a click"
"!"
msgstr ""

#: A.17-sample-stretching.md:54
msgid "Reverse Gear"
msgstr ""

#: A.17-sample-stretching.md:56
msgid ""
"Now, I'm sure many of you are thinking the same thing right now... \"what if yo"
"u use a negative number for the rate?\". Great question! Let's think about this"
" for a moment. If our `rate:` opt signifies the speed with which the sample is"
" played back, `1` being normal speed, `2` being double speed, `0.5` being half"
" speed, `-1` must mean backwards! Let's try it on a snare. First, play it back"
" at the normal rate:"
msgstr ""

#: A.17-sample-stretching.md:63
#, no-wrap
msgid "sample :elec_filt_snare, rate: 1"
msgstr "sample :elec_filt_snare, rate: 1"

#: A.17-sample-stretching.md:65
#, fuzzy
msgid "Now, play it backwards:"
msgstr "かっこいい！ 逆再生になりますね！"

#: A.17-sample-stretching.md:67
#, no-wrap
msgid "sample :elec_filt_snare, rate: -1"
msgstr "sample :elec_filt_snare, rate: -1"

#: A.17-sample-stretching.md:69
msgid ""
"Of course, you can play it backwards twice as fast with a rate of `-2` or back"
"wards at half speed with a rate of `-0.5`. Now, play around with different neg"
"ative rates and have fun. It's particularly amusing with the `:misc_burp` samp"
"le!"
msgstr ""

#: A.17-sample-stretching.md:75
#, fuzzy
msgid "Sample, Rate and Pitch"
msgstr "サンプルとレートとピッチ [サイドバー]"

#: A.17-sample-stretching.md:77
msgid ""
"One of the effects of rate modification on samples is that faster rates result"
" in the sample sounding higher in pitch and slower rates result in the sample "
"sounding lower in pitch. Another place you may have heard this effect in every"
" day life is when you're cycling or driving past a beeping pedestrian crossing"
" - as you're heading towards the sound source the pitch is higher than when yo"
"u're moving away from the sound - the so-called Doppler effect. Why is this?"
msgstr ""

#: A.17-sample-stretching.md:85
msgid ""
"Let's consider a simple beep which is represented by a sine wave. If we use an"
" oscilloscope to plot a beep, we'll see something like Figure A. If we plot a "
"beep an octave higher, we'll see Figure B and an octave lower will look like F"
"igure C. Notice that the waves of higher notes are more compact and the waves "
"of lower notes are more spread out."
msgstr ""

#: A.17-sample-stretching.md:91
msgid ""
"A sample of a beep is nothing more than a lot of numbers (x, y, coordinates) w"
"hich when plotted onto a graph will re-draw the original curves. See figure D "
"where each circle represents a coordinate. To turn the coordinates back into a"
"udio, the computer works through each x value and sends the corresponding y va"
"lue to the speakers. The trick here is that the rate at which the computer wor"
"ks through the x numbers does not have to be the same as the rate with which t"
"hey were recorded. In other words, the space (representing an amount of time) "
"between each circle can be stretched or compressed. So, if the computer walks "
"through the x values faster than the original rate, it will have the effect of"
" squashing the circles closer together which will result in a higher sounding "
"beep. It will also make the beep shorter as we will work through all the circl"
"es faster. This is shown in Figure E."
msgstr ""

#: A.17-sample-stretching.md:105
msgid ""
"Finally, one last thing to know is that a mathematician called Fourier proved "
"that any sound is actually lots and lots of sine waves all combined together. "
"Therefore, when we compress and stretch any recorded sound we're actually stre"
"tching and compressing many sine waves all at the same time in exactly this ma"
"nner."
msgstr ""

#: A.17-sample-stretching.md:111
msgid "Pitch Bending"
msgstr ""

#: A.17-sample-stretching.md:113
msgid ""
"As we've seen, using a faster rate will make the sound higher in pitch and a s"
"lower rate will make the sound lower in pitch. A very simple and useful trick "
"is to know that doubling the rate actually results in the pitch being an octav"
"e higher and inversely halving the rate results in the pitch being an octave l"
"ower. This means that for melodic samples, playing it alongside itself at doub"
"le/half rates actually sounds rather nice:"
msgstr ""

#: A.17-sample-stretching.md:121
#, no-wrap
msgid ""
"sample :bass_trance_c, rate: 1\n"
"sample :bass_trance_c, rate: 2\n"
"sample :bass_trance_c, rate: 0.5"
msgstr ""
"sample :bass_trance_c, rate: 1\n"
"sample :bass_trance_c, rate: 2\n"
"sample :bass_trance_c, rate: 0.5"

#: A.17-sample-stretching.md:127
msgid ""
"However, what if we just want to alter the rate such that the pitch goes up on"
"e semitone (one note up on a piano)? Sonic Pi makes this very easy via the `rp"
"itch:` opt:"
msgstr ""

#: A.17-sample-stretching.md:131
#, no-wrap
msgid ""
"sample :bass_trance_c\n"
"sample :bass_trance_c, rpitch: 3\n"
"sample :bass_trance_c, rpitch: 7"
msgstr ""
"sample :bass_trance_c\n"
"sample :bass_trance_c, rpitch: 3\n"
"sample :bass_trance_c, rpitch: 7"

#: A.17-sample-stretching.md:137
msgid ""
"If you take a look at the log on the right, you'll notice that an `rpitch:` of"
" `3` actually corresponds to a rate of `1.1892` and a `rpitch:` of `7` corresp"
"onds to a rate of `1.4983`. Finally, we can even combine `rate:` and `rpitch:`"
" opts:"
msgstr ""

#: A.17-sample-stretching.md:142
#, no-wrap
msgid ""
"sample :ambi_choir, rate: 0.25, rpitch: 3\n"
"sleep 3\n"
"sample :ambi_choir, rate: 0.25, rpitch: 5\n"
"sleep 2\n"
"sample :ambi_choir, rate: 0.25, rpitch: 6\n"
"sleep 1\n"
"sample :ambi_choir, rate: 0.25, rpitch: 1"
msgstr ""
"sample :ambi_choir, rate: 0.25, rpitch: 3\n"
"sleep 3\n"
"sample :ambi_choir, rate: 0.25, rpitch: 5\n"
"sleep 2\n"
"sample :ambi_choir, rate: 0.25, rpitch: 6\n"
"sleep 1\n"
"sample :ambi_choir, rate: 0.25, rpitch: 1"

#: A.17-sample-stretching.md:155
msgid ""
"Let's take a look at a simple piece which combines these ideas. Copy it into a"
"n empty Sonic Pi buffer, hit play, listen to it for a while and then use it as"
" a starting point for your own piece. See how much fun it is to manipulate the"
" playback rate of samples. As an added exercise try recording your own sounds "
"and play around with the rate to see what crazy sounds you can make."
msgstr ""

#: A.17-sample-stretching.md:162
#, no-wrap
msgid ""
"live_loop :beats do\n"
"  sample :guit_em9, rate: [0.25, 0.5, -1].choose, amp: 2\n"
"  sample :loop_garzul, rate: [0.5, 1].choose\n"
"  sleep 8\n"
"end\n"
" \n"
"live_loop :melody do\n"
"  oct = [-1, 1, 2].choose * 12\n"
"  with_fx :reverb, amp: 2 do\n"
"    16.times do\n"
"      n = (scale 0, :minor_pentatonic).choose\n"
"      sample :bass_voxy_hit_c, rpitch: n + 4 + oct\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end"
msgstr ""
"live_loop :beats do\n"
"  sample :guit_em9, rate: [0.25, 0.5, -1].choose, amp: 2\n"
"  sample :loop_garzul, rate: [0.5, 1].choose\n"
"  sleep 8\n"
"end\n"
" \n"
"live_loop :melody do\n"
"  oct = [-1, 1, 2].choose * 12\n"
"  with_fx :reverb, amp: 2 do\n"
"    16.times do\n"
"      n = (scale 0, :minor_pentatonic).choose\n"
"      sample :bass_voxy_hit_c, rpitch: n + 4 + oct\n"
"      sleep 0.125\n"
"    end\n"
"  end\n"
"end"

#: A.18-additive-synthesis.md:1
msgid "A.18 Sound Design - Additive Synthesis"
msgstr ""

#: A.18-additive-synthesis.md:3
msgid "Additive Synthesis"
msgstr ""

#: A.18-additive-synthesis.md:5
msgid ""
"This is the first of a short series of articles on how to use Sonic Pi for sou"
"nd design. We'll be taking a quick tour of a number of different techniques av"
"ailable for you to craft your own unique sound. The first technique we'll look"
" at is called *additive synthesis*. This may sound complicated - but if we exp"
"and each word slightly the meaning pops right out. Firstly, additive means a c"
"ombination of things and secondly synthesis means to create sound. Additive sy"
"nthesis therefore means nothing more complicated than *combining existing soun"
"ds to create new ones*. This synthesis technique dates back a very long time -"
" for example, pipe organs in the middle ages had lots of slightly different so"
"unding pipes which you could enable or disable with stops. Pulling out the sto"
"p for a given pipe 'added it to the mix' making the sound richer and more comp"
"lex. Now, let's see how we can pull out all the stops with Sonic Pi."
msgstr ""

#: A.18-additive-synthesis.md:21
msgid "Simple Combinations"
msgstr ""

#: A.18-additive-synthesis.md:23
msgid ""
"Let's start with the most basic sound there is - the humble pure-toned sine wa"
"ve:"
msgstr ""

#: A.18-additive-synthesis.md:26
#, no-wrap
msgid "synth :sine, note: :d3"
msgstr "synth :sine, note: :d3"

#: A.18-additive-synthesis.md:30
msgid "Now, let's see how this sounds combined with a square wave:"
msgstr ""

#: A.18-additive-synthesis.md:32
#, no-wrap
msgid ""
"synth :sine, note: :d3\n"
"synth :square, note: :d3"
msgstr ""
"synth :sine, note: :d3\n"
"synth :square, note: :d3"

#: A.18-additive-synthesis.md:37
msgid ""
"Notice how the two sounds combine to form a new, richer sound. Of course, we d"
"on't have to stop there, we can add as many sounds as we need. However, we nee"
"d to be careful with how many sounds we add together. Just like when we mix pa"
"ints to create new colours, adding too many colours will result in a messy bro"
"wn, similarly - adding too many sounds together will result in a muddy sound."
msgstr ""

#: A.18-additive-synthesis.md:45
#, fuzzy
msgid "Blending"
msgstr "スライド"

#: A.18-additive-synthesis.md:47
msgid ""
"Let's add something to make it sound a little brighter. We could use a triangl"
"e wave at an octave higher (for that high bright sound) yet only play it at am"
"p `0.4` so it adds something extra to the sound rather than taking it over:"
msgstr ""

#: A.18-additive-synthesis.md:52
#, no-wrap
msgid ""
"synth :sine, note: :d3\n"
"synth :square, note: :d3\n"
"synth :tri, note: :d4, amp: 0.4"
msgstr ""
"synth :sine, note: :d3\n"
"synth :square, note: :d3\n"
"synth :tri, note: :d4, amp: 0.4"

#: A.18-additive-synthesis.md:58
msgid ""
"Now, try creating your own sounds by combining 2 or more synths at different o"
"ctaves and amplitudes. Also, note that you can play around with each synth's o"
"pts to modify each source sound before it is mixed in for even more combinatio"
"ns of sounds."
msgstr ""

#: A.18-additive-synthesis.md:64
msgid "Detuning"
msgstr ""

#: A.18-additive-synthesis.md:66
msgid ""
"So far, when combining our different synths we've used either the same pitch o"
"r switched octave. How might it sound if we didn't stick to octaves but instea"
"d chose a slightly higher or lower note? Let's try it:"
msgstr ""

#: A.18-additive-synthesis.md:70
#, no-wrap
msgid ""
"detune = 0.7\n"
"synth :square, note: :e3\n"
"synth :square, note: :e3 + detune"
msgstr ""
"detune = 0.7\n"
"synth :square, note: :e3\n"
"synth :square, note: :e3 + detune"

#: A.18-additive-synthesis.md:76
msgid ""
"If we detune our square waves by 0.7 notes we hear something that perhaps does"
"n't sound in tune or correct - a 'bad' note. However, as we move closer to 0 i"
"t will sound less and less out of tune as the pitches of the two waves get clo"
"ser and more similar. Try it for yourself! Change the `detune:` opt value from"
" `0.7` to `0.5` and listen to the new sound. Try `0.2`, `0.1`, `0.05`, `0`. Ea"
"ch time you change the value, take a listen and see if you can hear how the so"
"und is changing. Notice that low detune values such as `0.1` produce a really "
"nice 'thick' sound, with both slightly different pitches interacting with each"
" other in interesting, often surprising, ways."
msgstr ""

#: A.18-additive-synthesis.md:87
#, fuzzy
msgid ""
"Some of the built-in synths already include a detune option that does exactly "
"this in one synth. Try playing with the `detune:` opt of `:dsaw`, `:dpulse` an"
"d `:dtri`."
msgstr "`:dsaw`"

#: A.18-additive-synthesis.md:92
#, fuzzy
msgid "Amplitude shaping"
msgstr "アンプ（音量）"

#: A.18-additive-synthesis.md:94
msgid ""
"Another way we can finely craft our sound is to use a different envelope and o"
"ptions for each synth trigger. For example this will allow you to make some as"
"pects of the sound percussive and other aspects ring out for a period of time."
msgstr ""

#: A.18-additive-synthesis.md:99
#, no-wrap
msgid ""
"detune = 0.1\n"
"synth :square, note: :e1, release: 2\n"
"synth :square, note: :e1 + detune, amp: 2, release: 2\n"
"synth :gnoise, release: 2, amp: 1, cutoff: 60\n"
"synth :gnoise, release: 0.5, amp: 1, cutoff: 100\n"
"synth :noise, release: 0.2, amp: 1, cutoff: 90"
msgstr ""
"detune = 0.1\n"
"synth :square, note: :e1, release: 2\n"
"synth :square, note: :e1 + detune, amp: 2, release: 2\n"
"synth :gnoise, release: 2, amp: 1, cutoff: 60\n"
"synth :gnoise, release: 0.5, amp: 1, cutoff: 100\n"
"synth :noise, release: 0.2, amp: 1, cutoff: 90"

#: A.18-additive-synthesis.md:108
msgid ""
"In the example above I have mixed in a noisy percussive element to the sound a"
"long with some more persistent background rumbling. This was achieved firstly "
"by using two noise synths with middling cutoff values (`90` and `100`) using s"
"hort release times along with a noise with a longer release time but with a lo"
"w cutoff value (which makes the noise less crisp and more rumbly.)"
msgstr ""

#: A.18-additive-synthesis.md:117
msgid ""
"Let's combine all these techniques to see if we can use additive synthesis to "
"re-create a basic bell sound. I've broken this example into four sections. Fir"
"stly we have the 'hit' section which is the initial onset part of the bell sou"
"nd - so uses a short envelope (e.g. a `release:` of around `0.1`). Next we hav"
"e the long ringing section in which I'm using the pure sound of the sine wave."
" Notice that I'm often increasing the note by roughly `12` and `24` which are "
"the number of notes in one and two octaves. I have also thrown in a couple of "
"low sine waves to give the sound some bass and depth. Finally, I used `define`"
" to wrap my code in a function which I can then use to play a melody. Try play"
"ing your own melody and also messing around with the contents of the `:bell` f"
"unction until you create your own crazy sound to play with!"
msgstr ""

#: A.18-additive-synthesis.md:130
#, no-wrap
msgid ""
"define :bell do |n|\n"
"  # Triangle waves for the 'hit'\n"
"  synth :tri, note: n - 12, release: 0.1\n"
"  synth :tri, note: n + 0.1, release: 0.1\n"
"  synth :tri, note: n - 0.1, release: 0.1\n"
"  synth :tri, note: n, release: 0.2\n"
"  # Sine waves for the 'ringing'\n"
"  synth :sine, note: n + 24, release: 2\n"
"  synth :sine, note: n + 24.1, release: 2\n"
"  synth :sine, note: n + 24.2, release: 0.5\n"
"  synth :sine, note: n + 11.8, release: 2\n"
"  synth :sine, note: n, release: 2\n"
"  # Low sine waves for the bass\n"
"  synth :sine, note: n - 11.8, release: 2\n"
"  synth :sine, note: n - 12, release: 2\n"
"end\n"
"# Play a melody with our new bell!\n"
"bell :e3\n"
"sleep 1\n"
"bell :c2\n"
"sleep 1\n"
"bell :d3\n"
"sleep 1\n"
"bell :g2"
msgstr ""

#: A.19-subtractive-synthesis.md:1
msgid "A.19 Sound Design - Subtractive Synthesis"
msgstr ""

#: A.19-subtractive-synthesis.md:3
msgid "Subtractive Synthesis"
msgstr ""

#: A.19-subtractive-synthesis.md:5
msgid ""
"This is the second in a series of articles on how to use Sonic Pi for sound de"
"sign. Last month we looked at additive synthesis which we discovered was the s"
"imple act of playing multiple sounds at the same time to make a new combined s"
"ound. For example we could combine different sounding synths or even the same "
"synth at different pitches to build a new complex sound from simple ingredient"
"s. This month we'll look at a new technique commonly called *subtractive synth"
"esis* which is simply the act of taking an existing complex sound and removing"
" parts of it to create something new. This is a technique which is commonly as"
"sociated with the sound of analog synthesisers of the 1960s and 1970s but also"
" with the recent renaissance of modular analog synths through popular standard"
"s such as Eurorack."
msgstr ""

#: A.19-subtractive-synthesis.md:18
msgid ""
"Despite this sounding like a particularly complicated and advanced technique, "
"Sonic Pi makes it surprisingly simple and easy - so let's dive right in."
msgstr ""

#: A.19-subtractive-synthesis.md:22
msgid "Complex Source Signal"
msgstr ""

#: A.19-subtractive-synthesis.md:24
msgid ""
"For a sound to work well with subtractive synthesis, it typically needs to be "
"fairly rich and interesting. This doesn't mean we need something hugely comple"
"x - in fact, just a standard `:square` or `:saw` wave will do:"
msgstr ""

#: A.19-subtractive-synthesis.md:29
#, no-wrap
msgid "synth :saw, note: :e2, release: 4"
msgstr "synth :saw, note: :e2, release: 4"

#: A.19-subtractive-synthesis.md:33
msgid ""
"Notice that this sound is already pretty interesting and contains many differe"
"nt frequencies above `:e2` (the second E on a piano) which add to create the t"
"imbre. If that didn't make much sense to you, try comparing it with the `:beep"
"`:"
msgstr ""

#: A.19-subtractive-synthesis.md:38
#, no-wrap
msgid "synth :beep, note: :e2, release: 4"
msgstr "synth :beep, note: :e2, release: 4"

#: A.19-subtractive-synthesis.md:42
msgid ""
"As the `:beep` synth is just a sine wave, you'll hear a much purer tone and on"
"ly at `:e2` and none of the high crispy/buzzy sounds which you heard in the `:"
"saw`. It's this buzziness and variation from a pure sine wave that we can play"
" with when we use subtractive synthesis."
msgstr ""

#: A.19-subtractive-synthesis.md:49
msgid ""
"Once we have our raw source signal, the next step is to pass it through a filt"
"er of some kind which will modify the sound by removing or reducing parts of i"
"t. One of the most common filters used for subtractive synthesis is something "
"called a low pass filter. This will allow all the low parts of the sound throu"
"gh but will reduce or remove the higher parts. Sonic Pi has a powerful yet sim"
"ple to use FX system that includes a low pass filter, called `:lpf`. Let's pla"
"y with it:"
msgstr ""

#: A.19-subtractive-synthesis.md:57
#, no-wrap
msgid ""
"with_fx :lpf, cutoff: 100 do\n"
"  synth :saw, note: :e2, release: 4\n"
"end"
msgstr ""
"with_fx :lpf, cutoff: 100 do\n"
"  synth :saw, note: :e2, release: 4\n"
"end"

#: A.19-subtractive-synthesis.md:63
msgid ""
"If you listen carefully you'll hear how some of that buzziness and crispiness "
"has been removed. In fact, all the frequencies in the sound above note `100` h"
"ave been reduced or removed and only the ones below are still present in the s"
"ound. Try changing that `cutoff:` point to lower notes, say `70` and then `50`"
" and compare the sounds."
msgstr ""

#: A.19-subtractive-synthesis.md:69
msgid ""
"Of course, the `:lpf` isn't the only filter you can use to manipulate the sour"
"ce signal. Another important FX is the high pass filter referred to as `:hpf` "
"in Sonic Pi. This does the opposite to `:lpf` in that it lets the high parts o"
"f the sound through and cuts off the low parts."
msgstr ""

#: A.19-subtractive-synthesis.md:74
#, no-wrap
msgid ""
"with_fx :hpf, cutoff: 90 do\n"
"  synth :saw, note: :e2, release: 4\n"
"end"
msgstr ""
"with_fx :hpf, cutoff: 90 do\n"
"  synth :saw, note: :e2, release: 4\n"
"end"

#: A.19-subtractive-synthesis.md:80
msgid ""
"Notice how this sounds much more buzzy and raspy now that all the low frequenc"
"y sounds have been removed. Play around with the cutoff value - notice how low"
"er values let more of the original bass parts of the source signal through and"
" higher values sound increasingly tinny and quiet."
msgstr ""

#: A.19-subtractive-synthesis.md:86
msgid "Low Pass Filter"
msgstr ""

#: A.19-subtractive-synthesis.md:88
msgid ""
"![Varying amounts of low pass filtering](../../../etc/doc/images/tutorial/arti"
"cles/A.19-subtractive-synthesis/subtractive-synthesis-waveforms.png)"
msgstr ""

#: A.19-subtractive-synthesis.md:90
msgid ""
"The low pass filter is such an important part of every subtractive synthesis t"
"oolkit that it's worth taking a deeper look at how it works. This diagram show"
"s the same sound wave (the `:prophet` synth) with varying amounts of filtering"
". At the top, section A shows the audio wave with no filtering. Notice how the"
" wave form is very pointy and contains lots of sharp edges. It is these hard, "
"sharp angles that produce the high crispy/buzzy parts of the sound. Section B "
"shows the low pass filter in action - notice how it is less pointy and more ro"
"unded than the wave form above. This means that the sound will have fewer high"
" frequencies giving it a more mellow rounded feel. Section C shows the low pas"
"s filter with a fairly low cutoff value - this means that even more of the hig"
"h frequencies have been removed from the signal resulting in an even softer, r"
"ounder wave form. Finally, notice how the size of the wave form, which represe"
"nts the amplitude, decreases as we move from A to C. Subtractive synthesis wor"
"ks by removing parts of the signal which means that the overall amplitude is r"
"educed as the amount of filtering that is taking place increases."
msgstr ""

#: A.19-subtractive-synthesis.md:109
msgid "Filter Modulation"
msgstr ""

#: A.19-subtractive-synthesis.md:111
msgid ""
"So far we've just produced fairly static sounds. In other words, the sound doe"
"sn't change in any way for the entirety of its duration. Often you might want "
"some movement in the sound to give the timbre some life. One way to achieve th"
"is is via filter modulation - changing the filter's options through time. Luck"
"ily Sonic Pi gives you powerful tools to manipulate an FX's opts through time."
" For example, you can set a slide time to each modulatable opt to specify how "
"long it should take for the current value to linearly slide to the target valu"
"e:"
msgstr ""

#: A.19-subtractive-synthesis.md:120
#, no-wrap
msgid ""
"with_fx :lpf, cutoff: 50 do |fx|\n"
"  control fx, cutoff_slide: 3, cutoff: 130\n"
"  synth :prophet, note: :e2, sustain: 3.5\n"
"end"
msgstr ""
"with_fx :lpf, cutoff: 50 do |fx|\n"
"  control fx, cutoff_slide: 3, cutoff: 130\n"
"  synth :prophet, note: :e2, sustain: 3.5\n"
"end"

#: A.19-subtractive-synthesis.md:127
msgid ""
"Let's take a quick look at what's going on here. Firstly we start an `:lpf` FX"
" block as normal with an initial `cutoff:` of a low `50`. However, the first l"
"ine also finishes with the strange `|fx|` at the end. This is an optional part"
" of the `with_fx` syntax which allows you to directly name and control the run"
"ning FX synth. Line 2 does exactly this and controls the FX to set the `cutoff"
"_slide:` opt to 3 and the new target `cutoff:` to be `130`. The FX will now st"
"art sliding the `cutoff:` opt's value from `50` to `130` over a period of 3 be"
"ats. Finally we also trigger a source signal synth so we can hear the effect o"
"f the modulated low pass filter."
msgstr ""

#: A.19-subtractive-synthesis.md:140
msgid ""
"This is just a very basic taster of what's possible when you use filters to mo"
"dify and change a source sound. Try playing with Sonic Pi's many built-in FX t"
"o see what crazy sounds you can design. If your sound feels too static, rememb"
"er you can start modulating the options to create some movement."
msgstr ""

#: A.19-subtractive-synthesis.md:146
msgid ""
"Let's finish by designing a function which will play a new sound created with "
"subtractive synthesis. See if you can figure out what's going on here - and fo"
"r the advanced Sonic Pi readers out there - see if you can work out why I wrap"
"ped everything inside a call to `at` (please send answers to @samaaron on Twit"
"ter)."
msgstr ""

#: A.19-subtractive-synthesis.md:152
#, no-wrap
msgid ""
"define :subt_synth do |note, sus|\n"
"  at do\n"
"    with_fx :lpf, cutoff: 40, amp: 2 do |fx|\n"
"      control fx, cutoff_slide: 6, cutoff: 100\n"
"      synth :prophet, note: note, sustain: sus\n"
"    end\n"
"    with_fx :hpf, cutoff_slide: 0.01 do |fx|\n"
"      synth :dsaw, note: note + 12, sustain: sus\n"
"      (sus * 8).times do\n"
"        control fx, cutoff: rrand(70, 110)\n"
"        sleep 0.125\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"subt_synth :e1, 8\n"
"sleep 8\n"
"subt_synth :e1 - 4, 8"
msgstr ""
"define :subt_synth do |note, sus|\n"
"  at do\n"
"    with_fx :lpf, cutoff: 40, amp: 2 do |fx|\n"
"      control fx, cutoff_slide: 6, cutoff: 100\n"
"      synth :prophet, note: note, sustain: sus\n"
"    end\n"
"    with_fx :hpf, cutoff_slide: 0.01 do |fx|\n"
"      synth :dsaw, note: note + 12, sustain: sus\n"
"      (sus * 8).times do\n"
"        control fx, cutoff: rrand(70, 110)\n"
"        sleep 0.125\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"subt_synth :e1, 8\n"
"sleep 8\n"
"subt_synth :e1 - 4, 8"

#: A.20-creative-coding-in-the-classroom.md:1
msgid "A.20 Creative coding in the classroom with Sonic Pi"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:3
msgid "Creative coding in the classroom with Sonic Pi"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:5
msgid ""
"(This article was published in [issue 9 of the Hello World Magazine](https://h"
"elloworld.raspberrypi.org/issues/9))"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:7
msgid ""
"Code is one of the most creative media that humans have created. The initially"
" obscure symbols of parentheses and lambdas are not just deeply rooted in scie"
"nce and mathematics, they are the closest we have managed to get to casting th"
"e same kind of magical spells as Gandalf and Harry Potter. I believe that this"
" provides a powerful means of engagement in our learning spaces. Through the m"
"agic of code we are able to conjure up individually meaningful stories and lea"
"rning experiences."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:15
msgid ""
"We are surrounded by magical experiences. From the sleight of hand of a stage "
"magician making the ball disappear into thin air, to the wonder of seeing your"
" favourite band perform on a big stage. It is these \"wow\" moments that inspire"
" us to pick up a magic book and learn the French Drop or to start jamming powe"
"r chords on an old guitar. How might we create similarly deep and lasting sens"
"es of wonder that will motivate people to practice and learn the fundamentals "
"of programming?"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:23
msgid "Musical Engines and Notation"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:25
msgid ""
"The histories of music and computers have been intricately woven together sinc"
"e the inception of computing machines, or \"engines\" as Charles Babbage's power"
"ful analytical engine was called. Back in 1842 the Mathematician Ada Lovelace,"
" who worked very closely with Babbage, saw the creative potential of these eng"
"ines. Whilst these first engines had originally been designed to accurately so"
"lve hard maths problems, Ada dreamt about making music with them:"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:33
msgid ""
"\"..the engine might compose elaborate and scientific pieces of music of any de"
"gree of complexity or extent.\" Ada Lovelace, 1842."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:36
msgid ""
"Of course, today in 2019 much of our music, regardless of genre, has either be"
"en composed, produced or mastered with a digital computer. Ada's dream came tr"
"ue. It is even possible to trace the history back even further. If you see cod"
"ing as the art of writing sequences of special symbols that instruct a compute"
"r to do specific things, then musical composition is a very similar practice. "
"In Western music, the symbols are black dots positioned on a stave of lines th"
"at tell the musician which notes to play and when. Intriguingly, if we trace t"
"he roots of Western music notation back to the Italian Benedictine monk, Guido"
" d'Arezzo, we find that the dots and lines system that modern orchestras use i"
"s just one of a number of notation systems he worked on. Some of the others we"
"re much closer to what we might now see as code."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:50
msgid ""
"In education, magical meaningful experiences with computers and programming la"
"nguages have been explored since the late '60s. Computer education pioneers Se"
"ymour Papert, Marvin Minsky and Cynthia Solomon explored simple Lisp-based lan"
"guages that moved pens over large pieces of paper. With just a few simple comm"
"ands it was possible to program the computer to draw any picture. They even ex"
"perimented by extending their Logo language from drawing to music. Papert wrot"
"e about learning through experiencing the reconstruction of knowledge rather t"
"han its transmission. Getting people to play with things directly was an impor"
"tant part of his group's work."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:62
msgid "Sonic Pi Performances"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:64
#, fuzzy
msgid ""
"![Jylda Live Coding in the Sage Gateshead](../../../etc/doc/images/tutorial/ar"
"ticles/A.20-creative-coding-in-the-classroom/jylda-small.png) Jylda and Sam Aa"
"ron perform at the Thinking Digital Conference in the Sage Gateshead. Photo cr"
"edit: TyneSight Photos."
msgstr "ライブコーディング"

#: A.20-creative-coding-in-the-classroom.md:68
msgid ""
"Sonic Pi has been used to perform in a wide range of venues such as school hal"
"ls, nightclubs, outdoor stages at musical festivals, college chapels and prest"
"igious music venues. For example the amazing Convo project which brought 1000 "
"children together in the Royal Albert Hall to perform an ambitious new composi"
"tion by composer Charlotte Harding. The piece was written for traditional inst"
"ruments, choirs, percussion and Sonic Pi code. The pop-artist Jylda also perfo"
"rmed with Sonic Pi in the Sage Gateshead for the Thinking Digital Conference, "
"where she created a unique live-coded improvised remix of her song Reeled."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:78
msgid ""
"![Sonic Pi in the Royal Albert Hall](../../../etc/doc/images/tutorial/articles"
"/A.20-creative-coding-in-the-classroom/convo-small.png) Sonic Pi used as one o"
"f the instruments as part of Convo at the Royal Albert Hall. Photo credit: Pet"
"e Jones."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:83
msgid "Live coding in the classroom"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:85
msgid ""
"Sonic Pi is a code-based music creation and performance tool that builds on al"
"l of these ideas. Unlike the majority of computing education software, it is b"
"oth simple enough to use for education and also powerful enough for profession"
"als. It has been used to perform in international music festivals, used to com"
"pose in a range of styles from classical, EDM and heavy metal, and was even re"
"viewed in the Rolling Stone magazine. It has a diverse community of over 1.5 m"
"illion live coders with a variety of backgrounds all learning and sharing thei"
"r ideas and thoughts through the medium of code. It is free to download for Ma"
"c, PC and Raspberry Pi and includes a friendly tutorial that assumes you know "
"nothing about either code or music."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:97
msgid ""
"Sonic Pi was initially conceived as a response to the UK's newly released Comp"
"uting curriculum in 2014. The goal was to find a motivating and fun way to tea"
"ch the fundamentals of programming. It turns out that there is a lot in common"
" and it's huge fun to explain sequencing as melody, iteration as rhythm, condi"
"tionals as musical variety. I developed the initial designs and first iteratio"
"ns of the platform with Carrie Anne Philbin, who brought a teacher’s perspecti"
"ve to the project. Since then, Sonic Pi has undergone iterative improvements t"
"hanks to the feedback gained from observing learners and collaborating directl"
"y with educators in the classroom. A core design philosophy was to never add a"
" feature that couldn't be easily taught to a 10 year old child. This meant tha"
"t most ideas had to be heavily refined and reworked until they were simple eno"
"ugh. Making things simple whilst keeping them powerful continues to be the har"
"dest part of the project."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:112
msgid ""
"In order to provide the magical motivation, Sonic Pi's design was never limite"
"d to a pure focus on education. Ideally there would be famous musicians and pe"
"rformers using Sonic Pi as a standard instrument alongside guitars, drums, voc"
"als, synths, violins, etc. These performers would then act as motivational rol"
"e models demonstrating the creative potential of code. For this to be possible"
" sufficient focus and effort therefore had to be placed on making it a powerfu"
"l instrument whilst still keeping it simple enough for 10 year olds to pick up"
". In addition to educators, I also worked directly with a variety of different"
" artists in classrooms, art galleries, studios and venues in the early stages "
"of Sonic Pi’s development. This provided essential feedback which enabled Soni"
"c Pi to grow and ultimately flourish as a tool for creative expression."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:126
msgid ""
"There were a number of exciting and unexpected side effects of this dual focus"
" on education and professional musicians. Many of the features are beneficial "
"to both groups. For example, a lot of effort has been put into making error me"
"ssages more friendly and useful (rather than being a huge complicated mess of "
"jargon). This turns out to be very useful when you write a bug while performin"
"g in front of thousands of people. Additionally, functionality such as playing"
" studio quality audio samples, adding audio effects, providing access to live "
"audio from the microphone all turn out to make the learning experience more fu"
"n, rewarding and ultimately meaningful."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:137
msgid ""
"The Sonic Pi community continues to grow and share amazing code compositions, "
"lesson plans, musical algorithms, and much more. Much of this happens on our f"
"riendly forum in_thread (in-thread.sonic-pi.net) which is home to a very diver"
"se group of people that includes educators, musicians, programmers, artists an"
"d makers. It is a real joy to see people learn to use code to express themselv"
"es in new ways and for that in turn to inspire others to do the same."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:145
msgid "Some fun capabilities"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:147
msgid ""
"From a Computer Science perspective, Sonic Pi provides you with the building b"
"locks to teach you the basics as found in the UK's curriculum such as sequenci"
"ng, iteration, conditionals, functions, data structures, algorithms, etc. Howe"
"ver, it also builds on a number of important and relevant concepts which have "
"become adopted in mainstream industry such as concurrency, events, pattern mat"
"ching, distributed computing and determinism - all whilst keeping things simpl"
"e enough to explain to a 10 year old child."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:156
msgid "Getting started is as simple as:"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:162
msgid "A melody can be constructed with one more command, sleep:"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:164
#, no-wrap
#, fuzzy
msgid ""
"play 70\n"
"sleep 1\n"
"play 72\n"
"sleep 0.5\n"
"play 75"
msgstr ""
"play 72\n"
"sleep 0.5\n"
"play 75\n"
"sleep 0.5\n"
"play 79"

#: A.20-creative-coding-in-the-classroom.md:172
msgid ""
"In this example, we play the note 70 (roughly the 70th note on a piano), wait "
"for 1 second, play note 72, wait for half a second and then play note 75. What"
"'s interesting here is that with just two commands we have access to pretty mu"
"ch all of Western notation (which notes to play and when) and learners can cod"
"e any melody they've ever heard. This leads to huge variety in expressive outc"
"omes whilst focussing on the same computing concept: sequencing in this case."
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:180
msgid ""
"Taking ideas from the professional music world, we can also play back any reco"
"rded sound. Sonic Pi can play any audio file on your computer but also has a n"
"umber of sounds built-in to make things easy to get started:"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:189
msgid ""
"This code will play back the drum break which was a pillarstone to early hip-h"
"op, Drum and Bass and Jungle. For example, a number of early hip-hop artists p"
"layed this drum break back at half speed to give it a more laid-back feeling:"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:198
msgid ""
"In the 90s a number of music scenes burst out of new technology which enabled "
"artists to take drum breaks like this apart and reassemble in a different orde"
"r. For example:"
msgstr ""

#: A.20-creative-coding-in-the-classroom.md:202
#, no-wrap
#, fuzzy
msgid ""
"live_loop :jungle do\n"
" sample :loop_amen, onset: pick\n"
" sleep 0.125\n"
"end"
msgstr "sample :loop_amen"

#: A.20-creative-coding-in-the-classroom.md:209
#, fuzzy
msgid ""
"In this example we introduce a basic loop called :jungle which picks a random "
"drum hit from our audio sample, waits for an eighth of a second and then picks"
" another drum hit. This results in an endless stream of random drum beats to d"
"ance to whilst you experience what a loop is."
msgstr "rand"

#: B-Essential-Knowledge.md:1
#, fuzzy
msgid "B Essential Knowledge"
msgstr "不可欠な知識"

#: B-Essential-Knowledge.md:3
msgid "Essential Knowledge"
msgstr "不可欠な知識"

#: B-Essential-Knowledge.md:5
msgid ""
"This section will cover some very useful - in fact *essential* - knowledge for"
" getting the most out of your Sonic Pi experience."
msgstr "この章ではSonic Piを最大限に活用するために、いくつかの非常に便利で、実際のところ*不可欠な*知識を紹介します。"

#: B-Essential-Knowledge.md:8
msgid ""
"We'll cover how to take advantage of the many keyboard shortcuts available to "
"you, how to share your work and some tips on performing with Sonic Pi."
msgstr ""
"利用可能な多くのキーボードのショートカットを活用する方法と、作品を共有する方法、そしてSonic Piでパフォーマンスする際のいくつかのヒントを見ていきます"
"。"

#: B.01-Using-Shortcuts.md:1
#, fuzzy
msgid "B.1 Using Shortcuts"
msgstr "10.1 ショートカットの使用"

#: B.01-Using-Shortcuts.md:3
msgid "Using Shortcuts"
msgstr "ショートカットの使用"

#: B.01-Using-Shortcuts.md:5
msgid ""
"Sonic Pi is as much an instrument as a coding environment. Shortcuts can there"
"fore make playing Sonic Pi much more *efficient and natural* - especially when"
" you're playing live in front of an audience."
msgstr ""
"Sonic Piは、コーディング環境であると同時に楽器でもあります。したがって、あなたが観客の前でライブ演奏している場合は特に、ショートカットを使うことで、"
"はるかに*効率的で自然に*Sonic Piの演奏を行うことができます。"

#: B.01-Using-Shortcuts.md:9
msgid ""
"Much of Sonic Pi can be controlled through the keyboard. As you gain more fami"
"liarity working and performing with Sonic Pi, you'll likely start using the sh"
"ortcuts more and more. *I personally touch-type* (I recommend you consider lea"
"rning too) and find myself frustrated whenever I need to reach for the mouse a"
"s it slows me down. I therefore use all of these shortcuts on a very regular b"
"asis!"
msgstr ""
"Sonic Piの多くの機能は、キーボードを介して制御することができます。Sonic Piの演奏や作業により慣れるために、ショートカットをもっと使いこなしま"
"しょう。私個人はブラインドタッチができ（あなたにも習得をお勧めします）、マウスを使う必要があるときにはいつも、動作が遅れるのでイライラしてしまいます。このた"
"め、私は普段からこれらのショートカットのすべてを使っています！"

#: B.01-Using-Shortcuts.md:16
msgid ""
"Therefore, if you learn the shortcuts, you'll learn to use your keyboard effec"
"tively and you'll be live coding like a pro in no time."
msgstr "ショートカットを学べば、効果的にキーボードを使用でき、すぐにプロのようなライブコーディングができるようになるでしょう。"

#: B.01-Using-Shortcuts.md:19
msgid ""
"However, *don't try and learn them all at once*, just try and remember the one"
"s you use most and then keep adding more to your practice."
msgstr ""
"しかし、*一度にすべてを憶えようとしない*で、最初はあなたが最も使うものを試しながら憶えていき、その後継続して他のショートカットを追加していくと良いでしょう"
"。"

#: B.01-Using-Shortcuts.md:22
msgid "Consistency across Platforms"
msgstr "プラットフォーム間での一貫性"

#: B.01-Using-Shortcuts.md:24
msgid ""
"Imagine you're learning the clarinet. You'd expect all clarinets of all makes "
"to have similar controls and fingerings. If they didn't, you'd have a tough ti"
"me switching between different clarinets and you'd be stuck to using just one "
"make."
msgstr ""
"クラリネットを習っているところを想像してみてください。すべてのクラリネットは、指使いや操作の全てが一貫してしていることを前提として作られていますが、もしそう"
"でなかったら、別のクラリネットに乗り換えるには大変な時間を費やしてしまうだろうし、1回だけの制作のためにそれを使用することについて戸惑ってしまうでしょう。"

#: B.01-Using-Shortcuts.md:29
msgid ""
"Unfortunately the three major operating systems (Linux, Mac OS X and Windows) "
"come with their own standard defaults for actions such as cut and paste etc. S"
"onic Pi will try and honour these standards. However *priority is placed on co"
"nsistency across platforms* within Sonic Pi rather than attempting to conform "
"to a given platform's standards. This means that when you learn the shortcuts "
"whilst playing with Sonic Pi on your Raspberry Pi, you can move to the Mac or "
"PC and feel right at home."
msgstr ""
"残念なことに3つの主要なオペレーティングシステム（Linux、Mac OS XおよびWindows）では、カット＆ペーストなどの操作のために独自の基準が用意"
"されています。Sonic Piは、これらの基準を尊重します。しかしながら、Sonic Piでは、プラットフォームの基準に対応することよりも、*プラットフォー"
"ム間での一貫性を優先しています*。これはRaspberry PiでSonic Piを演奏してショートカットを学んだら、MacやPCに乗り換えても違和感無く同"
"じように操作できることを意味しています。"

#: B.01-Using-Shortcuts.md:37
msgid "Control and Meta"
msgstr "ControlとMeta"

#: B.01-Using-Shortcuts.md:39
msgid ""
"Part of the notion of consistency is the naming of shortcuts. In Sonic Pi we u"
"se the names *Control* and *Meta* to refer to the two main combination keys. O"
"n all platforms *Control* is the same. However, on Linux and Windows, *Meta* i"
"s actually the *Alt* key while on Mac *Meta* is the *Command* key. For consist"
"ency we'll use the term *Meta* - just remember to map that to the appropriate "
"key on your operating system."
msgstr ""
"一貫性への考え方のひとつにショートカットの命名があります。Sonic Piにおいて、主要な2つの組み合わせキーを当てはめるために、*Controlキー*と*"
"Metaキー*を用います。すべてのプラットフォームでは、*Controlキー*は同じです。しかし、LinuxとWindowsでは、実際の*Metaキー*はA"
"ltキーで、Macの*Metaキー*は*コマンド⌘キー*です。一貫性のために、*Metaキー*という言葉を使いますが、あなたのオペレーティングシステムにおけ"
"る適切なキーに置き換えるようにしてください。"

#: B.01-Using-Shortcuts.md:46
msgid "Abbreviations"
msgstr "略語"

#: B.01-Using-Shortcuts.md:48
msgid ""
"To help keep things simple and readable, we'll use the abbreviations *C-* for "
"*Control* plus another key and *M-* for *Meta* plus another key. For example, "
"if a shortcut requires you to hold down both *Meta* and *r* we'll write that a"
"s `M-r`. The *-* just means \"at the same time as.\""
msgstr ""
"シンプルで読みやすくするために、*Ctrlキー*＋その他のキーは「*C-*」、*Metaキー*＋その他のキーは「*M-*」の略語を使います。例えば、あるショ"
"ートカットが*Metaキー*と'r'を同時に押さえる必要がある場合、「*M-r*」と表記します。そして、*-*は、\"同時に押さえる\"を意味しています。"

#: B.01-Using-Shortcuts.md:53
msgid "The following are some of the shortcuts I find most useful."
msgstr "以下は、僕が見つけたとっても有用なショートカットのいくつかです。"

#: B.01-Using-Shortcuts.md:55
msgid "Stopping and starting"
msgstr "停止と開始"

#: B.01-Using-Shortcuts.md:57
msgid ""
"Instead of always reaching for the mouse to run your code, you can simply pres"
"s `M-r`. Similarly, to stop running code you can press `M-s`."
msgstr "マウスを使う代わりに、`M-r`でコードを実行することができます。同様に、`M-s`でコードを停止することができます。"

#: B.01-Using-Shortcuts.md:60 B.02-Shortcut-Cheatsheet.md:56
msgid "Navigation"
msgstr "ナビゲーション"

#: B.01-Using-Shortcuts.md:62
msgid ""
"I'm really lost without the navigation shortcuts. I therefore highly recommend"
" you spend the time to learn them. These shortcuts also work extremely well wh"
"en you've learned to touch type as they use the standard letters rather than r"
"equiring you to move your hand to the mouse or the arrow keys on your keyboard"
"."
msgstr ""
"ナビゲーションのショートカットを使わない操作は実にもどかしいです。そのため、ショートカットを学ぶことに時間を費やすことを強くお勧めします。ブラインドタッチを"
"習得すれば、マウスやキーボードの矢印キーに手を移動させる必要が無くなるので、これらのショートカットをさらに有効に活用することができます。"

#: B.01-Using-Shortcuts.md:68
msgid ""
"You can move to the beginning of the line with `C-a`, the end of the line with"
" `C-e`, up a line with `C-p`, down a line with `C-n`, forward a character with"
" `C-f`, and back a character with `C-b`. You can even delete all the character"
"s from the cursor to the end of the line with `C-k`."
msgstr ""
"行の先頭に移動するには`C-a`、行の末尾に移動するには`C-e`、1行上は`C-p`、1行下がるには`C-n`、1文字進むには`C-f`、そして、1文字戻"
"るには`C-b`。`C-k`でカーソルから行の末尾まで全ての文字を消去する事ができます。"

#: B.01-Using-Shortcuts.md:74
msgid "Tidy Code"
msgstr "コードの整形"

#: B.01-Using-Shortcuts.md:76
msgid "To auto-align your code simply press `M-m`."
msgstr "コードを自動整形するには`M-m`を押します。"

#: B.01-Using-Shortcuts.md:78
msgid "Help System"
msgstr "ヘルプシステム"

#: B.01-Using-Shortcuts.md:80
msgid ""
"To toggle the help system you can press `M-i`. However, a much more useful sho"
"rtcut to know is `C-i` which will look up the word underneath the cursor and d"
"isplay the docs if it finds anything. Instant help!"
msgstr ""
"ヘルプシステムを切り替えるには、`M-i`を押します。しかし、何かを見つける場合、もっとはるかに便利なショートカットは、カーソル下の単語検索し、ドキュメント"
"を表示する`C-i`です。簡単でしょう！"

#: B.01-Using-Shortcuts.md:84
#, fuzzy
msgid "For a full list take a look at section B.2 Shortcut Cheatsheet."
msgstr "完全なリストについては、セクション10.2ショートカット一覧表を見てみましょう。"

#: B.02-Shortcut-Cheatsheet.md:1
#, fuzzy
msgid "B.2 Shortcut Cheatsheet"
msgstr "10.2 ショートカット一覧表"

#: B.02-Shortcut-Cheatsheet.md:3
msgid "Shortcut Cheatsheet"
msgstr "ショートカット一覧表"

#: B.02-Shortcut-Cheatsheet.md:5
#, fuzzy
msgid ""
"The following is a summary of the main shortcuts available within Sonic Pi. Pl"
"ease see Section B.1 for motivation and background."
msgstr "以下は、Sonic Piで利用可能な主なショートカットをまとめたものです。動機と背景については、セクション10.1を参照してください。"

#: B.02-Shortcut-Cheatsheet.md:8
msgid "Conventions"
msgstr "規定"

#: B.02-Shortcut-Cheatsheet.md:10
msgid ""
"In this list, we use the following conventions (where *Meta* is one of *Alt* o"
"n Windows/Linux or *Cmd* on Mac):"
msgstr "このリストでは下記の規定に準拠します（WindowsとLinuxの*Meta*キーは*Alt*キー、そしてMacは*Cmd*キー）:"

#: B.02-Shortcut-Cheatsheet.md:13
msgid ""
"`C-a` means hold the *Control* key then press the *a* key whilst holding them "
"both at the same time, then releasing."
msgstr "`C-a` は*Control*キーを押さえながら*a*キー、両方を同時にを押した後に離す事を意味しています。"

#: B.02-Shortcut-Cheatsheet.md:14
msgid ""
"`M-r` means hold the *Meta* key and then press the *r* key whilst holding them"
" both at the same time, then releasing."
msgstr "`M-r` は*Meta*キーを押さえながら*r*キー、両方を同時にした後に離す事を意味しています。"

#: B.02-Shortcut-Cheatsheet.md:15
msgid ""
"`S-M-z` means hold the *Shift* key, then the *Meta* key, then finally the *z* "
"key all at the same time, then releasing."
msgstr "`S-M-z` は*Shift*キーを押さえながら*Meta*キー、そして最後に*z*キー全てを同時に押した後に離す事を意味しています。"

#: B.02-Shortcut-Cheatsheet.md:16
msgid ""
"`C-M-f` means hold the *Control* key, then press *Meta* key, finally the *f* k"
"ey all at the same time, then releasing."
msgstr "`C-M-f`は*Control* キーを押さえながら*Meta*キー、そして最後に*f*キー全てを同時に押した後に離す事を意味しています。"

#: B.02-Shortcut-Cheatsheet.md:18
msgid "Main Application Manipulation"
msgstr "主なアプリケーションの操作"

#: B.02-Shortcut-Cheatsheet.md:20
msgid "`M-r` - Run code"
msgstr "`M-r` - コードを実行"

#: B.02-Shortcut-Cheatsheet.md:21
msgid "`M-s` - Stop code"
msgstr "`M-s` - コードを停止"

#: B.02-Shortcut-Cheatsheet.md:22
msgid "`M-i` - Toggle Help System"
msgstr "`M-i` - ヘルプシステムを表示"

#: B.02-Shortcut-Cheatsheet.md:23
msgid "`M-p` - Toggle Preferences"
msgstr "`M-p` - 設定を表示"

#: B.02-Shortcut-Cheatsheet.md:24
msgid "`M-{` - Switch buffer to the left"
msgstr "`M-{` - 左のBufferに切り替え"

#: B.02-Shortcut-Cheatsheet.md:25
msgid "`M-}` - Switch buffer to the right"
msgstr "`M-}` - 右のBufferに切り替え"

#: B.02-Shortcut-Cheatsheet.md:26
msgid "`S-M-0` - Switch to buffer 0"
msgstr ""

#: B.02-Shortcut-Cheatsheet.md:27
msgid "`S-M-1` - Switch to buffer 1"
msgstr ""

#: B.02-Shortcut-Cheatsheet.md:28
msgid "..."
msgstr ""

#: B.02-Shortcut-Cheatsheet.md:29
msgid "`S-M-9` - Switch to buffer 9"
msgstr ""

#: B.02-Shortcut-Cheatsheet.md:30
msgid "`M-+` - Increase text size of current buffer"
msgstr "`M-+` - 文字サイズを大きく"

#: B.02-Shortcut-Cheatsheet.md:31
msgid "`M--` - Decrease text size of current buffer"
msgstr "`M--` - 文字サイズを小さく"

#: B.02-Shortcut-Cheatsheet.md:34
msgid "Selection/Copy/Paste"
msgstr "選択/コピー/張り付け"

#: B.02-Shortcut-Cheatsheet.md:36
msgid "`M-a` - Select all"
msgstr "`M-a` - 全てを選択"

#: B.02-Shortcut-Cheatsheet.md:37
msgid "`M-c` - Copy selection to paste buffer"
msgstr "`M-c` - 選択箇所をコピー"

#: B.02-Shortcut-Cheatsheet.md:38
msgid "`M-]` - Copy selection to paste buffer"
msgstr "`M-]` - 選択箇所をコピー"

#: B.02-Shortcut-Cheatsheet.md:39
msgid "`M-x` - Cut selection to paste buffer"
msgstr "`M-x` - 選択箇所をカット"

#: B.02-Shortcut-Cheatsheet.md:40
msgid "`C-]` - Cut selection to paste buffer"
msgstr "`C-]` - 選択箇所をカット"

#: B.02-Shortcut-Cheatsheet.md:41
msgid "`C-k` - Cut to the end of the line"
msgstr "`C-k` - カーソルから行の末尾まで全ての文字を消去する"

#: B.02-Shortcut-Cheatsheet.md:42
msgid "`M-v` - Paste from paste buffer to editor"
msgstr "`M-v` - エディタへ張り付け"

#: B.02-Shortcut-Cheatsheet.md:43
msgid "`C-y` - Paste from paste buffer to editor"
msgstr "`C-y` - エディタへ張り付け"

#: B.02-Shortcut-Cheatsheet.md:44
msgid ""
"`C-SPACE` - Set mark. Navigation will now manipulate highlighted region. Use `"
"C-g` to escape."
msgstr "`C-SPACE` - マークを設定します。以降のナビゲーション操作で選択箇所を変更できます。`C-g`でマークを解除します。"

#: B.02-Shortcut-Cheatsheet.md:46
msgid "Text Manipulation"
msgstr "文字の操作"

#: B.02-Shortcut-Cheatsheet.md:48
msgid "`M-m` - Align all text"
msgstr "`M-m` - テキストを整形"

#: B.02-Shortcut-Cheatsheet.md:49
msgid "`Tab` - Align current line or selection (or select autocompletion)"
msgstr "`Tab` - 現在の行または選択箇所のテキストを整形（または、自動補完を選択）"

#: B.02-Shortcut-Cheatsheet.md:50
msgid "`C-l` - Centre editor"
msgstr "`C-l` - 真ん中へ移動"

#: B.02-Shortcut-Cheatsheet.md:51
msgid "`M-/` - Comment/Uncomment current line or selection"
msgstr "`M-/` - 現在の行または選択箇所をコメント／コメント解除"

#: B.02-Shortcut-Cheatsheet.md:52
msgid "`C-t` - Transpose/swap characters"
msgstr "`C-t` - カーソルの前後の文字を入れ替え"

#: B.02-Shortcut-Cheatsheet.md:53
msgid "`M-u` - Convert next word (or selection) to upper case."
msgstr "`M-u` - カーソルの後ろの単語（または選択箇所）を大文字に変換"

#: B.02-Shortcut-Cheatsheet.md:54
msgid "`M-l` - Convert next word (or selection) to lower case."
msgstr "`M-l` - カーソルの後ろの単語（または選択箇所）を小文字に変換"

#: B.02-Shortcut-Cheatsheet.md:58
msgid "`C-a` - Move to beginning of line"
msgstr "`C-a` - 行の先頭に移動"

#: B.02-Shortcut-Cheatsheet.md:59
msgid "`C-e` - Move to end of line"
msgstr "`C-e` - 行の末尾に移動"

#: B.02-Shortcut-Cheatsheet.md:60
msgid "`C-p` - Move to previous line"
msgstr "`C-p` - ひとつ前の行に移動"

#: B.02-Shortcut-Cheatsheet.md:61
msgid "`C-n` - Move to next line"
msgstr "`C-n` - 次の行に移動"

#: B.02-Shortcut-Cheatsheet.md:62
msgid "`C-f` - Move forward one character"
msgstr "`C-f` - 一文字進む"

#: B.02-Shortcut-Cheatsheet.md:63
msgid "`C-b` - Move backward one character"
msgstr "`C-b` - 一文字戻る"

#: B.02-Shortcut-Cheatsheet.md:64
msgid "`M-f` - Move forward one word"
msgstr "`M-f` - 一単語進む"

#: B.02-Shortcut-Cheatsheet.md:65
msgid "`M-b` - Move backward one word"
msgstr "`M-b` - 一単語戻る"

#: B.02-Shortcut-Cheatsheet.md:66
msgid "`C-M-n` - Move line or selection down"
msgstr "`C-M-n` - 現在の行または選択箇所を下に移動"

#: B.02-Shortcut-Cheatsheet.md:67
msgid "`C-M-p` - Move line or selection up"
msgstr "`C-M-p` - 現在の行または選択箇所を上に移動"

#: B.02-Shortcut-Cheatsheet.md:68
msgid "`S-M-u` - Move up 10 lines"
msgstr "`S-M-u` - 10行上に移動"

#: B.02-Shortcut-Cheatsheet.md:69
msgid "`S-M-d` - Move down 10 lines"
msgstr "`S-M-d` - 10行下に移動"

#: B.02-Shortcut-Cheatsheet.md:70
msgid "`M-<` - Move to beginning of buffer"
msgstr "`M-<` - Bufferの先頭に移動"

#: B.02-Shortcut-Cheatsheet.md:71
msgid "`M->` - Move to end of buffer"
msgstr "`M->` - Bufferの末尾に移動"

#: B.02-Shortcut-Cheatsheet.md:73
msgid "Deletion"
msgstr "削除"

#: B.02-Shortcut-Cheatsheet.md:75
msgid "`C-h` - Delete previous character"
msgstr "`C-h` - 前の文字を削除"

#: B.02-Shortcut-Cheatsheet.md:76
msgid "`C-d` - Delete next character"
msgstr "`C-d` - 次の文字を削除"

#: B.02-Shortcut-Cheatsheet.md:78
msgid "Advanced Editor Features"
msgstr "高度なエディタの機能"

#: B.02-Shortcut-Cheatsheet.md:80
msgid "`C-i` - Show docs for word under cursor"
msgstr "`C-i` - カーソルの下の単語のドキュメントを表示"

#: B.02-Shortcut-Cheatsheet.md:81
msgid "`M-z` - Undo"
msgstr "`M-z` - アンドゥ（行った操作を取り消し、元の状態に戻る）"

#: B.02-Shortcut-Cheatsheet.md:82
msgid "`S-M-z` - Redo"
msgstr "`S-M-z` - リドゥ（一旦取り消した操作をやり直す）"

#: B.02-Shortcut-Cheatsheet.md:83
msgid "`C-g` - Escape"
msgstr "`C-g` - エスケープ"

#: B.02-Shortcut-Cheatsheet.md:84
msgid "`S-M-f` - Toggle fullscreen mode"
msgstr "`S-M-f` - フルスクリーンモードを切り替え"

#: B.02-Shortcut-Cheatsheet.md:85
msgid "`S-M-b` - Toggle visibility of buttons"
msgstr "`S-M-b` - ボタンの表示を切り替え"

#: B.02-Shortcut-Cheatsheet.md:86
msgid "`S-M-l` - Toggle visibility of log"
msgstr "`S-M-l` - ログの表示を切り替え"

#: B.02-Shortcut-Cheatsheet.md:87
msgid "`S-M-m` - Toggle between light/dark modes"
msgstr "`S-M-m` - ライト／ダークモードを切り替え"

#: B.02-Shortcut-Cheatsheet.md:88
msgid "`S-M-s` - Save contents of buffer to a file"
msgstr "`S-M-s` - Bufferの内容をファイルに保存"

#: B.02-Shortcut-Cheatsheet.md:89
msgid "`S-M-o` - Load contents of buffer from a file"
msgstr "`S-M-o` - Bufferの内容をファイルから読み込む"

#: B.03-Sharing.md:1
#, fuzzy
msgid "B.3 Sharing"
msgstr "10.3 共有"

#: B.03-Sharing.md:3
msgid "Sharing"
msgstr "共有"

#: B.03-Sharing.md:5
msgid "Sonic Pi is all about sharing and learning with each other."
msgstr "Sonic Piで最も大事なことは、お互いに共有し学習することです。"

#: B.03-Sharing.md:7
msgid ""
"Once you've learned how to code music, sharing your compositions is as simple "
"as sending an email containing your code. Please do *share* your code with oth"
"ers so they can *learn* from your work and even use parts in a new *mash-up*."
msgstr ""
"いったん、どのように音楽をコード化するかを学んだら、作曲したコードを共有することは電子メールを送信するのと同じくらい簡単なことです。あなたの作品から*学び*"
"、さらに新しい*マッシュアップ*で部品を使えるように、他の人とコードを*共有*しましょう。"

#: B.03-Sharing.md:12
msgid ""
"If you're unsure of the best way to share your work with others I recommend pu"
"tting your code on [GitHub](https://github.com) and your music on [SoundCloud]"
"(https://soundcloud.com). That way you'll be able to easily reach a large audi"
"ence."
msgstr ""
"もしあなたの作品を他者と共有するためのよい方法が見当たらなければ、あなたの音楽を[SoundCloud](https://soundcloud.com)へ、"
"そしてコードを[GitHub](https://github.com)に置くことをお勧めします。それらの方法で、あなたの作品は、容易にたくさんの人に届けるこ"
"とができるでしょう。"

#: B.03-Sharing.md:17
msgid "Code -> GitHub"
msgstr "コードをGitHubへ"

#: B.03-Sharing.md:19
msgid ""
"[GitHub](https://github.com) is a site for sharing and working with code. It's"
" used by professional developers as well as artists for sharing and collaborat"
"ing with code. The simplest way to share a new piece of code (or even an unfin"
"ished piece) is to create a [Gist](https://gist.github.com). A [Gist](https://"
"gist.github.com) is a simple way of uploading your code in a simple way that o"
"thers can see, copy and share."
msgstr ""
"[GitHub](https://github.com)は、コードを共有し作業するためのサイトです。コードの共有や共同作業のためにプロの開発者と同じくアーテ"
"ィストも使用しています。新しい作品のコード（あるいは未完の作品）を共有する最も簡単な方法は、この[GitHub](https://github.com)で["
"Gist](https://gist.github.com)を作成することです。[Gist](https://gist.github.com)は、コードを簡"
"単にアップロードする方法で、これにより他の人が簡単に参照、コピーし共有することができます。"

#: B.03-Sharing.md:27
msgid "Audio -> SoundCloud"
msgstr "音をSoundCloudへ"

#: B.03-Sharing.md:29
msgid ""
"Another important way of sharing your work is to record the audio and upload i"
"t to [SoundCloud](https://soundcloud.com). Once you've uploaded your piece, ot"
"her users can comment and discuss your work. I also recommend placing a link t"
"o a [Gist](https://gist.github.com) of your code in the track description."
msgstr ""
"作品を共有するもう1つの重要な方法は、音を録音し[SoundCloud](https://soundcloud.com)にアップロードすることです。作品をア"
"ップロードしたら、他のユーザがコメントしあなたの作品について話し合うことができます。また、トラックの詳細にあなたのコードの[Gist](https://gi"
"st.github.com) へリンクを貼ることをお勧めします。"

#: B.03-Sharing.md:35
msgid ""
"To record your work, hit the `Rec` button in the toolbar, and recording starts"
" immediately. Hit `Run` to start your code if it isn't already in progress. Wh"
"en you're done recording, press the flashing `Rec` button again, and you'll be"
" prompted to enter a filename. The recording will be saved as a WAV file, whic"
"h can be edited and converted to MP3 by any number of free programs (try Audac"
"ity for instance)."
msgstr ""
"作品を記録するには、ツールバーの`Rec`ボタンを押すと、すぐに録音を開始します。もしコードがすでに実行中でなければ、開始するために`Run`を押してくださ"
"い。録音が完了したら、再び点滅している`Rec`ボタンを押すと、ファイル名を入力するよう求められます。WAVファイルとして保存された録音は、無料のソフトウェ"
"ア（例えば、Audacityを試してみてください）で編集したりMP3に変換することができます。"

#: B.03-Sharing.md:43
msgid "Hope"
msgstr "希望"

#: B.03-Sharing.md:45
msgid ""
"I encourage you to share your work and really hope that we'll all teach each o"
"ther new tricks and moves with Sonic Pi. I'm really excited by what you'll hav"
"e to show me."
msgstr ""
"私はみなさんが作った作品を共有し、我々がお互いにSonic Piの新しいトリックや動作を教えあえることを願っています。あなたが何を見せてくれるか本当に楽しみ"
"にしています。"

#: B.04-Performing.md:1
#, fuzzy
msgid "B.4 Performing"
msgstr "10.4 パフォーマンス"

#: B.04-Performing.md:3
msgid "Performing"
msgstr "パフォーマンス"

#: B.04-Performing.md:5
msgid ""
"One of the most exciting aspects of Sonic Pi is that it enables you to use cod"
"e as a *musical instrument*. This means that writing code live can now be seen"
" as a new way of performing music."
msgstr ""
"Sonic Piの中で最もエキサイティングな側面の1つは、*楽器*としてコードを使うことができるということです。これは、コードをライブで書くことが、音楽を演"
"奏する新しい方法とみなすことができることを意味します。"

#: B.04-Performing.md:9
msgid "We call this *Live Coding*."
msgstr "我々は、これを*ライブコーディング*と呼んでいます。"

#: B.04-Performing.md:11
msgid "Show Your Screen"
msgstr "画面を表示しよう"

#: B.04-Performing.md:13
msgid ""
"When you live code I recommend you *show your screen* to your audience. Otherw"
"ise it's like playing a guitar but hiding your fingers and the strings. When I"
" practice at home I use a Raspberry Pi and a little mini projector on my livin"
"g room wall. You could use your TV or one of your school/work projectors to gi"
"ve a show. Try it, it's a lot of fun."
msgstr ""
"ライブコーディングするとき、観客に*あなたの画面を表示する*ことをお勧めします。そうでなければ、ギターを指や弦を隠しながら演奏するようなものです。私は家で練"
"習するときは、Raspberry Piと小型プロジェクターでリビングルームの壁に投影しています。テレビや学校/職場のプロジェクターを使ってみましょう。挑戦し"
"てみてください。とても楽しいですよ。"

#: B.04-Performing.md:20
msgid "Form a Band"
msgstr "バンドを結成しよう"

#: B.04-Performing.md:22
msgid ""
"Don't just play on your own - form a live coding band! It's a lot of fun jammi"
"ng with others. One person could do beats, another ambient background, etc. Us"
"e the `live_audio` functionality to combine code with traditional instruments "
"such as a guitar or a microphone."
msgstr ""
"1人で演奏するのではなく、ライブコーディングバンドを結成しましょう！他の人とい"
"っしょに演奏するのはとても楽しいですよ。1人がビートを担当して、もう1人はアン"
"ビエントなBGMを奏でる、みたいにね。ギターやマイクのような普通の楽器とコードを"
"組み合わせる時には`live_audio`機能を使ってください。"

#: B.04-Performing.md:27
msgid "See what interesting combinations of sounds you can create with code."
msgstr "コードを使ってどんな面白い音の組み合わせが作れるか、試してみましょう。"

#: B.04-Performing.md:29
msgid "TOPLAP"
msgstr "TOPLAP"

#: B.04-Performing.md:31
msgid ""
"Live coding isn't completely new - a small number of people have been doing it"
" for a few years now, typically using bespoke systems they've built for themse"
"lves. A great place to go and find out more about other live coders and system"
"s is [TOPLAP](http://toplap.org)."
msgstr ""
"ライブコーディングは新しいものではありません。一部の人々は、自ら構築した特注システムを使用して、ここ数年ライブコーディングに取り組んできました。他のライブコ"
"ーダーやシステムについての詳細を知るには、[TOPLAP](http://toplap.org)は絶好の場所でしょう。"

#: B.04-Performing.md:36
msgid "Algorave"
msgstr "Algorave"

#: B.04-Performing.md:38
msgid ""
"Another great resource for exploring the live coding world is [Algorave](http:"
"//algorave.com). Here you can find all about a specific strand of live coding "
"for making music in nightclubs."
msgstr ""
"ライブコーディングの世界を探索するためのもう1つの偉大なリソースは、[Algorave](http://algorave.com)です。ここで、クラブシーン"
"でのライブコーディングに特化した情報を見つけることができます。"

#: C-Minecraft-Pi.md:1
#, fuzzy
msgid "C Minecraft Pi"
msgstr "Minecraft Pi（マインクラフトパイ）"

#: C-Minecraft-Pi.md:3
msgid "Minecraft Pi"
msgstr "Minecraft Pi（マインクラフトパイ）"

#: C-Minecraft-Pi.md:5
msgid ""
"Sonic Pi now supports a simple API for interacting with Minecraft Pi - the spe"
"cial edition of Minecraft which is installed by default on the Raspberry Pi's "
"Raspbian Linux-based operating system."
msgstr ""
"Sonic Piは現在、Minecraft Piと対話するためのシンプルなAPIをサポートしています。Minecraftの特別版は、Raspberry Pi"
"のLinuxベースのオペレーティングシステムRaspbianにデフォルトでインストールされています。"

#: C-Minecraft-Pi.md:9
msgid "No need to import libraries"
msgstr "ライブラリは不必要"

#: C-Minecraft-Pi.md:11
msgid ""
"The Minecraft Pi integration has been designed to be insanely easy to use. All"
" you need to do is to launch Minecraft Pi and create a world. You're then free"
" to use the `mc_*` fns just like you might use `play` and `synth`. There's no "
"need to import anything or install any libraries - it's all ready to go and wo"
"rks out of the box."
msgstr ""
"Minecraft Piは、とっても簡単に扱えるよう設計されています。必要なことは、Minecraft Piを起動してワールドを作成するだけです。その後、`"
"play`や`synth` を扱うように`mc_*`関数を自由に使えます。何かのライブラリをインストールしたり、インポートする必要はなく、そのまま使えます。"

#: C-Minecraft-Pi.md:17
msgid "Automatic Connection"
msgstr "自動接続"

#: C-Minecraft-Pi.md:19
msgid ""
"The Minecraft Pi API takes care of managing your connection to the Minecraft P"
"i application. This means you don't need to worry about a thing. If you try an"
"d use the Minecraft Pi API when Minecraft Pi isn't open, Sonic Pi will politel"
"y tell you. Similarly, if you close Minecraft Pi whilst you're still running a"
" `live_loop` that uses the API, the live loop will stop and politely tell you "
"that it can't connect. To reconnect, just launch Minecraft Pi again and Sonic "
"Pi will automatically detect and re-create the connection for you."
msgstr ""
"Minecraft Pi APIはMinecraft Piアプリケーションへの接続を可能にします。あなたは何も心配をしなくてもよいということです。Minec"
"raft Piを起動せずに、Minecraft Pi APIを使おうとした場合には、Sonic Piはこれを丁寧に教えてくれます。同様に、Minecraft"
" Pi APIを使っている`live_loop`が実行されている最中にMinecraft Piを閉じてしまった場合には、そのライブループを停止し、接続できて"
"ないことを丁寧に伝えてくれます。再接続するには、Minecraft Piを再び起動するだけで、Sonic Piが自動検出して、再接続を試みます。"

#: C-Minecraft-Pi.md:28
msgid "Designed to be Live Coded"
msgstr "ライブコーディングに対応した設計"

#: C-Minecraft-Pi.md:30
msgid ""
"The Minecraft Pi API has been designed to work seamlessly within `live_loop`s."
" This means it's possible to synchronise modifications in your Minecraft Pi wo"
"rlds with modifications in your Sonic Pi sounds. Instant Minecraft-based music"
" videos! Note however that Minecraft Pi is alpha software and is known to be s"
"lightly buggy. If you encounter any problems simply restart Minecraft Pi and c"
"arry on as before. Sonic Pi's automatic connection functionality will take car"
"e of things for you."
msgstr ""
"Minecraft Pi "
"APIは`live_loop`内でシームレスに動作するように設計されています。これは、"
"Sonic Piの音に変更を加え、Minecraft Piのワールドの変更と同期させることが可能"
"であることを意味します。インスタントなMinecraftベースのミュージックビデオです"
"！Minecraft Piはアルファ版のソフトウェアであり、わずかに不安定であることに注"
"意してください。何か問題が発生した場合は、単純にMinecraft "
"Piを再起動し、以前と同様に続けましょう。Sonic Piの自動接続機能が対応します。"

#: C-Minecraft-Pi.md:39
msgid "Requires a Raspberry Pi 2.0"
msgstr "Raspberry Pi 2.0が必要"

#: C-Minecraft-Pi.md:41
msgid ""
"It is highly recommended that you use a Raspberry Pi 2 if you wish to run both"
" Sonic Pi and Minecraft at the same time - especially if you want to use Sonic"
" Pi's sound capabilities."
msgstr ""
"Sonic PiとMinecraftの両方を同時に実行したい場合、特にSonic Piのサウンド機能を使用したい場合は、Raspberry Pi 2を使用す"
"ることをお勧めします。"

#: C-Minecraft-Pi.md:45
msgid "API Support"
msgstr "APIサポート"

#: C-Minecraft-Pi.md:47
#, fuzzy
msgid ""
"At this stage, Sonic Pi supports basic block and player manipulations which ar"
"e detailed in Section C.1. Support for event callbacks triggered by player int"
"eractions in the world is planned for a future release."
msgstr ""
"現段階では、Sonic Piは、次のセクション11.1に詳述されている基本ブロックとプレイヤーの操作をサポートしています。ワールド内のプレイヤーの相互作用に"
"よってトリガーされるイベントのコールバックのサポートは、将来のリリースバージョンで予定されています。"

#: C.01-Basic-API.md:1
#, fuzzy
msgid "C.1 Basic API"
msgstr "11.1 ベーシックなAPI"

#: C.01-Basic-API.md:3
msgid "Basic Minecraft Pi API"
msgstr "ベーシックなMinecraft Pi API"

#: C.01-Basic-API.md:5
msgid ""
"Sonic Pi currently supports the following basic interactions with Minecraft Pi"
":"
msgstr "Sonic Piは現在、下記のMinecraft Piの基本インタラクションをサポートしています:"

#: C.01-Basic-API.md:7 C.01-Basic-API.md:16
msgid "Displaying chat messages"
msgstr "チャットメッセージの表示"

#: C.01-Basic-API.md:8 C.01-Basic-API.md:33
msgid "Setting the position of the user"
msgstr "ユーザの位置設定"

#: C.01-Basic-API.md:9
msgid "Getting the position of the user"
msgstr "ユーザの位置情報の取得"

#: C.01-Basic-API.md:10
msgid "Setting the block type at a given coordinate"
msgstr "指定した座標のブロックタイプを設定"

#: C.01-Basic-API.md:11
msgid "Getting the block type at a given coordinate"
msgstr "指定した座標のブロックタイプを取得"

#: C.01-Basic-API.md:14
msgid "Let's look at each of these in turn."
msgstr "これらをそれぞれ順番に見てみましょう。"

#: C.01-Basic-API.md:18
msgid ""
"Let's see just how easy it is to control Minecraft Pi from Sonic Pi. First, ma"
"ke sure you have both Minecraft Pi and Sonic Pi open at the same time and also"
" make sure you've entered a Minecraft world and can walk around."
msgstr ""
"それではSonic PiからのMinecraft Piの制御が、どれだけ簡単か見てみましょう。まずはじめにMinecraft PiとSonic Piが同時に"
"起動していることを確認し、Minecraftのワールドに入って歩くことができることを確認してください。"

#: C.01-Basic-API.md:23
msgid "In a fresh Sonic Pi buffer simply enter the following code:"
msgstr "新しいSonic PiのBufferで、次のコードを入力してください。"

#: C.01-Basic-API.md:25
#, no-wrap
msgid "mc_message \"Hello from Sonic Pi\""
msgstr "mc_message \"Hello from Sonic Pi\""

#: C.01-Basic-API.md:29
msgid ""
"When you hit the *Run* button, you'll see your message flash up on the Minecra"
"ft window. Congratulations, you've written your first Minecraft code! That was"
" easy wasn't it."
msgstr ""
"*Run*ボタンを押すと、Minecraftウィンドウにメッセージが表示されます。おめでとう、あなたは初めてのMinecraftコードを書きました！ 簡単で"
"したよね。"

#: C.01-Basic-API.md:35
msgid ""
"Now, let's try a little magic. Let's teleport ourselves somewhere! Try the fol"
"lowing:"
msgstr "では、ちょっとした魔法を試してみましょう。どこかに瞬間移動してみましょう！ 以下を試してください。"

#: C.01-Basic-API.md:38
#, no-wrap
msgid "mc_teleport 50, 50, 50"
msgstr "mc_teleport 50, 50, 50"

#: C.01-Basic-API.md:42
#, fuzzy
msgid ""
"When you hit *Run* - boom! You're instantly transported to a new place. Most l"
"ikely it was somewhere in the sky and you fell down either to dry land or into"
" water. Now, what are those numbers: `50, 50, 50`? They're the coordinates of "
"the location you're trying to teleport to. Let's take a brief moment to explor"
"e what coordinates are and how they work because they're really, really import"
"ant for programming Minecraft."
msgstr ""
"`Run`を押すと、ブーン！ 新しい場所へあなたの座標が移動しました。たいていは、乾燥した土地、または水に落ちたか、空中のどこかでしょう。`50, 50, "
"50`、これらの数字は何でしょう？ これらは瞬間移動しようとしている場所の座標です。座標とは何なのか、そして座標がどのように動作するのかは、Minecraf"
"tをプログラムするにあたって本当に重要なので、少し時間を取って見ていきましょう。"

#: C.01-Basic-API.md:50
msgid "Coordinates"
msgstr "座標"

#: C.01-Basic-API.md:52
msgid ""
"Imagine a pirate's map with a big `X` marking the location of some treasure. T"
"he exact location of the `X` can be described with two numbers - how far along"
" the map from left to right and how far along the map from bottom to top. For "
"example `10cm` across and `8cm` up. These two numbers `10` and `8` are coordin"
"ates. You could easily imagine describing the locations of other stashes of tr"
"easure with other pairs of numbers. Perhaps there's a big chest of gold at `2`"
" across and `9` up..."
msgstr ""
"いくつかの宝の場所が大きな`X`でマーキングされた海賊の地図を想像してみてください。`X`の正確な位置は、左から右へ向かってどれくらい離れているか、下から上"
"へ向かってどのくらい離れているか、この2つの数字で場所を記述することができます。例えば、横へ`10cm`、上に`8cm`。これら2つの数字`10`と`8`が"
"座標です。他に隠された宝物の在処も別の2つの数字で容易に記述できることが想像できますね。おそらく、`2`つ横切り、`9`つ上には大きな金脈がありそうです…"

#: C.01-Basic-API.md:61
msgid ""
"Now, in Minecraft two numbers isn't quite enough. We also need to know how hig"
"h we are. We therefore need three numbers:"
msgstr ""
"さて、Minecraftの中では2つの数字では十分ではありません。それに加えて、私たちがどれだけ高い所にいるのかを知る必要があります。したがって、3つの数字"
"が必要になります。"

#: C.01-Basic-API.md:64
msgid "How far from right to left in the world - `x`"
msgstr "どのくらい右端から左に離れてるか - `x`"

#: C.01-Basic-API.md:65
msgid "How far from front to back in the world - `z`"
msgstr "どのくらい手前から奥へ離れてるか - `z`"

#: C.01-Basic-API.md:66
msgid "How high up we are in the world - `y`"
msgstr "どのくらい高くあがったか - `y`"

#: C.01-Basic-API.md:68
msgid ""
"One more thing - we typically describe these coordinates in this order `x`, `y"
"`, `z`."
msgstr "通常、`x`, `y`, `z`でこれらの座標を記述します。"

#: C.01-Basic-API.md:71
msgid "Finding your current coordinates"
msgstr "現在の座標を知る"

#: C.01-Basic-API.md:73
msgid ""
"Let's have a play with coordinates. Navigate to a nice place in the Minecraft "
"map and then switch over to Sonic Pi. Now enter the following:"
msgstr "座標を使って遊んでみましょう。Minecraftのマップで素敵な場所に移動した後、Sonic Piに切り替え、次を入力してください。"

#: C.01-Basic-API.md:76
#, no-wrap
msgid "puts mc_location"
msgstr "puts mc_location"

#: C.01-Basic-API.md:80
msgid ""
"When you hit the *Run* button you'll see the coordinates of your current posit"
"ion displayed in the log window. Take a note of them, then move forward in the"
" world and try again. Notice how the coordinates changed! Now, I recommend you"
" spend some time repeating exactly this - move a bit in the world, take a look"
" at the coordinates and repeat. Do this until you start to get a feel for how "
"the coordinates change when you move. Once you've understood how coordinates w"
"ork, programming with the Minecraft API will be a complete breeze."
msgstr ""
"`Run`ボタンを押すと、ログ画面に、現在位置の座標が表示されます。座標の値を書き留め、続いてワールド内で前方に移動し、再び試してみてください。座標がどのよ"
"うに変化するかに注目しましょう！ これを繰り返すのに時間を使うことをお勧めします。すなわち、ワールド内で少し動いては座標を見てみるということです。あなたが移"
"動すると座標がどのように変化するか感触を得られるまで、これを行いましょう。これを調整する方法が理解できれば、MinecraftのAPIを使用したプログラミン"
"グがほぼ完了します。"

#: C.01-Basic-API.md:89
msgid "Let's Build!"
msgstr "さぁ、構築しましょう!"

#: C.01-Basic-API.md:91
msgid ""
"Now that you know how to find the current position and to teleport using coord"
"inates, you have all the tools you need to start building things in Minecraft "
"with code. Let's say you want to make the block with coordinates `40`, `50`, `"
"60` to be glass. That's super easy:"
msgstr ""
"現在位置を取得する方法と、座標を利用して瞬間移動する方法を覚えたので、あなたはコードでMinecraft内に何かを構築し始めるために必要な道具をすべて持って"
"います。たとえば、座標`40`, `50`, `60`にガラスのブロックを作りたかったら、それはとっても簡単ですね。"

#: C.01-Basic-API.md:96
#, no-wrap
msgid "mc_set_block :glass, 40, 50, 60"
msgstr "mc_set_block :glass, 40, 50, 60"

#: C.01-Basic-API.md:100
msgid ""
"Haha, it really was that easy. To see your handywork just teleport nearby and "
"take a look:"
msgstr "ハハ、本当に簡単だったでしょう。作ったものを見るには、近くに瞬間移動してみましょう。"

#: C.01-Basic-API.md:103
#, no-wrap
msgid "mc_teleport 35, 50, 60"
msgstr "mc_teleport 35, 50, 60"

#: C.01-Basic-API.md:107
msgid ""
"Now turn around and you should see your glass block! Try changing it to diamon"
"d:"
msgstr "振り向くと、あなたの作ったガラスのブロックが表示されるはずです！ それをダイヤモンドに変更してみましょう。"

#: C.01-Basic-API.md:110
#, no-wrap
msgid "mc_set_block :diamond, 40, 50, 60"
msgstr "mc_set_block :diamond, 40, 50, 60"

#: C.01-Basic-API.md:114
msgid ""
"If you were looking in the right direction you might have even seen it change "
"in front of your eyes! This is the start of something exciting..."
msgstr "見る角度が合えば、それがあなたの目の前で変更されることだってあるのです！ これはエキサイティングな何かの始まりです…"

#: C.01-Basic-API.md:117
msgid "Looking at blocks"
msgstr "ブロックを調べる"

#: C.01-Basic-API.md:119
msgid ""
"Let's look at one last thing before we move onto something a bit more involved"
". Given a set of coordinates we can ask Minecraft what the type of a specific "
"block is. Let's try it with the diamond block you just created:"
msgstr ""
"少し複雑なことに移る前に、最後の1つを見てみましょう。座標を与え、特定のブロックの種類が何であるかをMinecraftに尋ねることができます。では、先ほど作"
"成したダイヤモンドブロックで試してみましょう。"

#: C.01-Basic-API.md:124
#, no-wrap
msgid "puts mc_get_block 40, 50, 60"
msgstr "puts mc_get_block 40, 50, 60"

#: C.01-Basic-API.md:128
msgid ""
"Yey! It's `:diamond`. Try changing it back to glass and asking again - does it"
" now say `:glass`? I'm sure it does :-)"
msgstr ""
"イェイ！ それは`:diamond`（ダイヤモンド）ですね。ガラスに戻して、もう一度尋ねてみましょう。`:glass`を示しましたか？ きっとそうなったでし"
"ょう(^o^)"

#: C.01-Basic-API.md:131
msgid "Available block types"
msgstr "使用可能なブロックタイプ"

#: C.01-Basic-API.md:133
msgid ""
"Before you go on a Minecraft Pi coding rampage, you might find this list of av"
"ailable block types useful:"
msgstr "Minecraft Piでコーディングで暴れに行く前に、利用可能なブロックタイプのリストがあると便利でしょう。以下に示します。"

#: C.01-Basic-API.md:136
#, no-wrap
msgid ""
"    :air\n"
"    :stone\n"
"    :grass\n"
"    :dirt\n"
"    :cobblestone\n"
"    :wood_plank\n"
"    :sapling\n"
"    :bedrock\n"
"    :water_flowing\n"
"    :water\n"
"    :water_stationary\n"
"    :lava_flowing\n"
"    :lava\n"
"    :lava_stationary\n"
"    :sand\n"
"    :gravel\n"
"    :gold_ore\n"
"    :iron_ore\n"
"    :coal_ore\n"
"    :wood\n"
"    :leaves\n"
"    :glass\n"
"    :lapis\n"
"    :lapis_lazuli_block\n"
"    :sandstone\n"
"    :bed\n"
"    :cobweb\n"
"    :grass_tall\n"
"    :flower_yellow\n"
"    :flower_cyan\n"
"    :mushroom_brown\n"
"    :mushroom_red\n"
"    :gold_block\n"
"    :gold\n"
"    :iron_block\n"
"    :iron\n"
"    :stone_slab_double\n"
"    :stone_slab\n"
"    :brick\n"
"    :brick_block\n"
"    :tnt\n"
"    :bookshelf\n"
"    :moss_stone\n"
"    :obsidian\n"
"    :torch\n"
"    :fire\n"
"    :stairs_wood\n"
"    :chest\n"
"    :diamond_ore\n"
"    :diamond_block\n"
"    :diamond\n"
"    :crafting_table\n"
"    :farmland\n"
"    :furnace_inactive\n"
"    :furnace_active\n"
"    :door_wood\n"
"    :ladder\n"
"    :stairs_cobblestone\n"
"    :door_iron\n"
"    :redstone_ore\n"
"    :snow\n"
"    :ice\n"
"    :snow_block\n"
"    :cactus\n"
"    :clay\n"
"    :sugar_cane\n"
"    :fence\n"
"    :glowstone_block\n"
"    :bedrock_invisible\n"
"    :stone_brick\n"
"    :glass_pane\n"
"    :melon\n"
"    :fence_gate\n"
"    :glowing_obsidian\n"
"    :nether_reactor_core"
msgstr ""
"    :air\t\t\t空気\n"
"    :stone\t\t\t石\n"
"    :grass\t\t\t草\n"
"    :dirt\t\t\t汚れ\n"
"    :cobblestone\t\t石畳\n"
"    :wood_plank\t\t木の板\n"
"    :sapling\t\t苗木\n"
"    :bedrock\t\t岩盤\n"
"    :water_flowing\t\t水流\n"
"    :water\t\t\t水\n"
"    :water_stationary\t静止した水\n"
"    :lava_flowing\t\t溶岩流\n"
"    :lava\t\t\t溶岩\n"
"    :lava_stationary\t固まった溶岩\n"
"    :sand\t\t\t砂\n"
"    :gravel\t\t\t砂利\n"
"    :gold_ore\t\t金の鉱石\n"
"    :iron_ore\t\t鉄鉱石\n"
"    :coal_ore\t\t石炭鉱石\n"
"    :wood\t\t\t木材\n"
"    :leaves\t\t\t葉\n"
"    :glass\t\t\tガラス\n"
"    :lapis\t\t\tラピス\n"
"    :lapis_lazuli_block\tラピスラズリブロック\n"
"    :sandstone\t\t砂岩\n"
"    :bed\t\t\tベッド\n"
"    :cobweb\t\t\tクモの巣\n"
"    :grass_tall\t\t背の高い草\n"
"    :flower_yellow\t\t黄色い花\n"
"    :flower_cyan\t\tシアン色の花\n"
"    :mushroom_brown\t\t茶色いキノコ\n"
"    :mushroom_red\t\t赤いキノコ\n"
"    :gold_block\t\t金のブロック\n"
"    :gold\t\t\t金\n"
"    :iron_block\t\t鉄のブロック\n"
"    :iron\t\t\t鉄\n"
"    :stone_slab_double\t石板（ダブル）\n"
"    :stone_slab\t\t石板\n"
"    :brick\t\t\tレンガ\n"
"    :brick_block\t\tレンガブロック\n"
"    :tnt\t\t\tTNT\n"
"    :bookshelf\t\t本棚\n"
"    :moss_stone\t\t苔石\n"
"    :obsidian\t\t黒曜石\n"
"    :torch\t\t\tトーチ\n"
"    :fire\t\t\t火\n"
"    :stairs_wood\t\t木の階段\n"
"    :chest\t\t\tチェスト\n"
"    :diamond_ore\t\tダイアモンドの鉱石\n"
"    :diamond_block\t\tダイアモンドのブロック\n"
"    :diamond\t\tダイアモンド\n"
"    :crafting_table\t\t作業テーブル\n"
"    :farmland\t\t農地\n"
"    :furnace_inactive\t廃炉\n"
"    :furnace_active\t\t炉\n"
"    :door_wood\t\t木のドア\n"
"    :ladder\t\t\tはしご\n"
"    :stairs_cobblestone\t石畳の階段\n"
"    :door_iron\t\t鉄のドア\n"
"    :redstone_ore\t\tレッドストーン鉱石\n"
"    :snow\t\t\t雪\n"
"    :ice\t\t\t氷\n"
"    :snow_block\t\t雪のブロック\n"
"    :cactus\t\t\tサボテン\n"
"    :clay\t\t\t粘土\n"
"    :sugar_cane\t\tサトウキビ\n"
"    :fence\t\t\tフェンズ\n"
"    :glowstone_block\t光る石のブロック\n"
"    :bedrock_invisible\t目に見えない岩盤\n"
"    :stone_brick\t\t石レンガ\n"
"    :glass_pane\t\tガラス板\n"
"    :melon\t\t\tメロン\n"
"    :fence_gate\t\tフェンスゲート\n"
"    :glowing_obsidian\t輝く黒曜石\n"
"    :nether_reactor_core\t原子炉コア"
